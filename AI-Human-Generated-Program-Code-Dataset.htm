<table class="table table-bordered table-hover table-condensed">
<thead><tr><th title="Field #1">id</th>
<th title="Field #2">problem_number</th>
<th title="Field #3">language</th>
<th title="Field #4">difficulty</th>
<th title="Field #5">generator_name</th>
<th title="Field #6">generator_type</th>
<th title="Field #7">description</th>
<th title="Field #8">prompt</th>
<th title="Field #9">ai_generated_code</th>
<th title="Field #10">human_generated_code</th>
</tr></thead>
<tbody><tr>
<td align="right">1</td>
<td align="right">1</td>
<td>Java</td>
<td>easy</td>
<td>Bing AI Chat</td>
<td>Chatbot</td>
<td>You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.<br/><br/>Return the maximum sum or -1 if no such pair exists.<br/><br/>Example 1:<br/><br/>Input: nums = [51,71,17,24,42]<br/>Output: 88<br/>Explanation: <br/>For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. <br/>For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.<br/>It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.<br/><br/>Example 2:<br/><br/>Input: nums = [1,2,3,4]<br/>Output: -1<br/>Explanation: No pair exists in nums with equal maximum digits.<br/><br/>Constraints:<br/><br/>2 &lt;= nums.length &lt;= 100<br/>1 &lt;= nums[i] &lt;= 10^4 </td>
<td>solve the following problem with java code. Class name: Solution, Method name: maxSum(int[] nums).<br/><br/>You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.<br/><br/>Return the maximum sum or -1 if no such pair exists.<br/><br/>Example 1:<br/><br/>Input: nums = [51,71,17,24,42]<br/>Output: 88<br/>Explanation: <br/>For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. <br/>For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.<br/>It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.<br/><br/>Example 2:<br/><br/>Input: nums = [1,2,3,4]<br/>Output: -1<br/>Explanation: No pair exists in nums with equal maximum digits.<br/><br/>Constraints:<br/><br/>2 &lt;= nums.length &lt;= 100<br/>1 &lt;= nums[i] &lt;= 10^4</td>
<td>Public Class Solution {<br/>    Public Int Maxsum(int[] Nums) {<br/>        Int[] Maxsum = New Int[10];<br/>        For (Int Num : Nums) {<br/>            Int Maxdigit = 0;<br/>            Int Temp = Num;<br/>            While (Temp &gt; 0) {<br/>                Maxdigit = Math.max(maxdigit, Temp % 10);<br/>                Temp /= 10;<br/>            }<br/>            For (Int I = 0; I &lt; 10; I++) {<br/>                If (I == Maxdigit) {<br/>                    Maxsum[i] = Math.max(maxsum[i], Num + Maxsum[i]);<br/>                } Else {<br/>                    Maxsum[i] = Math.max(maxsum[i], Num);<br/>                }<br/>            }<br/>        }<br/>        Int Res = -1;<br/>        For (Int Sum : Maxsum) {<br/>            Res = Math.max(res, Sum);<br/>        }<br/>        Return Res == 0 ? -1 : Res;<br/>    }<br/>}</td>
<td>Class Solution {<br/>    Public Int Maxsum(int[] Nums) {<br/>    Int Ans = -1;<br/>    Map&lt;integer,list&lt;integer&gt;&gt; Ump = New Hashmap&lt;&gt;();<br/>    For(int I = 0; I &lt; Nums.length; ++I){<br/>        Int T = Nums[i], Maxdigit = 0;<br/>        While(t != 0){ //Evaluate Max Digit In The Number<br/>            Maxdigit = Math.max(t%10, Maxdigit);<br/>            T = T/10;<br/>        }<br/>        If(!ump.containskey(maxdigit)) Ump.put(maxdigit, New Arraylist&lt;&gt;());<br/>        Ump.get(maxdigit).add(nums[i]); // Add The Number To The Map <br/>    }<br/>    For(map.entry&lt;integer, List&lt;integer&gt;&gt; Entry: Ump.entryset()){<br/>        Entry.getvalue().sort(comparator.reverseorder()); //To Find Max Two Number In Each Max Digit <br/>        If(entry.getvalue().size() &gt;= 2) Ans = Math.max(ans, Entry.getvalue().get(0) + Entry.getvalue().get(1)); //Sum Max Two Number And Take Max<br/>    }<br/>    Return Ans;<br/>    }<br/>}</td>
</tr>
<tr>
<td align="right">2</td>
<td align="right">1</td>
<td>Python</td>
<td>easy</td>
<td>Bing AI Chat</td>
<td>Chatbot</td>
<td>You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.<br/><br/>Return the maximum sum or -1 if no such pair exists.<br/><br/>Example 1:<br/><br/>Input: nums = [51,71,17,24,42]<br/>Output: 88<br/>Explanation: <br/>For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. <br/>For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.<br/>It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.<br/><br/>Example 2:<br/><br/>Input: nums = [1,2,3,4]<br/>Output: -1<br/>Explanation: No pair exists in nums with equal maximum digits.<br/><br/>Constraints:<br/><br/>2 &lt;= nums.length &lt;= 100<br/>1 &lt;= nums[i] &lt;= 10^4 </td>
<td>solve the following problem with python3 code. Class name: Solution, Method name: def maxSum(self, nums: List[int]) -&gt; int:.<br/><br/>You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.<br/><br/>Return the maximum sum or -1 if no such pair exists.<br/><br/>Example 1:<br/><br/>Input: nums = [51,71,17,24,42]<br/>Output: 88<br/>Explanation: <br/>For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. <br/>For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.<br/>It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.<br/><br/>Example 2:<br/><br/>Input: nums = [1,2,3,4]<br/>Output: -1<br/>Explanation: No pair exists in nums with equal maximum digits.<br/><br/>Constraints:<br/><br/>2 &lt;= nums.length &lt;= 100<br/>1 &lt;= nums[i] &lt;= 10^4</td>
<td>Class Solution:<br/>    Def Maxsum(self, Nums: List[int]) -&gt; Int:<br/>        Max_digit = {}<br/>        For Num In Nums:<br/>            Digit = Max(int(d) For D In Str(num))<br/>            If Digit Not In Max_digit:<br/>                Max_digit[digit] = []<br/>            Max_digit[digit].append(num)<br/>        Res = -1<br/>        For Digit, Values In Max_digit.items():<br/>            If Len(values) &gt;= 2:<br/>                Values.sort(reverse=true)<br/>                Res = Max(res, Values[0] + Values[1])<br/>        Return Res</td>
<td>Class Solution:<br/>    Def Maxsum(self, Nums: List[int]) -&gt; Int:<br/>        Max_by_digit = Defaultdict(int)<br/>        Max_sum = -1<br/><br/>        For Num In Nums:<br/>            Digit = Max(str(num))<br/><br/>            If Digit In Max_by_digit:<br/>                Max_sum = Max(max_sum, Max_by_digit[digit] + Num)<br/><br/>            Max_by_digit[digit] = Max(max_by_digit[digit], Num)<br/><br/>        Return Max_sum</td>
</tr>
<tr>
<td align="right">3</td>
<td align="right">1</td>
<td>C++</td>
<td>easy</td>
<td>Bing AI Chat</td>
<td>Chatbot</td>
<td>You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.<br/><br/>Return the maximum sum or -1 if no such pair exists.<br/><br/>Example 1:<br/><br/>Input: nums = [51,71,17,24,42]<br/>Output: 88<br/>Explanation: <br/>For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. <br/>For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.<br/>It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.<br/><br/>Example 2:<br/><br/>Input: nums = [1,2,3,4]<br/>Output: -1<br/>Explanation: No pair exists in nums with equal maximum digits.<br/><br/>Constraints:<br/><br/>2 &lt;= nums.length &lt;= 100<br/>1 &lt;= nums[i] &lt;= 10^4 </td>
<td>solve the following problem with C++ code. Class name: Solution, Method name: maxSum(std::vector&lt;int&gt;&amp; nums).<br/><br/>You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.<br/><br/>Return the maximum sum or -1 if no such pair exists.<br/><br/>Example 1:<br/><br/>Input: nums = [51,71,17,24,42]<br/>Output: 88<br/>Explanation: <br/>For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. <br/>For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.<br/>It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.<br/><br/>Example 2:<br/><br/>Input: nums = [1,2,3,4]<br/>Output: -1<br/>Explanation: No pair exists in nums with equal maximum digits.<br/><br/>Constraints:<br/><br/>2 &lt;= nums.length &lt;= 100<br/>1 &lt;= nums[i] &lt;= 10^4</td>
<td>Class Solution {<br/>Public:<br/>    Int Maxsum(std::vector&lt;int&gt;&amp; Nums) {<br/>        Int Maxsum = -1;<br/>        For (Int I = 0; I &lt; Nums.size(); I++) {<br/>            For (Int J = I + 1; J &lt; Nums.size(); J++) {<br/>                If (Maxdigit(nums[i]) == Maxdigit(nums[j])) {<br/>                    Maxsum = Std::max(maxsum, Nums[i] + Nums[j]);<br/>                }<br/>            }<br/>        }<br/>        Return Maxsum;<br/>    }<br/><br/>Private:<br/>    Int Maxdigit(int Num) {<br/>        Int Maxdigit = 0;<br/>        While (Num &gt; 0) {<br/>            Maxdigit = Std::max(maxdigit, Num % 10);<br/>            Num /= 10;<br/>        }<br/>        Return Maxdigit;<br/>    }<br/>};</td>
<td>Class Solution {<br/>    Public:<br/>        Int Maxsum(vector&lt;int&gt;&amp; Nums) {<br/>        Int Res = -1, Max_num[10] = {};<br/>        For (Auto Num : Nums) {<br/>            Int Max_d = 0;<br/>            For (Int V = Num; V; V /= 10)<br/>                Max_d = Max(max_d, V % 10);<br/>            If (Max_num[max_d])<br/>                Res = Max(res, Max_num[max_d] + Num);<br/>            Max_num[max_d] = Max(max_num[max_d], Num);<br/>        }<br/>        Return Res;<br/>    }<br/>};</td>
</tr>
<tr>
<td align="right">4</td>
<td align="right">2</td>
<td>Java</td>
<td>easy</td>
<td>Bing AI Chat</td>
<td>Chatbot</td>
<td>Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.<br/><br/>You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.<br/><br/>Return the final string that will be present on your laptop screen.<br/><br/>Example 1:<br/><br/>Input: s = &quot;string&quot;<br/>Output: &quot;rtsng&quot;<br/>Explanation: <br/>After typing first character, the text on the screen is &quot;s&quot;.<br/>After the second character, the text is &quot;st&quot;. <br/>After the third character, the text is &quot;str&quot;.<br/>Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.<br/>After the fifth character, the text is &quot;rtsn&quot;. <br/>After the sixth character, the text is &quot;rtsng&quot;. <br/>Therefore, we return &quot;rtsng&quot;.<br/><br/>Example 2:<br/><br/>Input: s = &quot;poiinter&quot;<br/>Output: &quot;ponter&quot;<br/>Explanation: <br/>After the first character, the text on the screen is &quot;p&quot;.<br/>After the second character, the text is &quot;po&quot;. <br/>Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. <br/>Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.<br/>After the fifth character, the text is &quot;pon&quot;.<br/>After the sixth character, the text is &quot;pont&quot;. <br/>After the seventh character, the text is &quot;ponte&quot;. <br/>After the eighth character, the text is &quot;ponter&quot;. <br/>Therefore, we return &quot;ponter&quot;.<br/> <br/>Constraints:<br/><br/>1 &lt;= s.length &lt;= 100<br/>s consists of lowercase English letters.<br/>s[0] != &#39;i&#39;</td>
<td>Solve the following problem with java code. Class name: Solution, Method name: finalString(String s).<br/><br/>Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.<br/><br/>You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.<br/><br/>Return the final string that will be present on your laptop screen.<br/><br/>Example 1:<br/><br/>Input: s = &quot;string&quot;<br/>Output: &quot;rtsng&quot;<br/>Explanation: <br/>After typing first character, the text on the screen is &quot;s&quot;.<br/>After the second character, the text is &quot;st&quot;. <br/>After the third character, the text is &quot;str&quot;.<br/>Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.<br/>After the fifth character, the text is &quot;rtsn&quot;. <br/>After the sixth character, the text is &quot;rtsng&quot;. <br/>Therefore, we return &quot;rtsng&quot;.<br/><br/>Example 2:<br/><br/>Input: s = &quot;poiinter&quot;<br/>Output: &quot;ponter&quot;<br/>Explanation: <br/>After the first character, the text on the screen is &quot;p&quot;.<br/>After the second character, the text is &quot;po&quot;. <br/>Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. <br/>Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.<br/>After the fifth character, the text is &quot;pon&quot;.<br/>After the sixth character, the text is &quot;pont&quot;. <br/>After the seventh character, the text is &quot;ponte&quot;. <br/>After the eighth character, the text is &quot;ponter&quot;. <br/>Therefore, we return &quot;ponter&quot;.<br/> <br/>Constraints:<br/><br/>1 &lt;= s.length &lt;= 100<br/>s consists of lowercase English letters.<br/>s[0] != &#39;i&#39;</td>
<td>Class Solution {<br/>    Public String Finalstring(string S) {<br/>        Stringbuilder Sb = New Stringbuilder();<br/>        For (Char C : S.tochararray()) {<br/>            If (C == &#39;I&#39;) {<br/>                Sb.reverse();<br/>            } Else {<br/>                Sb.append(c);<br/>            }<br/>        }<br/>        Return Sb.tostring();<br/>    }<br/>}</td>
<td>Class Solution {<br/>    Public String Finalstring(string S) {<br/>        Stringbuilder Nm=new Stringbuilder();<br/>        For(char C:s.tochararray())<br/>        {<br/>            If(c==&#39;i&#39;)<br/>            {<br/>                Nm.reverse();<br/>            }<br/>            Else<br/>            {<br/>                Nm.append(c);<br/>            }<br/>        }<br/>        Return Nm.tostring();<br/>    }<br/>}</td>
</tr>
<tr>
<td align="right">5</td>
<td align="right">2</td>
<td>Python</td>
<td>easy</td>
<td>Bing AI Chat</td>
<td>Chatbot</td>
<td>Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.<br/><br/>You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.<br/><br/>Return the final string that will be present on your laptop screen.<br/><br/>Example 1:<br/><br/>Input: s = &quot;string&quot;<br/>Output: &quot;rtsng&quot;<br/>Explanation: <br/>After typing first character, the text on the screen is &quot;s&quot;.<br/>After the second character, the text is &quot;st&quot;. <br/>After the third character, the text is &quot;str&quot;.<br/>Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.<br/>After the fifth character, the text is &quot;rtsn&quot;. <br/>After the sixth character, the text is &quot;rtsng&quot;. <br/>Therefore, we return &quot;rtsng&quot;.<br/><br/>Example 2:<br/><br/>Input: s = &quot;poiinter&quot;<br/>Output: &quot;ponter&quot;<br/>Explanation: <br/>After the first character, the text on the screen is &quot;p&quot;.<br/>After the second character, the text is &quot;po&quot;. <br/>Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. <br/>Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.<br/>After the fifth character, the text is &quot;pon&quot;.<br/>After the sixth character, the text is &quot;pont&quot;. <br/>After the seventh character, the text is &quot;ponte&quot;. <br/>After the eighth character, the text is &quot;ponter&quot;. <br/>Therefore, we return &quot;ponter&quot;.<br/> <br/>Constraints:<br/><br/>1 &lt;= s.length &lt;= 100<br/>s consists of lowercase English letters.<br/>s[0] != &#39;i&#39;</td>
<td>Solve the following problem with python3 code. Class name: Solution, Method name: def finalString(self, s: str) -&gt; str:.<br/><br/>Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.<br/><br/>You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.<br/><br/>Return the final string that will be present on your laptop screen.<br/><br/>Example 1:<br/><br/>Input: s = &quot;string&quot;<br/>Output: &quot;rtsng&quot;<br/>Explanation: <br/>After typing first character, the text on the screen is &quot;s&quot;.<br/>After the second character, the text is &quot;st&quot;. <br/>After the third character, the text is &quot;str&quot;.<br/>Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.<br/>After the fifth character, the text is &quot;rtsn&quot;. <br/>After the sixth character, the text is &quot;rtsng&quot;. <br/>Therefore, we return &quot;rtsng&quot;.<br/><br/>Example 2:<br/><br/>Input: s = &quot;poiinter&quot;<br/>Output: &quot;ponter&quot;<br/>Explanation: <br/>After the first character, the text on the screen is &quot;p&quot;.<br/>After the second character, the text is &quot;po&quot;. <br/>Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. <br/>Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.<br/>After the fifth character, the text is &quot;pon&quot;.<br/>After the sixth character, the text is &quot;pont&quot;. <br/>After the seventh character, the text is &quot;ponte&quot;. <br/>After the eighth character, the text is &quot;ponter&quot;. <br/>Therefore, we return &quot;ponter&quot;.<br/> <br/>Constraints:<br/><br/>1 &lt;= s.length &lt;= 100<br/>s consists of lowercase English letters.<br/>s[0] != &#39;i&#39;</td>
<td>Class Solution:<br/>    Def Finalstring(self, S: Str) -&gt; Str:<br/>        Res = &quot;&quot;<br/>        For C In S:<br/>            If C == &#39;I&#39;:<br/>                Res = Res[::-1]<br/>            Else:<br/>                Res += C<br/>        Return Res</td>
<td>Class Solution:<br/>    Def Finalstring(self, S: Str) -&gt; Str:<br/>        While &quot;I&quot; In S:<br/>            Index=s.index(&quot;i&quot;)<br/><br/>            #First Half And Second Half<br/>            First=s[:index][::-1]<br/>            Second=s[index+1:]<br/><br/>            S=&quot;&quot;.join([first,second])<br/>        Return S</td>
</tr>
<tr>
<td align="right">6</td>
<td align="right">2</td>
<td>C++</td>
<td>easy</td>
<td>Bing AI Chat</td>
<td>Chatbot</td>
<td>Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.<br/><br/>You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.<br/><br/>Return the final string that will be present on your laptop screen.<br/><br/>Example 1:<br/><br/>Input: s = &quot;string&quot;<br/>Output: &quot;rtsng&quot;<br/>Explanation: <br/>After typing first character, the text on the screen is &quot;s&quot;.<br/>After the second character, the text is &quot;st&quot;. <br/>After the third character, the text is &quot;str&quot;.<br/>Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.<br/>After the fifth character, the text is &quot;rtsn&quot;. <br/>After the sixth character, the text is &quot;rtsng&quot;. <br/>Therefore, we return &quot;rtsng&quot;.<br/><br/>Example 2:<br/><br/>Input: s = &quot;poiinter&quot;<br/>Output: &quot;ponter&quot;<br/>Explanation: <br/>After the first character, the text on the screen is &quot;p&quot;.<br/>After the second character, the text is &quot;po&quot;. <br/>Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. <br/>Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.<br/>After the fifth character, the text is &quot;pon&quot;.<br/>After the sixth character, the text is &quot;pont&quot;. <br/>After the seventh character, the text is &quot;ponte&quot;. <br/>After the eighth character, the text is &quot;ponter&quot;. <br/>Therefore, we return &quot;ponter&quot;.<br/> <br/>Constraints:<br/><br/>1 &lt;= s.length &lt;= 100<br/>s consists of lowercase English letters.<br/>s[0] != &#39;i&#39;</td>
<td>Solve the following problem with C++ code. Class name: Solution, Method name: string finalString(string s).<br/><br/>Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.<br/><br/>You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.<br/><br/>Return the final string that will be present on your laptop screen.<br/><br/>Example 1:<br/><br/>Input: s = &quot;string&quot;<br/>Output: &quot;rtsng&quot;<br/>Explanation: <br/>After typing first character, the text on the screen is &quot;s&quot;.<br/>After the second character, the text is &quot;st&quot;. <br/>After the third character, the text is &quot;str&quot;.<br/>Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.<br/>After the fifth character, the text is &quot;rtsn&quot;. <br/>After the sixth character, the text is &quot;rtsng&quot;. <br/>Therefore, we return &quot;rtsng&quot;.<br/><br/>Example 2:<br/><br/>Input: s = &quot;poiinter&quot;<br/>Output: &quot;ponter&quot;<br/>Explanation: <br/>After the first character, the text on the screen is &quot;p&quot;.<br/>After the second character, the text is &quot;po&quot;. <br/>Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. <br/>Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.<br/>After the fifth character, the text is &quot;pon&quot;.<br/>After the sixth character, the text is &quot;pont&quot;. <br/>After the seventh character, the text is &quot;ponte&quot;. <br/>After the eighth character, the text is &quot;ponter&quot;. <br/>Therefore, we return &quot;ponter&quot;.<br/> <br/>Constraints:<br/><br/>1 &lt;= s.length &lt;= 100<br/>s consists of lowercase English letters.<br/>s[0] != &#39;i&#39;</td>
<td>Class Solution {<br/>Public:<br/>    Std::string Finalstring(std::string S) {<br/>        Std::string Result = &quot;&quot;;<br/>        For (Char C : S) {<br/>            If (C == &#39;I&#39;) {<br/>                Std::reverse(result.begin(), Result.end());<br/>            } Else {<br/>                Result += C;<br/>            }<br/>        }<br/>        Return Result;<br/>    }<br/>};</td>
<td>Class Solution {<br/>Public:<br/>    String Finalstring(const String &amp;S) {<br/>        String A, B;<br/>        For (Char Ch : S)<br/>            If (Ch == &#39;I&#39;)<br/>                Swap(a, B);<br/>            Else<br/>                A += Ch;<br/>        Return String(rbegin(b), Rend(b)) + A;<br/>    }<br/>};</td>
</tr>
<tr>
<td align="right">7</td>
<td align="right">3</td>
<td>Java</td>
<td>medium</td>
<td>Bing AI Chat</td>
<td>Chatbot</td>
<td>You are given a 0-indexed integer array nums and an integer x.<br/><br/>Find the minimum absolute difference between two elements in the array that are at least x indices apart.<br/><br/>In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.<br/><br/>Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.<br/><br/>Example 1:<br/><br/>Input: nums = [4,3,2,4], x = 2<br/>Output: 0<br/>Explanation: We can select nums[0] = 4 and nums[3] = 4. <br/>They are at least 2 indices apart, and their absolute difference is the minimum, 0. <br/>It can be shown that 0 is the optimal answer.<br/><br/>Example 2:<br/><br/>Input: nums = [5,3,2,10,15], x = 1<br/>Output: 1<br/>Explanation: We can select nums[1] = 3 and nums[2] = 2.<br/>They are at least 1 index apart, and their absolute difference is the minimum, 1.<br/>It can be shown that 1 is the optimal answer.<br/><br/>Example 3:<br/><br/>Input: nums = [1,2,3,4], x = 3<br/>Output: 3<br/>Explanation: We can select nums[0] = 1 and nums[3] = 4.<br/>They are at least 3 indices apart, and their absolute difference is the minimum, 3.<br/>It can be shown that 3 is the optimal answer.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^9<br/>0 &lt;= x &lt; nums.length </td>
<td>Solve the following problem with java code. Class name: Solution, Method name: minAbsoluteDifference(List&lt;Integer&gt; nums, int x).<br/><br/>You are given a 0-indexed integer array nums and an integer x.<br/><br/>Find the minimum absolute difference between two elements in the array that are at least x indices apart.<br/><br/>In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.<br/><br/>Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.<br/><br/>Example 1:<br/><br/>Input: nums = [4,3,2,4], x = 2<br/>Output: 0<br/>Explanation: We can select nums[0] = 4 and nums[3] = 4. <br/>They are at least 2 indices apart, and their absolute difference is the minimum, 0. <br/>It can be shown that 0 is the optimal answer.<br/><br/>Example 2:<br/><br/>Input: nums = [5,3,2,10,15], x = 1<br/>Output: 1<br/>Explanation: We can select nums[1] = 3 and nums[2] = 2.<br/>They are at least 1 index apart, and their absolute difference is the minimum, 1.<br/>It can be shown that 1 is the optimal answer.<br/><br/>Example 3:<br/><br/>Input: nums = [1,2,3,4], x = 3<br/>Output: 3<br/>Explanation: We can select nums[0] = 1 and nums[3] = 4.<br/>They are at least 3 indices apart, and their absolute difference is the minimum, 3.<br/>It can be shown that 3 is the optimal answer.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^9<br/>0 &lt;= x &lt; nums.length</td>
<td>Public Class Solution {<br/>    Public Int Minabsolutedifference(list&lt;integer&gt; Nums, Int X) {<br/>        Treemap&lt;integer, Integer&gt; Map = New Treemap&lt;&gt;();<br/>        Map.put(nums.get(0), 0);<br/>        Int N = Nums.size();<br/>        Int Mindiff = Integer.max_value;<br/><br/>        For (Int I = 1; I &lt; N; I++) {<br/>            If (I &gt;= X) {<br/>                Map.remove(nums.get(i - X));<br/>            }<br/>            Integer Lower = Map.floorkey(nums.get(i));<br/>            Integer Higher = Map.ceilingkey(nums.get(i));<br/>            If (Lower != Null) {<br/>                Mindiff = Math.min(mindiff, Math.abs(nums.get(i) - Lower));<br/>            }<br/>            If (Higher != Null) {<br/>                Mindiff = Math.min(mindiff, Math.abs(nums.get(i) - Higher));<br/>            }<br/>            Map.put(nums.get(i), I);<br/>        }<br/><br/>        Return Mindiff;<br/>    }<br/>}</td>
<td>Class Solution {<br/>    Int Minabsolutedifference(list&lt;integer&gt; Nums, Int X) {<br/>        Int Ans = Integer.max_value;<br/>        Treeset&lt;integer&gt; S = New Treeset&lt;&gt;();<br/>        For(int I = X; I &lt; Nums.size(); ++I){<br/>            S.add(nums.get(i-x));<br/>            Integer High = S.ceiling(nums.get(i)), Low = S.floor(nums.get(i));<br/>            If(high != Null) Ans = Math.min(ans, Math.abs(nums.get(i) - High));<br/>            If(low != Null) Ans = Math.min(ans, Math.abs(nums.get(i) - Low));<br/>        }<br/>        Return Ans;<br/>    }<br/>}</td>
</tr>
<tr>
<td align="right">8</td>
<td align="right">3</td>
<td>Python</td>
<td>medium</td>
<td>Bing AI Chat</td>
<td>Chatbot</td>
<td>You are given a 0-indexed integer array nums and an integer x.<br/><br/>Find the minimum absolute difference between two elements in the array that are at least x indices apart.<br/><br/>In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.<br/><br/>Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.<br/><br/>Example 1:<br/><br/>Input: nums = [4,3,2,4], x = 2<br/>Output: 0<br/>Explanation: We can select nums[0] = 4 and nums[3] = 4. <br/>They are at least 2 indices apart, and their absolute difference is the minimum, 0. <br/>It can be shown that 0 is the optimal answer.<br/><br/>Example 2:<br/><br/>Input: nums = [5,3,2,10,15], x = 1<br/>Output: 1<br/>Explanation: We can select nums[1] = 3 and nums[2] = 2.<br/>They are at least 1 index apart, and their absolute difference is the minimum, 1.<br/>It can be shown that 1 is the optimal answer.<br/><br/>Example 3:<br/><br/>Input: nums = [1,2,3,4], x = 3<br/>Output: 3<br/>Explanation: We can select nums[0] = 1 and nums[3] = 4.<br/>They are at least 3 indices apart, and their absolute difference is the minimum, 3.<br/>It can be shown that 3 is the optimal answer.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^9<br/>0 &lt;= x &lt; nums.length </td>
<td>Solve the following problem with python3 code. Class name: Solution, Method name: def minAbsoluteDifference(self, nums: List[int], x: int) -&gt; int:.<br/><br/>You are given a 0-indexed integer array nums and an integer x.<br/><br/>Find the minimum absolute difference between two elements in the array that are at least x indices apart.<br/><br/>In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.<br/><br/>Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.<br/><br/>Example 1:<br/><br/>Input: nums = [4,3,2,4], x = 2<br/>Output: 0<br/>Explanation: We can select nums[0] = 4 and nums[3] = 4. <br/>They are at least 2 indices apart, and their absolute difference is the minimum, 0. <br/>It can be shown that 0 is the optimal answer.<br/><br/>Example 2:<br/><br/>Input: nums = [5,3,2,10,15], x = 1<br/>Output: 1<br/>Explanation: We can select nums[1] = 3 and nums[2] = 2.<br/>They are at least 1 index apart, and their absolute difference is the minimum, 1.<br/>It can be shown that 1 is the optimal answer.<br/><br/>Example 3:<br/><br/>Input: nums = [1,2,3,4], x = 3<br/>Output: 3<br/>Explanation: We can select nums[0] = 1 and nums[3] = 4.<br/>They are at least 3 indices apart, and their absolute difference is the minimum, 3.<br/>It can be shown that 3 is the optimal answer.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^9<br/>0 &lt;= x &lt; nums.length</td>
<td>Class Solution:<br/>    Def Minabsolutedifference(self, Nums: List[int], X: Int) -&gt; Int:<br/>        N = Len(nums)<br/>        Min_diff = Float(&#39;inf&#39;)<br/>        For I In Range(n):<br/>            For J In Range(i + X, N):<br/>                Min_diff = Min(min_diff, Abs(nums[i] - Nums[j]))<br/>        Return Min_diff</td>
<td>Class Solution:<br/>  Def Minabsolutedifference(self, Nums: List[int], X: Int) -&gt; Int:<br/>    If X == 0:<br/>      Return 0<br/><br/>    Arr, Best_dist = Sortedlist([]), Float(&#39;inf&#39;)<br/>    For I In Range(x, Len(nums)):<br/>      Arr.add(nums[i - X])<br/>      V = Nums[i]<br/><br/>      Pos = Arr.bisect_left(v)<br/>      If Pos &lt; Len(arr):<br/>        Best_dist = Min(best_dist, Abs(arr[pos] - V))<br/>      If Pos &gt; 0:<br/>        Best_dist = Min(best_dist, Abs(arr[pos - 1] - V))<br/>    <br/>    Return Best_dist</td>
</tr>
<tr>
<td align="right">9</td>
<td align="right">3</td>
<td>C++</td>
<td>medium</td>
<td>Bing AI Chat</td>
<td>Chatbot</td>
<td>You are given a 0-indexed integer array nums and an integer x.<br/><br/>Find the minimum absolute difference between two elements in the array that are at least x indices apart.<br/><br/>In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.<br/><br/>Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.<br/><br/>Example 1:<br/><br/>Input: nums = [4,3,2,4], x = 2<br/>Output: 0<br/>Explanation: We can select nums[0] = 4 and nums[3] = 4. <br/>They are at least 2 indices apart, and their absolute difference is the minimum, 0. <br/>It can be shown that 0 is the optimal answer.<br/><br/>Example 2:<br/><br/>Input: nums = [5,3,2,10,15], x = 1<br/>Output: 1<br/>Explanation: We can select nums[1] = 3 and nums[2] = 2.<br/>They are at least 1 index apart, and their absolute difference is the minimum, 1.<br/>It can be shown that 1 is the optimal answer.<br/><br/>Example 3:<br/><br/>Input: nums = [1,2,3,4], x = 3<br/>Output: 3<br/>Explanation: We can select nums[0] = 1 and nums[3] = 4.<br/>They are at least 3 indices apart, and their absolute difference is the minimum, 3.<br/>It can be shown that 3 is the optimal answer.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^9<br/>0 &lt;= x &lt; nums.length </td>
<td>Solve the following problem with C++ code. Class name: Solution, Method name: int minAbsoluteDifference(vector&lt;int&gt;&amp; nums, int x).<br/><br/>You are given a 0-indexed integer array nums and an integer x.<br/><br/>Find the minimum absolute difference between two elements in the array that are at least x indices apart.<br/><br/>In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.<br/><br/>Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.<br/><br/>Example 1:<br/><br/>Input: nums = [4,3,2,4], x = 2<br/>Output: 0<br/>Explanation: We can select nums[0] = 4 and nums[3] = 4. <br/>They are at least 2 indices apart, and their absolute difference is the minimum, 0. <br/>It can be shown that 0 is the optimal answer.<br/><br/>Example 2:<br/><br/>Input: nums = [5,3,2,10,15], x = 1<br/>Output: 1<br/>Explanation: We can select nums[1] = 3 and nums[2] = 2.<br/>They are at least 1 index apart, and their absolute difference is the minimum, 1.<br/>It can be shown that 1 is the optimal answer.<br/><br/>Example 3:<br/><br/>Input: nums = [1,2,3,4], x = 3<br/>Output: 3<br/>Explanation: We can select nums[0] = 1 and nums[3] = 4.<br/>They are at least 3 indices apart, and their absolute difference is the minimum, 3.<br/>It can be shown that 3 is the optimal answer.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^9<br/>0 &lt;= x &lt; nums.length</td>
<td>Class Solution {<br/>Public:<br/>    Int Minabsolutedifference(std::vector&lt;int&gt;&amp; Nums, Int X) {<br/>        Int Mindiff = Int_max;<br/>        For (Int I = 0; I &lt; Nums.size(); I++) {<br/>            For (Int J = I + X; J &lt; Nums.size(); J++) {<br/>                Mindiff = Std::min(mindiff, Std::abs(nums[i] - Nums[j]));<br/>            }<br/>        }<br/>        Return Mindiff;<br/>    }<br/>};</td>
<td>Class Solution {<br/>Public:<br/>    Int Minabsolutedifference(vector&lt;int&gt;&amp; Nums, Int X) {<br/>        Int Ans = Int_max;<br/>        Set&lt;int&gt; S;<br/>        For(int I = X; I &lt; Nums.size(); ++I){<br/>            S.insert(nums[i-x]);<br/>            Auto It = S.upper_bound(nums[i]);<br/>            If(it != S.end()) Ans = Min(ans, Abs(nums[i] - *It));<br/>            If(it != S.begin()) Ans = Min(ans, Abs(nums[i] - *Prev(it)));<br/>        }<br/>        Return Ans;<br/>    }<br/>};</td>
</tr>
<tr>
<td align="right">10</td>
<td align="right">4</td>
<td>Java</td>
<td>medium</td>
<td>Bing AI Chat</td>
<td>Chatbot</td>
<td>You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.<br/><br/>Return the head of the linked list after doubling it.<br/><br/>Example 1:<br/><br/>Input: head = [1,8,9]<br/>Output: [3,7,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.<br/><br/>Example 2:<br/><br/>Input: head = [9,9,9]<br/>Output: [1,9,9,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. <br/><br/>Constraints:<br/><br/>The number of nodes in the list is in the range [1, 10^4]<br/>0 &lt;= Node.val &lt;= 9<br/>The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself. </td>
<td>Solve the following problem with java code. Class name: Solution, Method name: doubleIt(ListNode head).<br/><br/>You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.<br/><br/>Return the head of the linked list after doubling it.<br/><br/>Example 1:<br/><br/>Input: head = [1,8,9]<br/>Output: [3,7,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.<br/><br/>Example 2:<br/><br/>Input: head = [9,9,9]<br/>Output: [1,9,9,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. <br/><br/>Constraints:<br/><br/>The number of nodes in the list is in the range [1, 10^4]<br/>0 &lt;= Node.val &lt;= 9<br/>The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.</td>
<td>Class Solution {<br/>    Public Listnode Doubleit(listnode Head) {<br/>        // Convert Linked List To Number<br/>        Long Num = 0;<br/>        While (Head != Null) {<br/>            Num = Num * 10 + Head.val;<br/>            Head = Head.next;<br/>        }<br/><br/>        // Double The Number<br/>        Num *= 2;<br/><br/>        // Convert Number Back To Linked List<br/>        Listnode Dummy = New Listnode(0);<br/>        Listnode Curr = Dummy;<br/>        Do {<br/>            Curr.next = New Listnode((int)(num % 10));<br/>            Num /= 10;<br/>            Curr = Curr.next;<br/>        } While (Num &gt; 0);<br/><br/>        // Reverse The Linked List And Return<br/>        Return Reverse(dummy.next);<br/>    }<br/><br/>    Private Listnode Reverse(listnode Head) {<br/>        Listnode Prev = Null;<br/>        While (Head != Null) {<br/>            Listnode Next = Head.next;<br/>            Head.next = Prev;<br/>            Prev = Head;<br/>            Head = Next;<br/>        }<br/>        Return Prev;<br/>    }<br/>}</td>
<td>Class Solution {<br/>    Public Listnode Doubleit(listnode Head) {<br/>        If (Head.val &gt; 4)<br/>            Head = New Listnode(0, Head);<br/>        For(listnode Node = Head; Node != Null; Node = Node.next) {<br/>            Node.val = (Node.val * 2) % 10;<br/>            If (Node.next != Null &amp;&amp; Node.next.val &gt; 4)<br/>                Node.val++;<br/>        }<br/>        Return Head;<br/>    }<br/>}</td>
</tr>
<tr>
<td align="right">11</td>
<td align="right">4</td>
<td>Python</td>
<td>medium</td>
<td>Bing AI Chat</td>
<td>Chatbot</td>
<td>You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.<br/><br/>Return the head of the linked list after doubling it.<br/><br/>Example 1:<br/><br/>Input: head = [1,8,9]<br/>Output: [3,7,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.<br/><br/>Example 2:<br/><br/>Input: head = [9,9,9]<br/>Output: [1,9,9,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. <br/><br/>Constraints:<br/><br/>The number of nodes in the list is in the range [1, 10^4]<br/>0 &lt;= Node.val &lt;= 9<br/>The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself. </td>
<td>Solve the following problem with python3 code. Class name: Solution, Method name: def doubleIt(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:.<br/><br/>You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.<br/><br/>Return the head of the linked list after doubling it.<br/><br/>Example 1:<br/><br/>Input: head = [1,8,9]<br/>Output: [3,7,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.<br/><br/>Example 2:<br/><br/>Input: head = [9,9,9]<br/>Output: [1,9,9,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. <br/><br/>Constraints:<br/><br/>The number of nodes in the list is in the range [1, 10^4]<br/>0 &lt;= Node.val &lt;= 9<br/>The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.</td>
<td>Class Solution:<br/>    Def Doubleit(self, Head: Optional[listnode]) -&gt; Optional[listnode]:<br/>        # Convert Linked List To Integer<br/>        Num = 0<br/>        Curr = Head<br/>        While Curr:<br/>            Num = Num * 10 + Curr.val<br/>            Curr = Curr.next<br/><br/>        # Double The Integer<br/>        Num *= 2<br/><br/>        # Convert Integer To Linked List<br/>        Dummy = Listnode(0)<br/>        Curr = Dummy<br/>        For Digit In Str(num):<br/>            Curr.next = Listnode(int(digit))<br/>            Curr = Curr.next<br/><br/>        Return Dummy.next</td>
<td>Class Solution:<br/>    Def Doubleit(self, Head: Optional[listnode]) -&gt; Optional[listnode]:<br/>        If Head.val &gt; 4:<br/>            Head = Listnode(0, Head)<br/>        Node = Head<br/>        While Node:<br/>            Node.val = (Node.val * 2) % 10<br/>            If Node.next And Node.next.val &gt; 4:<br/>                Node.val += 1<br/>            Node = Node.next<br/>        Return Head</td>
</tr>
<tr>
<td align="right">12</td>
<td align="right">4</td>
<td>C++</td>
<td>medium</td>
<td>Bing AI Chat</td>
<td>Chatbot</td>
<td>You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.<br/><br/>Return the head of the linked list after doubling it.<br/><br/>Example 1:<br/><br/>Input: head = [1,8,9]<br/>Output: [3,7,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.<br/><br/>Example 2:<br/><br/>Input: head = [9,9,9]<br/>Output: [1,9,9,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. <br/><br/>Constraints:<br/><br/>The number of nodes in the list is in the range [1, 10^4]<br/>0 &lt;= Node.val &lt;= 9<br/>The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself. </td>
<td>Solve the following problem with C++ code. Class name: Solution, Method name: ListNode* doubleIt(ListNode* head).<br/><br/>You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.<br/><br/>Return the head of the linked list after doubling it.<br/><br/>Example 1:<br/><br/>Input: head = [1,8,9]<br/>Output: [3,7,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.<br/><br/>Example 2:<br/><br/>Input: head = [9,9,9]<br/>Output: [1,9,9,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. <br/><br/>Constraints:<br/><br/>The number of nodes in the list is in the range [1, 10^4]<br/>0 &lt;= Node.val &lt;= 9<br/>The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.</td>
<td>Class Solution {<br/>Public:<br/>    Listnode* Doubleit(listnode* Head) {<br/>        Listnode* Current = Head;<br/>        Int Carry = 0;<br/>        While (Current != Nullptr) {<br/>            Int Sum = Current-&gt;val * 2 + Carry;<br/>            Current-&gt;val = Sum % 10;<br/>            Carry = Sum / 10;<br/>            If (Current-&gt;next == Nullptr &amp;&amp; Carry &gt; 0) {<br/>                Current-&gt;next = New Listnode(carry);<br/>                Break;<br/>            }<br/>            Current = Current-&gt;next;<br/>        }<br/>        Return Head;<br/>    }<br/>};</td>
<td>Class Solution {<br/>Public:<br/>    Listnode* Doubleit(listnode* Head) {<br/>        If (Head-&gt;val &gt; 4)<br/>            Head = New Listnode(0, Head);<br/>        For(listnode* Node = Head; Node; Node = Node-&gt;next) {<br/>            Node-&gt;val = (Node-&gt;val * 2) % 10;<br/>            If (Node-&gt;next &amp;&amp; Node-&gt;next-&gt;val &gt; 4)<br/>                Node-&gt;val++;<br/>        }<br/>        Return Head;<br/>    }<br/>};</td>
</tr>
<tr>
<td align="right">13</td>
<td align="right">5</td>
<td>Java</td>
<td>hard</td>
<td>Bing AI Chat</td>
<td>Chatbot</td>
<td>You are given an array nums of n positive integers and an integer k.<br/><br/>Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:<br/><br/>Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.<br/>Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.<br/>Multiply your score by x.<br/>Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.<br/><br/>The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.<br/><br/>Return the maximum possible score after applying at most k operations.<br/><br/>Since the answer may be large, return it modulo 10^9 + 7.<br/><br/>Example 1:<br/><br/>Input: nums = [8,3,9,3,8], k = 2<br/>Output: 81<br/>Explanation: To get a score of 81, we can apply the following operations:<br/>- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.<br/>It can be proven that 81 is the highest score one can obtain.<br/><br/>Example 2:<br/><br/>Input: nums = [19,12,14,6,10,18], k = 3<br/>Output: 4788<br/>Explanation: To get a score of 4788, we can apply the following operations: <br/>- Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.<br/>- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.<br/>It can be proven that 4788 is the highest score one can obtain.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length == n &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^5<br/>1 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9) </td>
<td>Solve the following problem with java code. Class name: Solution, Method name: maximumScore(List&lt;Integer&gt; nums, int k).<br/><br/>You are given an array nums of n positive integers and an integer k.<br/><br/>Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:<br/><br/>Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.<br/>Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.<br/>Multiply your score by x.<br/>Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.<br/><br/>The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.<br/><br/>Return the maximum possible score after applying at most k operations.<br/><br/>Since the answer may be large, return it modulo 10^9 + 7.<br/><br/>Example 1:<br/><br/>Input: nums = [8,3,9,3,8], k = 2<br/>Output: 81<br/>Explanation: To get a score of 81, we can apply the following operations:<br/>- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.<br/>It can be proven that 81 is the highest score one can obtain.<br/><br/>Example 2:<br/><br/>Input: nums = [19,12,14,6,10,18], k = 3<br/>Output: 4788<br/>Explanation: To get a score of 4788, we can apply the following operations: <br/>- Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.<br/>- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.<br/>It can be proven that 4788 is the highest score one can obtain.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length == n &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^5<br/>1 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9).</td>
<td>Public Class Solution {<br/>    Private Static Final Int Mod = 1_000_000_007;<br/>    Private List&lt;integer&gt; Nums;<br/>    Private Int N;<br/>    Private List&lt;integer&gt;[] Factors;<br/><br/>    Public Int Maximumscore(list&lt;integer&gt; Nums, Int K) {<br/>        This.nums = Nums;<br/>        This.n = Nums.size();<br/>        This.factors = New Arraylist[n];<br/>        For (Int I = 0; I &lt; N; I++) {<br/>            Factors[i] = Primefactors(nums.get(i));<br/>        }<br/><br/>        Priorityqueue&lt;int[]&gt; Pq = New Priorityqueue&lt;&gt;((a, B) -&gt; B[2] - A[2]);<br/>        Pq.offer(new Int[]{0, N - 1, Maxprimescore(0, N - 1)});<br/><br/>        Long Res = 1;<br/>        Boolean[] Chosen = New Boolean[n];<br/>        While (K-- &gt; 0) {<br/>            Int[] Cur = Pq.poll();<br/>            Int L = Cur[0], R = Cur[1], Maxscore = Cur[2];<br/>            Res = (Res * Maxscore) % Mod;<br/><br/>            Int Maxidx = Maxprimescoreindex(l, R);<br/>            Chosen[maxidx] = True;<br/><br/>            If (Maxidx - 1 &gt;= L &amp;&amp; !Chosen[maxidx - 1]) {<br/>                Pq.offer(new Int[]{l, Maxidx - 1, Maxprimescore(l, Maxidx - 1)});<br/>            }<br/>            If (Maxidx + 1 &lt;= R &amp;&amp; !Chosen[maxidx + 1]) {<br/>                Pq.offer(new Int[]{maxidx + 1, R, Maxprimescore(maxidx + 1, R)});<br/>            }<br/>        }<br/><br/>        Return (Int) Res;<br/>    }<br/><br/>    Private List&lt;integer&gt; Primefactors(int Num) {<br/>        List&lt;integer&gt; Factors = New Arraylist&lt;&gt;();<br/>        For (Int I = 2; I * I &lt;= Num; I++) {<br/>            If (Num % I == 0) {<br/>                Factors.add(i);<br/>                While (Num % I == 0) {<br/>                    Num /= I;<br/>                }<br/>            }<br/>        }<br/>        If (Num &gt; 1) {<br/>            Factors.add(num);<br/>        }<br/>        Return Factors;<br/>    }<br/><br/>    Private Int Maxprimescore(int L, Int R) {<br/>        Int Maxscore = 0;<br/>        For (Int I = L; I &lt;= R; I++) {<br/>            Maxscore = Math.max(maxscore, Factors[i].size());<br/>        }<br/>        Return Maxscore;<br/>    }<br/><br/>    Private Int Maxprimescoreindex(int L, Int R) {<br/>        Int Maxscore = 0, Idx = -1;<br/>        For (Int I = L; I &lt;= R; I++) {<br/>            If (Factors[i].size() &gt;= Maxscore) {<br/>                Maxscore = Factors[i].size();<br/>                Idx = I;<br/>            }<br/>        }<br/>        Return Idx;<br/>    }<br/>}</td>
<td>Class Solution {<br/>    Static Final Int Mod = 1000000007;<br/><br/>    Public Int Maximumscore(list&lt;integer&gt; Nums, Int K) {<br/>        Int N = Nums.size();<br/><br/>        Int Upper = Collections.max(nums) + 1;<br/><br/>        Boolean[] Prime = New Boolean[upper];<br/>        Int[] Primescore = New Int[upper];<br/>        Arrays.fill(prime, True);<br/>        Prime[0] = Prime[1] = False;<br/>        For (Int I = 2; I &lt; Upper; I++) {<br/>            If (Prime[i]) {<br/>                For (Int J = I; J &lt; Upper; J += I) {<br/>                    Primescore[j]++;<br/>                    Prime[j] = False;<br/>                }<br/>            }<br/>        }<br/><br/>        Int[] Nextgreaterelement = New Int[n];<br/>        Arrays.fill(nextgreaterelement, N);<br/>        Stack&lt;integer&gt; S = New Stack&lt;&gt;();<br/>        For (Int I = N - 1; I &gt;= 0; I--) {<br/>            While (!S.empty() &amp;&amp; Primescore[nums.get(i)] &gt;= Primescore[nums.get(s.peek())]) {<br/>                S.pop();<br/>            }<br/>            Nextgreaterelement[i] = S.empty() ? N : S.peek();<br/>            S.push(i);<br/>        }<br/><br/>        Int[] Prevgreaterorequalelement = New Int[n];<br/>        Arrays.fill(prevgreaterorequalelement, -1);<br/>        S = New Stack&lt;&gt;();<br/>        For (Int I = 0; I &lt; N; I++) {<br/>            While (!S.empty() &amp;&amp; Primescore[nums.get(i)] &gt; Primescore[nums.get(s.peek())]) {<br/>                S.pop();<br/>            }<br/>            Prevgreaterorequalelement[i] = S.empty() ? -1 : S.peek();<br/>            S.push(i);<br/>        }<br/><br/>        Int Res = 1;<br/>        Int[][] Tuples = New Int[n][2];<br/>        For (Int I = 0; I &lt; N; I++) {<br/>            Tuples[i][0] = Nums.get(i);<br/>            Tuples[i][1] = I;<br/>        }<br/>        Arrays.sort(tuples, New Comparator&lt;int[]&gt;() {<br/>            Public Int Compare(int[] A, Int[] B) {<br/>                Return B[0] - A[0];<br/>            }<br/>        });<br/>        For (Int I = 0; I &lt; N; I++) {<br/>            Int Num = Tuples[i][0];<br/>            Int Idx = Tuples[i][1];<br/>            Int Operations = Math.min((idx - Prevgreaterorequalelement[idx]) * (Nextgreaterelement[idx] - Idx), K);<br/>            Res = (Int)((1l * Res * Pow(num, Operations)) % Mod);<br/>            K -= Operations;<br/>            If (K == 0) {<br/>                Return Res;<br/>            }<br/>        }<br/><br/>        Return Res;<br/>    }<br/><br/>    Public Int Pow(int X, Int N) {<br/>        Int Res = 1;<br/>        While (N &gt; 0) {<br/>            If (N % 2 == 1) {<br/>                Res = (Int)((1l * Res * X) % Mod);<br/>            }<br/>            X = (Int)((1l * X * X) % Mod);<br/>            N /= 2;<br/>        }<br/>        Return Res;<br/>    }<br/>}</td>
</tr>
<tr>
<td align="right">14</td>
<td align="right">5</td>
<td>Python</td>
<td>hard</td>
<td>Bing AI Chat</td>
<td>Chatbot</td>
<td>You are given an array nums of n positive integers and an integer k.<br/><br/>Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:<br/><br/>Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.<br/>Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.<br/>Multiply your score by x.<br/>Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.<br/><br/>The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.<br/><br/>Return the maximum possible score after applying at most k operations.<br/><br/>Since the answer may be large, return it modulo 10^9 + 7.<br/><br/>Example 1:<br/><br/>Input: nums = [8,3,9,3,8], k = 2<br/>Output: 81<br/>Explanation: To get a score of 81, we can apply the following operations:<br/>- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.<br/>It can be proven that 81 is the highest score one can obtain.<br/><br/>Example 2:<br/><br/>Input: nums = [19,12,14,6,10,18], k = 3<br/>Output: 4788<br/>Explanation: To get a score of 4788, we can apply the following operations: <br/>- Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.<br/>- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.<br/>It can be proven that 4788 is the highest score one can obtain.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length == n &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^5<br/>1 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9) </td>
<td>Solve the following problem with python3 code. Class name: Solution, Method name: def maximumScore(self, nums: List[int], k: int) -&gt; int:.<br/><br/>You are given an array nums of n positive integers and an integer k.<br/><br/>Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:<br/><br/>Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.<br/>Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.<br/>Multiply your score by x.<br/>Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.<br/><br/>The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.<br/><br/>Return the maximum possible score after applying at most k operations.<br/><br/>Since the answer may be large, return it modulo 10^9 + 7.<br/><br/>Example 1:<br/><br/>Input: nums = [8,3,9,3,8], k = 2<br/>Output: 81<br/>Explanation: To get a score of 81, we can apply the following operations:<br/>- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.<br/>It can be proven that 81 is the highest score one can obtain.<br/><br/>Example 2:<br/><br/>Input: nums = [19,12,14,6,10,18], k = 3<br/>Output: 4788<br/>Explanation: To get a score of 4788, we can apply the following operations: <br/>- Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.<br/>- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.<br/>It can be proven that 4788 is the highest score one can obtain.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length == n &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^5<br/>1 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9).</td>
<td>Class Solution:<br/>    Def Maximumscore(self, Nums: List[int], K: Int) -&gt; Int:<br/>        N = Len(nums)<br/>        Mod = 10**9 + 7<br/><br/>        # Precompute The Prime Score Of All Numbers In Nums<br/>        Prime_score = [0] * N<br/>        For I, Num In Enumerate(nums):<br/>            For J In Range(2, Int(sqrt(num)) + 1):<br/>                If Num % J == 0:<br/>                    Prime_score[i] += 1<br/>                    While Num % J == 0:<br/>                        Num //= J<br/>            If Num &gt; 1:<br/>                Prime_score[i] += 1<br/><br/>        # Compute The Maximum Score Using Dynamic Programming<br/>        Dp = [1]<br/>        For _ In Range(k):<br/>            New_dp = [0] * (N + 1)<br/>            For L In Range(n):<br/>                For R In Range(l, N):<br/>                    Max_prime_score = Max(prime_score[l:r+1])<br/>                    Max_index = Prime_score[l:r+1].index(max_prime_score) + L<br/>                    New_dp[r+1] = Max(new_dp[r+1], Dp[l] * Nums[max_index] % Mod)<br/>            Dp = New_dp<br/><br/>        Return Max(dp) % Mod</td>
<td>Class Solution: <br/>    Mod = 1000000007<br/><br/>    Def Maximumscore(self, Nums: List[int], K: Int) -&gt; Int:<br/>        N = Len(nums)<br/><br/>        Upper = Max(nums) + 1<br/><br/>        Prime = [True]*upper<br/>        Prime[0] = Prime[1] = False<br/>        Primescore = [0]*upper<br/>        For I In Range(2, Upper):<br/>            If Prime[i]:<br/>                For J In Range(i, Upper, I):<br/>                    Primescore[j] += 1<br/>                    Prime[j] = False<br/><br/>        Nextgreaterelement = [N]*n<br/>        S = []<br/>        For I In Range(n - 1, -1, -1):<br/>            While S And Primescore[nums[i]] &gt;= Primescore[nums[s[-1]]]:<br/>                S.pop()<br/>            Nextgreaterelement[i] = S[-1] If S Else N<br/>            S.append(i)<br/><br/>        Prevgreaterorequalelement = [-1]*n<br/>        S = []<br/>        For I In Range(n):<br/>            While S And Primescore[nums[i]] &gt; Primescore[nums[s[-1]]]:<br/>                S.pop()<br/>            Prevgreaterorequalelement[i] = S[-1] If S Else -1<br/>            S.append(i)<br/><br/>        Res = 1<br/>        Tuples = [[Nums[i], I] For I In Range(n)]<br/>        Tuples.sort(reverse=true)<br/>        For Num, Idx In Tuples:<br/>            Operations = Min((idx - Prevgreaterorequalelement[idx]) * (Nextgreaterelement[idx] - Idx), K)<br/>            Res = (Res * Self.pow(num, Operations)) % Self.mod<br/>            K -= Operations<br/>            If K == 0:<br/>                Return Res<br/><br/>        Return Res<br/><br/>    Def Pow(self, X: Int, N: Int) -&gt; Int:<br/>        Res = 1<br/>        While N &gt; 0:<br/>            If N % 2 == 1:<br/>                Res = (Res * X) % Self.mod<br/>            X = (X * X) % Self.mod<br/>            N //= 2<br/>        Return Res</td>
</tr>
<tr>
<td align="right">15</td>
<td align="right">5</td>
<td>C++</td>
<td>hard</td>
<td>Bing AI Chat</td>
<td>Chatbot</td>
<td>You are given an array nums of n positive integers and an integer k.<br/><br/>Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:<br/><br/>Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.<br/>Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.<br/>Multiply your score by x.<br/>Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.<br/><br/>The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.<br/><br/>Return the maximum possible score after applying at most k operations.<br/><br/>Since the answer may be large, return it modulo 10^9 + 7.<br/><br/>Example 1:<br/><br/>Input: nums = [8,3,9,3,8], k = 2<br/>Output: 81<br/>Explanation: To get a score of 81, we can apply the following operations:<br/>- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.<br/>It can be proven that 81 is the highest score one can obtain.<br/><br/>Example 2:<br/><br/>Input: nums = [19,12,14,6,10,18], k = 3<br/>Output: 4788<br/>Explanation: To get a score of 4788, we can apply the following operations: <br/>- Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.<br/>- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.<br/>It can be proven that 4788 is the highest score one can obtain.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length == n &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^5<br/>1 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9) </td>
<td>Solve the following problem with C++ code. Class name: Solution, Method name: int maximumScore(vector&lt;int&gt;&amp; nums, int k).<br/><br/>You are given an array nums of n positive integers and an integer k.<br/><br/>Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:<br/><br/>Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.<br/>Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.<br/>Multiply your score by x.<br/>Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.<br/><br/>The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.<br/><br/>Return the maximum possible score after applying at most k operations.<br/><br/>Since the answer may be large, return it modulo 10^9 + 7.<br/><br/>Example 1:<br/><br/>Input: nums = [8,3,9,3,8], k = 2<br/>Output: 81<br/>Explanation: To get a score of 81, we can apply the following operations:<br/>- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.<br/>It can be proven that 81 is the highest score one can obtain.<br/><br/>Example 2:<br/><br/>Input: nums = [19,12,14,6,10,18], k = 3<br/>Output: 4788<br/>Explanation: To get a score of 4788, we can apply the following operations: <br/>- Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.<br/>- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.<br/>It can be proven that 4788 is the highest score one can obtain.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length == n &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^5<br/>1 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9).</td>
<td>Class Solution {<br/>Public:<br/>    Int Maximumscore(std::vector&lt;int&gt;&amp; Nums, Int K) {<br/>        Const Int Mod = 1e9 + 7;<br/>        Int N = Nums.size();<br/>        Std::vector&lt;int&gt; Primescore(n);<br/>        For (Int I = 0; I &lt; N; I++) {<br/>            Primescore[i] = Getprimescore(nums[i]);<br/>        }<br/>        Std::vector&lt;std::vector&lt;long Long&gt;&gt; Dp(n, Std::vector&lt;long Long&gt;(k + 1));<br/>        For (Int I = 0; I &lt; N; I++) {<br/>            Dp[i][0] = Nums[i];<br/>            For (Int J = 1; J &lt;= K; J++) {<br/>                For (Int L = 0; L &lt; I; L++) {<br/>                    If (Primescore[l] &gt;= Primescore[i]) {<br/>                        Dp[i][j] = Std::max(dp[i][j], Dp[l][j - 1] * Nums[i] % Mod);<br/>                    }<br/>                }<br/>            }<br/>        }<br/>        Long Long Maxscore = 0;<br/>        For (Int I = 0; I &lt; N; I++) {<br/>            Maxscore = Std::max(maxscore, Dp[i][k]);<br/>        }<br/>        Return Maxscore % Mod;<br/>    }<br/><br/>Private:<br/>    Int Getprimescore(int Num) {<br/>        Int Score = 0;<br/>        For (Int I = 2; I &lt;= Std::sqrt(num); I++) {<br/>            If (Num % I == 0) {<br/>                Score++;<br/>                While (Num % I == 0) {<br/>                    Num /= I;<br/>                }<br/>            }<br/>        }<br/>        If (Num &gt; 1) {<br/>            Score++;<br/>        }<br/>        Return Score;<br/>    }<br/>};</td>
<td>Class Solution {<br/>Public:<br/>    Const Int Mod = 1000000007;<br/><br/>    Int Maximumscore(vector&lt;int&gt;&amp; Nums, Int K) {<br/>        Int N = Nums.size();<br/><br/>        Int Upper = *Max_element(nums.begin(), Nums.end()) + 1;<br/><br/>        Vector&lt;bool&gt; Prime(upper, True);<br/>        Prime[0] = Prime[1] = False;<br/>        Vector&lt;int&gt; Primescore(upper, 0);<br/>        For (Int I = 2; I &lt; Upper; I++) {<br/>            If (Prime[i]) {<br/>                For (Int J = I; J &lt; Upper; J += I) {<br/>                    Primescore[j]++;<br/>                    Prime[j] = False;<br/>                }<br/>            }<br/>        }<br/><br/>        Vector&lt;int&gt; Nextgreaterelement(n, N);<br/>        Stack&lt;int&gt; S;<br/>        For (Int I = N - 1; I &gt;= 0; I--) {<br/>            While (!S.empty() &amp;&amp; Primescore[nums[i]] &gt;= Primescore[nums[s.top()]]) {<br/>                S.pop();<br/>            }<br/>            Nextgreaterelement[i] = S.empty() ? N : S.top();<br/>            S.push(i);<br/>        }<br/><br/>        Vector&lt;int&gt; Prevgreaterorequalelement(n, -1);<br/>        S = Stack&lt;int&gt;();<br/>        For (Int I = 0; I &lt; N; I++) {<br/>            While (!S.empty() &amp;&amp; Primescore[nums[i]] &gt; Primescore[nums[s.top()]]) {<br/>                S.pop();<br/>            }<br/>            Prevgreaterorequalelement[i] = S.empty() ? -1 : S.top();<br/>            S.push(i);<br/>        }<br/><br/>        Int Res = 1;<br/>        Vector&lt;pair&lt;int, Int&gt;&gt; Tuples(n);<br/>        For (Int I = 0; I &lt; N; I++) {<br/>            Tuples[i].first = Nums[i];<br/>            Tuples[i].second = I;<br/>        }<br/>        Sort(tuples.rbegin(), Tuples.rend());<br/>        For (Const Auto&amp; [Num, I] : Tuples) {<br/>            Int Operations = Min((i - Prevgreaterorequalelement[i]) * (Nextgreaterelement[i] - I), K);<br/>            Res = (Int)((1l * Res * Pow(num, Operations)) % Mod);<br/>            K -= Operations;<br/>            If (K == 0) {<br/>                Return Res;<br/>            }<br/>        }<br/><br/>        Return Res;<br/>    }<br/><br/>    Int Pow(int X, Int N) {<br/>        Int Res = 1;<br/>        While (N &gt; 0) {<br/>            If (N % 2 == 1) {<br/>                Res = (Int)((1l * Res * X) % Mod);<br/>            }<br/>            X = (Int)((1l * X * X) % Mod);<br/>            N /= 2;<br/>        }<br/>        Return Res;<br/>    }<br/>};</td>
</tr>
<tr>
<td align="right">16</td>
<td align="right">6</td>
<td>Java</td>
<td>hard</td>
<td>Bing AI Chat</td>
<td>Chatbot</td>
<td>You are given a 0-indexed 2D integer array items of length n and an integer k.<br/><br/>items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.<br/><br/>Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.<br/><br/>Your task is to find the maximum elegance from all subsequences of size k in items.<br/><br/>Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.<br/><br/>Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.<br/><br/>Example 1:<br/><br/>Input: items = [[3,2],[5,1],[10,1]], k = 2<br/>Output: 17<br/>Explanation: In this example, we have to select a subsequence of size 2.<br/>We can select items[0] = [3,2] and items[2] = [10,1].<br/>The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].<br/>Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. <br/><br/>Example 2:<br/><br/>Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3<br/>Output: 19<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. <br/>The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. <br/>Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.<br/><br/>Example 3:<br/><br/>Input: items = [[1,1],[2,1],[3,1]], k = 3<br/>Output: 7<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We should select all the items. <br/>The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. <br/>Hence, the maximum elegance is 6 + 1^2 = 7.  <br/> <br/>Constraints:<br/><br/>1 &lt;= items.length == n &lt;= 10^5<br/>items[i].length == 2<br/>items[i][0] == profit_i<br/>items[i][1] == category_i<br/>1 &lt;= profit_i &lt;= 10^9<br/>1 &lt;= category_i &lt;= n <br/>1 &lt;= k &lt;= n </td>
<td>Solve the following problem with java code. Class name: Solution, Method name: findMaximumElegance(int [][] items, int k).<br/><br/>You are given a 0-indexed 2D integer array items of length n and an integer k.<br/><br/>items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.<br/><br/>Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.<br/><br/>Your task is to find the maximum elegance from all subsequences of size k in items.<br/><br/>Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.<br/><br/>Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.<br/><br/>Example 1:<br/><br/>Input: items = [[3,2],[5,1],[10,1]], k = 2<br/>Output: 17<br/>Explanation: In this example, we have to select a subsequence of size 2.<br/>We can select items[0] = [3,2] and items[2] = [10,1].<br/>The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].<br/>Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. <br/><br/>Example 2:<br/><br/>Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3<br/>Output: 19<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. <br/>The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. <br/>Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.<br/><br/>Example 3:<br/><br/>Input: items = [[1,1],[2,1],[3,1]], k = 3<br/>Output: 7<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We should select all the items. <br/>The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. <br/>Hence, the maximum elegance is 6 + 1^2 = 7.  <br/> <br/>Constraints:<br/><br/>1 &lt;= items.length == n &lt;= 10^5<br/>items[i].length == 2<br/>items[i][0] == profit_i<br/>items[i][1] == category_i<br/>1 &lt;= profit_i &lt;= 10^9<br/>1 &lt;= category_i &lt;= n <br/>1 &lt;= k &lt;= n</td>
<td>Class Solution {<br/>    Private Static Final Int Mod = 1_000_000_007;<br/><br/>    Public Int Findmaximumelegance(int[][] Items, Int K) {<br/>        Int N = Items.length;<br/>        List&lt;int[]&gt;[] Categoryitems = New List[n + 1];<br/>        For (Int I = 0; I &lt;= N; I++) {<br/>            Categoryitems[i] = New Arraylist&lt;&gt;();<br/>        }<br/>        For (Int[] Item : Items) {<br/>            Categoryitems[item[1]].add(item);<br/>        }<br/><br/>        Priorityqueue&lt;integer&gt; Pq = New Priorityqueue&lt;&gt;();<br/>        Long[] Dp = New Long[k + 1];<br/>        Dp[0] = 0;<br/>        Int Totalitems = 0;<br/>        For (List&lt;int[]&gt; Itemlist : Categoryitems) {<br/>            If (Itemlist.isempty()) Continue;<br/><br/>            Collections.sort(itemlist, Comparator.comparingint(a -&gt; -A[0]));<br/>            Int Categoryprofit = 0;<br/>            For (Int[] Item : Itemlist) {<br/>                Categoryprofit += Item[0];<br/>                Pq.offer(item[0]);<br/>                If (Pq.size() &gt; Totalitems + 1) {<br/>                    Categoryprofit -= Pq.poll();<br/>                }<br/>            }<br/><br/>            For (Int J = Math.min(k, Totalitems + Itemlist.size()); J &gt;= 0; J--) {<br/>                For (Int L = Math.max(0, J - Totalitems); L &lt;= Math.min(j, Itemlist.size()); L++) {<br/>                    Dp[j] = Math.max(dp[j], (J - L &gt; 0 ? Dp[j - L - 1] : 0) + Categoryprofit);<br/>                }<br/>            }<br/><br/>            Totalitems += Itemlist.size();<br/>        }<br/><br/>        Long Res = 0;<br/>        For (Int I = 1; I &lt;= K; I++) {<br/>            Res = Math.max(res, Dp[i] + (Long)i * I);<br/>        }<br/><br/>        Return (Int)(res % Mod);<br/>    }<br/>}</td>
<td>Class Solution {<br/>    Public Long Findmaximumelegance(int[][] A, Int K) {<br/>        Arrays.sort(a, (A, B) -&gt; B[0] - A[0]);<br/>        Long Res = 0, Cur = 0;<br/>        List&lt;integer&gt; Dup = New Arraylist&lt;&gt;();<br/>        Set&lt;integer&gt; Seen = New Hashset&lt;&gt;();<br/>        For (Int I = 0; I &lt; A.length; ++I) {<br/>            If (I &lt; K) {<br/>                If (Seen.contains(a[i][1])) {<br/>                    Dup.add(a[i][0]);<br/>                }<br/>                Cur += A[i][0];<br/>            } Else If (!Seen.contains(a[i][1])) {<br/>                If (Dup.isempty()) Break;<br/>                Cur += A[i][0] - Dup.remove(dup.size() - 1);<br/>            }<br/>            Seen.add(a[i][1]);<br/>            Res = Math.max(res, Cur + 1l * Seen.size() * Seen.size());<br/>        }<br/>        Return Res;<br/>    }<br/>}</td>
</tr>
<tr>
<td align="right">17</td>
<td align="right">6</td>
<td>Python</td>
<td>hard</td>
<td>Bing AI Chat</td>
<td>Chatbot</td>
<td>You are given a 0-indexed 2D integer array items of length n and an integer k.<br/><br/>items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.<br/><br/>Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.<br/><br/>Your task is to find the maximum elegance from all subsequences of size k in items.<br/><br/>Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.<br/><br/>Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.<br/><br/>Example 1:<br/><br/>Input: items = [[3,2],[5,1],[10,1]], k = 2<br/>Output: 17<br/>Explanation: In this example, we have to select a subsequence of size 2.<br/>We can select items[0] = [3,2] and items[2] = [10,1].<br/>The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].<br/>Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. <br/><br/>Example 2:<br/><br/>Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3<br/>Output: 19<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. <br/>The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. <br/>Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.<br/><br/>Example 3:<br/><br/>Input: items = [[1,1],[2,1],[3,1]], k = 3<br/>Output: 7<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We should select all the items. <br/>The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. <br/>Hence, the maximum elegance is 6 + 1^2 = 7.  <br/> <br/>Constraints:<br/><br/>1 &lt;= items.length == n &lt;= 10^5<br/>items[i].length == 2<br/>items[i][0] == profit_i<br/>items[i][1] == category_i<br/>1 &lt;= profit_i &lt;= 10^9<br/>1 &lt;= category_i &lt;= n <br/>1 &lt;= k &lt;= n </td>
<td>Solve the following problem with python3 code. Class name: Solution, Method name: def findMaximumElegance(self, items: List[List[int]], k: int) -&gt; int:.<br/><br/>You are given a 0-indexed 2D integer array items of length n and an integer k.<br/><br/>items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.<br/><br/>Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.<br/><br/>Your task is to find the maximum elegance from all subsequences of size k in items.<br/><br/>Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.<br/><br/>Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.<br/><br/>Example 1:<br/><br/>Input: items = [[3,2],[5,1],[10,1]], k = 2<br/>Output: 17<br/>Explanation: In this example, we have to select a subsequence of size 2.<br/>We can select items[0] = [3,2] and items[2] = [10,1].<br/>The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].<br/>Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. <br/><br/>Example 2:<br/><br/>Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3<br/>Output: 19<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. <br/>The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. <br/>Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.<br/><br/>Example 3:<br/><br/>Input: items = [[1,1],[2,1],[3,1]], k = 3<br/>Output: 7<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We should select all the items. <br/>The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. <br/>Hence, the maximum elegance is 6 + 1^2 = 7.  <br/> <br/>Constraints:<br/><br/>1 &lt;= items.length == n &lt;= 10^5<br/>items[i].length == 2<br/>items[i][0] == profit_i<br/>items[i][1] == category_i<br/>1 &lt;= profit_i &lt;= 10^9<br/>1 &lt;= category_i &lt;= n <br/>1 &lt;= k &lt;= n</td>
<td>Class Solution:<br/>    Def Findmaximumelegance(self, Items: List[list[int]], K: Int) -&gt; Int:<br/>        N = Len(items)<br/>        Items.sort(key=lambda X: (-X[0], X[1]))<br/>        Dp = [[0, 0] For _ In Range(n + 1)]<br/>        For I In Range(1, N + 1):<br/>            Dp[i][0] = Max(dp[i - 1][0], Dp[i - 1][1])<br/>            Dp[i][1] = Max(dp[i - 1][0] + Items[i - 1][0], Dp[i - 1][1] + Items[i - 1][0])<br/>        Return Max(dp[k]) + Len(set([item[1] For Item In Items[:k]])) ** 2</td>
<td>Class Solution:<br/>    Def Findmaximumelegance(self, Items: List[list[int]], K: Int) -&gt; Int:<br/>        Items = Sorted(items, Key=lambda V: -V[0])<br/>        Res = Cur = 0<br/>        A = []<br/>        Seen = Set()<br/>        For I, (P, C) In Enumerate(items):<br/>            If I &lt; K:<br/>                If C In Seen:<br/>                    A.append(p)<br/>                Cur += P<br/>            Elif C Not In Seen:<br/>                If Not A: Break<br/>                Cur += P - A.pop()<br/>            Seen.add(c)<br/>            Res = Max(res, Cur + Len(seen) * Len(seen))<br/>        Return Res</td>
</tr>
<tr>
<td align="right">18</td>
<td align="right">6</td>
<td>C++</td>
<td>hard</td>
<td>Bing AI Chat</td>
<td>Chatbot</td>
<td>You are given a 0-indexed 2D integer array items of length n and an integer k.<br/><br/>items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.<br/><br/>Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.<br/><br/>Your task is to find the maximum elegance from all subsequences of size k in items.<br/><br/>Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.<br/><br/>Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.<br/><br/>Example 1:<br/><br/>Input: items = [[3,2],[5,1],[10,1]], k = 2<br/>Output: 17<br/>Explanation: In this example, we have to select a subsequence of size 2.<br/>We can select items[0] = [3,2] and items[2] = [10,1].<br/>The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].<br/>Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. <br/><br/>Example 2:<br/><br/>Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3<br/>Output: 19<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. <br/>The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. <br/>Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.<br/><br/>Example 3:<br/><br/>Input: items = [[1,1],[2,1],[3,1]], k = 3<br/>Output: 7<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We should select all the items. <br/>The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. <br/>Hence, the maximum elegance is 6 + 1^2 = 7.  <br/> <br/>Constraints:<br/><br/>1 &lt;= items.length == n &lt;= 10^5<br/>items[i].length == 2<br/>items[i][0] == profit_i<br/>items[i][1] == category_i<br/>1 &lt;= profit_i &lt;= 10^9<br/>1 &lt;= category_i &lt;= n <br/>1 &lt;= k &lt;= n </td>
<td>Solve the following problem with C++ code. Class name: Solution, Method name: long long findMaximumElegance(vector&lt;vector&lt;int&gt;&gt;&amp; items, int k).<br/><br/>You are given a 0-indexed 2D integer array items of length n and an integer k.<br/><br/>items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.<br/><br/>Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.<br/><br/>Your task is to find the maximum elegance from all subsequences of size k in items.<br/><br/>Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.<br/><br/>Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.<br/><br/>Example 1:<br/><br/>Input: items = [[3,2],[5,1],[10,1]], k = 2<br/>Output: 17<br/>Explanation: In this example, we have to select a subsequence of size 2.<br/>We can select items[0] = [3,2] and items[2] = [10,1].<br/>The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].<br/>Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. <br/><br/>Example 2:<br/><br/>Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3<br/>Output: 19<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. <br/>The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. <br/>Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.<br/><br/>Example 3:<br/><br/>Input: items = [[1,1],[2,1],[3,1]], k = 3<br/>Output: 7<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We should select all the items. <br/>The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. <br/>Hence, the maximum elegance is 6 + 1^2 = 7.  <br/> <br/>Constraints:<br/><br/>1 &lt;= items.length == n &lt;= 10^5<br/>items[i].length == 2<br/>items[i][0] == profit_i<br/>items[i][1] == category_i<br/>1 &lt;= profit_i &lt;= 10^9<br/>1 &lt;= category_i &lt;= n <br/>1 &lt;= k &lt;= n</td>
<td>Class Solution {<br/>Public:<br/>    Long Long Findmaximumelegance(std::vector&lt;std::vector&lt;int&gt;&gt;&amp; Items, Int K) {<br/>        Const Int Mod = 1e9 + 7;<br/>        Int N = Items.size();<br/>        Std::vector&lt;std::unordered_map&lt;int, Long Long&gt;&gt; Dp(n);<br/>        For (Int I = 0; I &lt; N; I++) {<br/>            Dp[i][1 &lt;&lt; Items[i][1]] = Items[i][0];<br/>            For (Int J = 0; J &lt; I; J++) {<br/>                For (Auto&amp; [Mask, Val] : Dp[j]) {<br/>                    Int Newmask = Mask | (1 &lt;&lt; Items[i][1]);<br/>                    Dp[i][newmask] = Std::max(dp[i][newmask], Val + Items[i][0]);<br/>                }<br/>            }<br/>        }<br/>        Long Long Maxelegance = 0;<br/>        For (Int I = 0; I &lt; N; I++) {<br/>            For (Auto&amp; [Mask, Val] : Dp[i]) {<br/>                Int Cnt = __builtin_popcount(mask);<br/>                If (Cnt &gt;= K) {<br/>                    Maxelegance = Std::max(maxelegance, Val + Cnt * Cnt);<br/>                }<br/>            }<br/>        }<br/>        Return Maxelegance % Mod;<br/>    }<br/>};</td>
<td>Class Solution {<br/>Public:<br/>    Long Long Findmaximumelegance(vector&lt;vector&lt;int&gt;&gt;&amp; A, Int K) {<br/>        Sort(a.begin(), A.end(), [](Const Vector&lt;int&gt;&amp; A, Const Vector&lt;int&gt;&amp; B) {<br/>            Return A[0] &gt; B[0];<br/>        });<br/>        Long Long Res = 0, Cur = 0;<br/>        Vector&lt;int&gt; Dup;<br/>        Unordered_set&lt;int&gt; Seen;<br/>        For (Int I = 0; I &lt; A.size(); ++I) {<br/>            If (I &lt; K) {<br/>                If (Seen.count(a[i][1])) {<br/>                    Dup.push_back(a[i][0]);<br/>                }<br/>                Cur += A[i][0];<br/>            } Else If (Seen.find(a[i][1]) == Seen.end()) {<br/>                If (Dup.empty()) Break;<br/>                Cur += A[i][0] - Dup.back();<br/>                Dup.pop_back();<br/>            }<br/>            Seen.insert(a[i][1]);<br/>            Res = Fmax(res, Cur + 1l * Seen.size() * Seen.size());<br/>        }<br/>        Return Res;<br/>    }<br/>};</td>
</tr>
<tr>
<td align="right">19</td>
<td align="right">1</td>
<td>Java</td>
<td>easy</td>
<td>ChatGPT</td>
<td>Chatbot</td>
<td>You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.<br/><br/>Return the maximum sum or -1 if no such pair exists.<br/><br/>Example 1:<br/><br/>Input: nums = [51,71,17,24,42]<br/>Output: 88<br/>Explanation: <br/>For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. <br/>For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.<br/>It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.<br/><br/>Example 2:<br/><br/>Input: nums = [1,2,3,4]<br/>Output: -1<br/>Explanation: No pair exists in nums with equal maximum digits.<br/><br/>Constraints:<br/><br/>2 &lt;= nums.length &lt;= 100<br/>1 &lt;= nums[i] &lt;= 10^4 </td>
<td>solve the following problem with java code. Class name: Solution, Method name: maxSum(int[] nums).<br/><br/>You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.<br/><br/>Return the maximum sum or -1 if no such pair exists.<br/><br/>Example 1:<br/><br/>Input: nums = [51,71,17,24,42]<br/>Output: 88<br/>Explanation: <br/>For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. <br/>For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.<br/>It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.<br/><br/>Example 2:<br/><br/>Input: nums = [1,2,3,4]<br/>Output: -1<br/>Explanation: No pair exists in nums with equal maximum digits.<br/><br/>Constraints:<br/><br/>2 &lt;= nums.length &lt;= 100<br/>1 &lt;= nums[i] &lt;= 10^4</td>
<td>Public Class Solution {<br/>    Public Int Maxsum(int[] Nums) {<br/>        // Create An Array Of Size 10 To Keep Track Of The Maximum Values For Each Digit (0-9)<br/>        Int[] Maxdigits = New Int[10];<br/>        <br/>        // Iterate Through The Array And Update The Maxdigits Array With The Maximum Values For Each Digit<br/>        For (Int Num : Nums) {<br/>            Int Maxdigit = Getmaxdigit(num);<br/>            Maxdigits[maxdigit] = Math.max(maxdigits[maxdigit], Num);<br/>        }<br/>        <br/>        Int Maxsum = -1;<br/>        <br/>        // Iterate Through The Maxdigits Array To Find Pairs With Equal Maximum Digits<br/>        For (Int I = 0; I &lt;= 9; I++) {<br/>            For (Int J = I; J &lt;= 9; J++) {<br/>                If (Maxdigits[i] != 0 &amp;&amp; Maxdigits[j] != 0 &amp;&amp; I == J) {<br/>                    Maxsum = Math.max(maxsum, Maxdigits[i] + Maxdigits[j]);<br/>                }<br/>            }<br/>        }<br/>        <br/>        Return Maxsum;<br/>    }<br/>    <br/>    // Helper Method To Get The Maximum Digit From A Number<br/>    Private Int Getmaxdigit(int Num) {<br/>        Int Maxdigit = 0;<br/>        While (Num &gt; 0) {<br/>            Maxdigit = Math.max(maxdigit, Num % 10);<br/>            Num /= 10;<br/>        }<br/>        Return Maxdigit;<br/>    }<br/>    <br/>}</td>
<td>Class Solution {<br/>    Public Int Maxsum(int[] Nums) {<br/>    Int Ans = -1;<br/>    Map&lt;integer,list&lt;integer&gt;&gt; Ump = New Hashmap&lt;&gt;();<br/>    For(int I = 0; I &lt; Nums.length; ++I){<br/>        Int T = Nums[i], Maxdigit = 0;<br/>        While(t != 0){ //Evaluate Max Digit In The Number<br/>            Maxdigit = Math.max(t%10, Maxdigit);<br/>            T = T/10;<br/>        }<br/>        If(!ump.containskey(maxdigit)) Ump.put(maxdigit, New Arraylist&lt;&gt;());<br/>        Ump.get(maxdigit).add(nums[i]); // Add The Number To The Map <br/>    }<br/>    For(map.entry&lt;integer, List&lt;integer&gt;&gt; Entry: Ump.entryset()){<br/>        Entry.getvalue().sort(comparator.reverseorder()); //To Find Max Two Number In Each Max Digit <br/>        If(entry.getvalue().size() &gt;= 2) Ans = Math.max(ans, Entry.getvalue().get(0) + Entry.getvalue().get(1)); //Sum Max Two Number And Take Max<br/>    }<br/>    Return Ans;<br/>    }<br/>}</td>
</tr>
<tr>
<td align="right">20</td>
<td align="right">1</td>
<td>Python</td>
<td>easy</td>
<td>ChatGPT</td>
<td>Chatbot</td>
<td>You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.<br/><br/>Return the maximum sum or -1 if no such pair exists.<br/><br/>Example 1:<br/><br/>Input: nums = [51,71,17,24,42]<br/>Output: 88<br/>Explanation: <br/>For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. <br/>For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.<br/>It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.<br/><br/>Example 2:<br/><br/>Input: nums = [1,2,3,4]<br/>Output: -1<br/>Explanation: No pair exists in nums with equal maximum digits.<br/><br/>Constraints:<br/><br/>2 &lt;= nums.length &lt;= 100<br/>1 &lt;= nums[i] &lt;= 10^4 </td>
<td>solve the following problem with python3 code. Class name: Solution, Method name: def maxSum(self, nums: List[int]) -&gt; int:.<br/><br/>You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.<br/><br/>Return the maximum sum or -1 if no such pair exists.<br/><br/>Example 1:<br/><br/>Input: nums = [51,71,17,24,42]<br/>Output: 88<br/>Explanation: <br/>For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. <br/>For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.<br/>It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.<br/><br/>Example 2:<br/><br/>Input: nums = [1,2,3,4]<br/>Output: -1<br/>Explanation: No pair exists in nums with equal maximum digits.<br/><br/>Constraints:<br/><br/>2 &lt;= nums.length &lt;= 100<br/>1 &lt;= nums[i] &lt;= 10^4</td>
<td>Class Solution:<br/>    Def Maxsum(self, Nums: List[int]) -&gt; Int:<br/>        Max_digit_sum = {}  # Dictionary To Store The Maximum Sum For Each Maximum Digit<br/>        <br/>        For Num In Nums:<br/>            Max_digit = Max(str(num))  # Find The Maximum Digit In The Current Number<br/>            If Max_digit In Max_digit_sum:<br/>                Max_digit_sum[max_digit] = Max(max_digit_sum[max_digit], Num)<br/>            Else:<br/>                Max_digit_sum[max_digit] = Num<br/>        <br/>        Max_sum = -1  # Initialize The Maximum Sum To -1<br/>        <br/>        # Iterate Through The Dictionary To Find The Maximum Sum<br/>        For Digit, Num In Max_digit_sum.items():<br/>            If Max_digit_sum[digit] != Num:<br/>                Max_sum = Max(max_sum, Num + Max_digit_sum[digit])<br/>        <br/>        Return Max_sum</td>
<td>Class Solution:<br/>    Def Maxsum(self, Nums: List[int]) -&gt; Int:<br/>        Max_by_digit = Defaultdict(int)<br/>        Max_sum = -1<br/><br/>        For Num In Nums:<br/>            Digit = Max(str(num))<br/><br/>            If Digit In Max_by_digit:<br/>                Max_sum = Max(max_sum, Max_by_digit[digit] + Num)<br/><br/>            Max_by_digit[digit] = Max(max_by_digit[digit], Num)<br/><br/>        Return Max_sum</td>
</tr>
<tr>
<td align="right">21</td>
<td align="right">1</td>
<td>C++</td>
<td>easy</td>
<td>ChatGPT</td>
<td>Chatbot</td>
<td>You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.<br/><br/>Return the maximum sum or -1 if no such pair exists.<br/><br/>Example 1:<br/><br/>Input: nums = [51,71,17,24,42]<br/>Output: 88<br/>Explanation: <br/>For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. <br/>For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.<br/>It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.<br/><br/>Example 2:<br/><br/>Input: nums = [1,2,3,4]<br/>Output: -1<br/>Explanation: No pair exists in nums with equal maximum digits.<br/><br/>Constraints:<br/><br/>2 &lt;= nums.length &lt;= 100<br/>1 &lt;= nums[i] &lt;= 10^4 </td>
<td>solve the following problem with C++ code. Class name: Solution, Method name: maxSum(std::vector&lt;int&gt;&amp; nums).<br/><br/>You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.<br/><br/>Return the maximum sum or -1 if no such pair exists.<br/><br/>Example 1:<br/><br/>Input: nums = [51,71,17,24,42]<br/>Output: 88<br/>Explanation: <br/>For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. <br/>For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.<br/>It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.<br/><br/>Example 2:<br/><br/>Input: nums = [1,2,3,4]<br/>Output: -1<br/>Explanation: No pair exists in nums with equal maximum digits.<br/><br/>Constraints:<br/><br/>2 &lt;= nums.length &lt;= 100<br/>1 &lt;= nums[i] &lt;= 10^4</td>
<td>Class Solution {<br/>Public:<br/>    Int Maxsum(std::vector&lt;int&gt;&amp; Nums) {<br/>        Std::vector&lt;int&gt; Maxdigit(10, -1); // To Store The Maximum Number For Each Digit (0-9)<br/>        Int Maxsum = -1; // Initialize Maxsum To -1 As The Minimum Possible Answer<br/>        <br/>        For (Int Num : Nums) {<br/>            Int Maxdig = 0; // To Store The Maximum Digit In The Current Number<br/>            Int Temp = Num; // Temporary Variable To Avoid Modifying Num<br/>            <br/>            While (Temp &gt; 0) {<br/>                Int Digit = Temp % 10;<br/>                Maxdig = Std::max(maxdig, Digit); // Update Maxdig If A Larger Digit Is Found<br/>                Temp /= 10;<br/>            }<br/>            <br/>            If (Maxdigit[maxdig] != -1) {<br/>                // If We Have Seen A Number With The Same Maximum Digit Before, Update Maxsum<br/>                Maxsum = Std::max(maxsum, Maxdigit[maxdig] + Num);<br/>            }<br/>            <br/>            // Update Maxdigit[maxdig] With The Maximum Of The Current Number And The Previous Maximum<br/>            Maxdigit[maxdig] = Std::max(maxdigit[maxdig], Num);<br/>        }<br/>        <br/>        Return Maxsum;<br/>    }<br/>};</td>
<td>Class Solution {<br/>    Public:<br/>        Int Maxsum(vector&lt;int&gt;&amp; Nums) {<br/>        Int Res = -1, Max_num[10] = {};<br/>        For (Auto Num : Nums) {<br/>            Int Max_d = 0;<br/>            For (Int V = Num; V; V /= 10)<br/>                Max_d = Max(max_d, V % 10);<br/>            If (Max_num[max_d])<br/>                Res = Max(res, Max_num[max_d] + Num);<br/>            Max_num[max_d] = Max(max_num[max_d], Num);<br/>        }<br/>        Return Res;<br/>    }<br/>};</td>
</tr>
<tr>
<td align="right">22</td>
<td align="right">2</td>
<td>Java</td>
<td>easy</td>
<td>ChatGPT</td>
<td>Chatbot</td>
<td>Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.<br/><br/>You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.<br/><br/>Return the final string that will be present on your laptop screen.<br/><br/>Example 1:<br/><br/>Input: s = &quot;string&quot;<br/>Output: &quot;rtsng&quot;<br/>Explanation: <br/>After typing first character, the text on the screen is &quot;s&quot;.<br/>After the second character, the text is &quot;st&quot;. <br/>After the third character, the text is &quot;str&quot;.<br/>Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.<br/>After the fifth character, the text is &quot;rtsn&quot;. <br/>After the sixth character, the text is &quot;rtsng&quot;. <br/>Therefore, we return &quot;rtsng&quot;.<br/><br/>Example 2:<br/><br/>Input: s = &quot;poiinter&quot;<br/>Output: &quot;ponter&quot;<br/>Explanation: <br/>After the first character, the text on the screen is &quot;p&quot;.<br/>After the second character, the text is &quot;po&quot;. <br/>Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. <br/>Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.<br/>After the fifth character, the text is &quot;pon&quot;.<br/>After the sixth character, the text is &quot;pont&quot;. <br/>After the seventh character, the text is &quot;ponte&quot;. <br/>After the eighth character, the text is &quot;ponter&quot;. <br/>Therefore, we return &quot;ponter&quot;.<br/> <br/>Constraints:<br/><br/>1 &lt;= s.length &lt;= 100<br/>s consists of lowercase English letters.<br/>s[0] != &#39;i&#39;</td>
<td>Solve the following problem with java code. Class name: Solution, Method name: finalString(String s).<br/><br/>Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.<br/><br/>You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.<br/><br/>Return the final string that will be present on your laptop screen.<br/><br/>Example 1:<br/><br/>Input: s = &quot;string&quot;<br/>Output: &quot;rtsng&quot;<br/>Explanation: <br/>After typing first character, the text on the screen is &quot;s&quot;.<br/>After the second character, the text is &quot;st&quot;. <br/>After the third character, the text is &quot;str&quot;.<br/>Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.<br/>After the fifth character, the text is &quot;rtsn&quot;. <br/>After the sixth character, the text is &quot;rtsng&quot;. <br/>Therefore, we return &quot;rtsng&quot;.<br/><br/>Example 2:<br/><br/>Input: s = &quot;poiinter&quot;<br/>Output: &quot;ponter&quot;<br/>Explanation: <br/>After the first character, the text on the screen is &quot;p&quot;.<br/>After the second character, the text is &quot;po&quot;. <br/>Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. <br/>Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.<br/>After the fifth character, the text is &quot;pon&quot;.<br/>After the sixth character, the text is &quot;pont&quot;. <br/>After the seventh character, the text is &quot;ponte&quot;. <br/>After the eighth character, the text is &quot;ponter&quot;. <br/>Therefore, we return &quot;ponter&quot;.<br/> <br/>Constraints:<br/><br/>1 &lt;= s.length &lt;= 100<br/>s consists of lowercase English letters.<br/>s[0] != &#39;i&#39;</td>
<td>Public Class Solution {<br/>    Public String Finalstring(string S) {<br/>        Stringbuilder Result = New Stringbuilder();<br/>        Stringbuilder Reversebuffer = New Stringbuilder();<br/>        <br/>        Boolean Reverse = False;<br/>        <br/>        For (Char C : S.tochararray()) {<br/>            If (C == &#39;I&#39;) {<br/>                Reverse = !Reverse;<br/>            } Else {<br/>                If (Reverse) {<br/>                    Reversebuffer.insert(0, C);<br/>                } Else {<br/>                    Result.append(c);<br/>                }<br/>            }<br/>        }<br/>        <br/>        Result.append(reversebuffer);<br/>        <br/>        Return Result.tostring();<br/>    }<br/>    <br/>}</td>
<td>Class Solution {<br/>    Public String Finalstring(string S) {<br/>        Stringbuilder Nm=new Stringbuilder();<br/>        For(char C:s.tochararray())<br/>        {<br/>            If(c==&#39;i&#39;)<br/>            {<br/>                Nm.reverse();<br/>            }<br/>            Else<br/>            {<br/>                Nm.append(c);<br/>            }<br/>        }<br/>        Return Nm.tostring();<br/>    }<br/>}</td>
</tr>
<tr>
<td align="right">23</td>
<td align="right">2</td>
<td>Python</td>
<td>easy</td>
<td>ChatGPT</td>
<td>Chatbot</td>
<td>Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.<br/><br/>You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.<br/><br/>Return the final string that will be present on your laptop screen.<br/><br/>Example 1:<br/><br/>Input: s = &quot;string&quot;<br/>Output: &quot;rtsng&quot;<br/>Explanation: <br/>After typing first character, the text on the screen is &quot;s&quot;.<br/>After the second character, the text is &quot;st&quot;. <br/>After the third character, the text is &quot;str&quot;.<br/>Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.<br/>After the fifth character, the text is &quot;rtsn&quot;. <br/>After the sixth character, the text is &quot;rtsng&quot;. <br/>Therefore, we return &quot;rtsng&quot;.<br/><br/>Example 2:<br/><br/>Input: s = &quot;poiinter&quot;<br/>Output: &quot;ponter&quot;<br/>Explanation: <br/>After the first character, the text on the screen is &quot;p&quot;.<br/>After the second character, the text is &quot;po&quot;. <br/>Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. <br/>Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.<br/>After the fifth character, the text is &quot;pon&quot;.<br/>After the sixth character, the text is &quot;pont&quot;. <br/>After the seventh character, the text is &quot;ponte&quot;. <br/>After the eighth character, the text is &quot;ponter&quot;. <br/>Therefore, we return &quot;ponter&quot;.<br/> <br/>Constraints:<br/><br/>1 &lt;= s.length &lt;= 100<br/>s consists of lowercase English letters.<br/>s[0] != &#39;i&#39;</td>
<td>Solve the following problem with python3 code. Class name: Solution, Method name: def finalString(self, s: str) -&gt; str:.<br/><br/>Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.<br/><br/>You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.<br/><br/>Return the final string that will be present on your laptop screen.<br/><br/>Example 1:<br/><br/>Input: s = &quot;string&quot;<br/>Output: &quot;rtsng&quot;<br/>Explanation: <br/>After typing first character, the text on the screen is &quot;s&quot;.<br/>After the second character, the text is &quot;st&quot;. <br/>After the third character, the text is &quot;str&quot;.<br/>Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.<br/>After the fifth character, the text is &quot;rtsn&quot;. <br/>After the sixth character, the text is &quot;rtsng&quot;. <br/>Therefore, we return &quot;rtsng&quot;.<br/><br/>Example 2:<br/><br/>Input: s = &quot;poiinter&quot;<br/>Output: &quot;ponter&quot;<br/>Explanation: <br/>After the first character, the text on the screen is &quot;p&quot;.<br/>After the second character, the text is &quot;po&quot;. <br/>Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. <br/>Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.<br/>After the fifth character, the text is &quot;pon&quot;.<br/>After the sixth character, the text is &quot;pont&quot;. <br/>After the seventh character, the text is &quot;ponte&quot;. <br/>After the eighth character, the text is &quot;ponter&quot;. <br/>Therefore, we return &quot;ponter&quot;.<br/> <br/>Constraints:<br/><br/>1 &lt;= s.length &lt;= 100<br/>s consists of lowercase English letters.<br/>s[0] != &#39;i&#39;</td>
<td>Class Solution:<br/>    Def Finalstring(self, S: Str) -&gt; Str:<br/>        Stack = []  # Use A Stack To Simulate Typing Process<br/>        <br/>        For Char In S:<br/>            If Char == &#39;I&#39;:<br/>                # If The Character Is &#39;I&#39;, Reverse The Stack<br/>                Stack.reverse()<br/>            Else:<br/>                Stack.append(char)<br/>        <br/>        # Convert The Stack To A String And Return<br/>        Return &#39;&#39;.Join(stack)</td>
<td>Class Solution:<br/>    Def Finalstring(self, S: Str) -&gt; Str:<br/>        While &quot;I&quot; In S:<br/>            Index=s.index(&quot;i&quot;)<br/><br/>            #First Half And Second Half<br/>            First=s[:index][::-1]<br/>            Second=s[index+1:]<br/><br/>            S=&quot;&quot;.join([first,second])<br/>        Return S</td>
</tr>
<tr>
<td align="right">24</td>
<td align="right">2</td>
<td>C++</td>
<td>easy</td>
<td>ChatGPT</td>
<td>Chatbot</td>
<td>Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.<br/><br/>You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.<br/><br/>Return the final string that will be present on your laptop screen.<br/><br/>Example 1:<br/><br/>Input: s = &quot;string&quot;<br/>Output: &quot;rtsng&quot;<br/>Explanation: <br/>After typing first character, the text on the screen is &quot;s&quot;.<br/>After the second character, the text is &quot;st&quot;. <br/>After the third character, the text is &quot;str&quot;.<br/>Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.<br/>After the fifth character, the text is &quot;rtsn&quot;. <br/>After the sixth character, the text is &quot;rtsng&quot;. <br/>Therefore, we return &quot;rtsng&quot;.<br/><br/>Example 2:<br/><br/>Input: s = &quot;poiinter&quot;<br/>Output: &quot;ponter&quot;<br/>Explanation: <br/>After the first character, the text on the screen is &quot;p&quot;.<br/>After the second character, the text is &quot;po&quot;. <br/>Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. <br/>Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.<br/>After the fifth character, the text is &quot;pon&quot;.<br/>After the sixth character, the text is &quot;pont&quot;. <br/>After the seventh character, the text is &quot;ponte&quot;. <br/>After the eighth character, the text is &quot;ponter&quot;. <br/>Therefore, we return &quot;ponter&quot;.<br/> <br/>Constraints:<br/><br/>1 &lt;= s.length &lt;= 100<br/>s consists of lowercase English letters.<br/>s[0] != &#39;i&#39;</td>
<td>Solve the following problem with C++ code. Class name: Solution, Method name: string finalString(string s).<br/><br/>Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.<br/><br/>You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.<br/><br/>Return the final string that will be present on your laptop screen.<br/><br/>Example 1:<br/><br/>Input: s = &quot;string&quot;<br/>Output: &quot;rtsng&quot;<br/>Explanation: <br/>After typing first character, the text on the screen is &quot;s&quot;.<br/>After the second character, the text is &quot;st&quot;. <br/>After the third character, the text is &quot;str&quot;.<br/>Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.<br/>After the fifth character, the text is &quot;rtsn&quot;. <br/>After the sixth character, the text is &quot;rtsng&quot;. <br/>Therefore, we return &quot;rtsng&quot;.<br/><br/>Example 2:<br/><br/>Input: s = &quot;poiinter&quot;<br/>Output: &quot;ponter&quot;<br/>Explanation: <br/>After the first character, the text on the screen is &quot;p&quot;.<br/>After the second character, the text is &quot;po&quot;. <br/>Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. <br/>Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.<br/>After the fifth character, the text is &quot;pon&quot;.<br/>After the sixth character, the text is &quot;pont&quot;. <br/>After the seventh character, the text is &quot;ponte&quot;. <br/>After the eighth character, the text is &quot;ponter&quot;. <br/>Therefore, we return &quot;ponter&quot;.<br/> <br/>Constraints:<br/><br/>1 &lt;= s.length &lt;= 100<br/>s consists of lowercase English letters.<br/>s[0] != &#39;i&#39;</td>
<td>Class Solution {<br/>Public:<br/>    Std::string Finalstring(std::string S) {<br/>        Std::string Result = &quot;&quot;; // Initialize The Result String<br/>        <br/>        For (Char C : S) {<br/>            If (C == &#39;I&#39;) {<br/>                // If The Character Is &#39;I&#39;, Reverse The Result String<br/>                Std::reverse(result.begin(), Result.end());<br/>            } Else {<br/>                // Otherwise, Append The Character To The Result String<br/>                Result += C;<br/>            }<br/>        }<br/>        <br/>        Return Result;<br/>    }<br/>};</td>
<td>Class Solution {<br/>Public:<br/>    String Finalstring(const String &amp;S) {<br/>        String A, B;<br/>        For (Char Ch : S)<br/>            If (Ch == &#39;I&#39;)<br/>                Swap(a, B);<br/>            Else<br/>                A += Ch;<br/>        Return String(rbegin(b), Rend(b)) + A;<br/>    }<br/>};</td>
</tr>
<tr>
<td align="right">25</td>
<td align="right">3</td>
<td>Java</td>
<td>medium</td>
<td>ChatGPT</td>
<td>Chatbot</td>
<td>You are given a 0-indexed integer array nums and an integer x.<br/><br/>Find the minimum absolute difference between two elements in the array that are at least x indices apart.<br/><br/>In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.<br/><br/>Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.<br/><br/>Example 1:<br/><br/>Input: nums = [4,3,2,4], x = 2<br/>Output: 0<br/>Explanation: We can select nums[0] = 4 and nums[3] = 4. <br/>They are at least 2 indices apart, and their absolute difference is the minimum, 0. <br/>It can be shown that 0 is the optimal answer.<br/><br/>Example 2:<br/><br/>Input: nums = [5,3,2,10,15], x = 1<br/>Output: 1<br/>Explanation: We can select nums[1] = 3 and nums[2] = 2.<br/>They are at least 1 index apart, and their absolute difference is the minimum, 1.<br/>It can be shown that 1 is the optimal answer.<br/><br/>Example 3:<br/><br/>Input: nums = [1,2,3,4], x = 3<br/>Output: 3<br/>Explanation: We can select nums[0] = 1 and nums[3] = 4.<br/>They are at least 3 indices apart, and their absolute difference is the minimum, 3.<br/>It can be shown that 3 is the optimal answer.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^9<br/>0 &lt;= x &lt; nums.length </td>
<td>Solve the following problem with java code. Class name: Solution, Method name: minAbsoluteDifference(List&lt;Integer&gt; nums, int x).<br/><br/>You are given a 0-indexed integer array nums and an integer x.<br/><br/>Find the minimum absolute difference between two elements in the array that are at least x indices apart.<br/><br/>In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.<br/><br/>Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.<br/><br/>Example 1:<br/><br/>Input: nums = [4,3,2,4], x = 2<br/>Output: 0<br/>Explanation: We can select nums[0] = 4 and nums[3] = 4. <br/>They are at least 2 indices apart, and their absolute difference is the minimum, 0. <br/>It can be shown that 0 is the optimal answer.<br/><br/>Example 2:<br/><br/>Input: nums = [5,3,2,10,15], x = 1<br/>Output: 1<br/>Explanation: We can select nums[1] = 3 and nums[2] = 2.<br/>They are at least 1 index apart, and their absolute difference is the minimum, 1.<br/>It can be shown that 1 is the optimal answer.<br/><br/>Example 3:<br/><br/>Input: nums = [1,2,3,4], x = 3<br/>Output: 3<br/>Explanation: We can select nums[0] = 1 and nums[3] = 4.<br/>They are at least 3 indices apart, and their absolute difference is the minimum, 3.<br/>It can be shown that 3 is the optimal answer.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^9<br/>0 &lt;= x &lt; nums.length</td>
<td>Public Class Solution {<br/>    Public Int Minabsolutedifference(list&lt;integer&gt; Nums, Int X) {<br/>        Int N = Nums.size();<br/>        Int Minabsdiff = Integer.max_value;<br/>        <br/>        // Create A Treemap To Store The Indices Of Elements<br/>        Treemap&lt;integer, Integer&gt; Indexmap = New Treemap&lt;&gt;();<br/>        <br/>        For (Int I = 0; I &lt; N; I++) {<br/>            Int Num = Nums.get(i);<br/>            <br/>            // Check If There Exists A Number In The Treemap With A Difference Of At Least X<br/>            // From The Current Number, And Update The Minimum Absolute Difference Accordingly.<br/>            Integer Floorkey = Indexmap.floorkey(num - X);<br/>            If (Floorkey != Null) {<br/>                Int Index = Indexmap.get(floorkey);<br/>                Minabsdiff = Math.min(minabsdiff, Math.abs(num - Nums.get(index)));<br/>            }<br/>            <br/>            // Check If There Exists A Number In The Treemap With A Difference Of At Least X<br/>            // From The Current Number, And Update The Minimum Absolute Difference Accordingly.<br/>            Integer Ceilingkey = Indexmap.ceilingkey(num + X);<br/>            If (Ceilingkey != Null) {<br/>                Int Index = Indexmap.get(ceilingkey);<br/>                Minabsdiff = Math.min(minabsdiff, Math.abs(num - Nums.get(index)));<br/>            }<br/>            <br/>            // Update The Index Of The Current Number In The Treemap.<br/>            Indexmap.put(num, I);<br/>        }<br/>        <br/>        Return Minabsdiff;<br/>    }<br/>   <br/>}</td>
<td>Class Solution {<br/>    Int Minabsolutedifference(list&lt;integer&gt; Nums, Int X) {<br/>        Int Ans = Integer.max_value;<br/>        Treeset&lt;integer&gt; S = New Treeset&lt;&gt;();<br/>        For(int I = X; I &lt; Nums.size(); ++I){<br/>            S.add(nums.get(i-x));<br/>            Integer High = S.ceiling(nums.get(i)), Low = S.floor(nums.get(i));<br/>            If(high != Null) Ans = Math.min(ans, Math.abs(nums.get(i) - High));<br/>            If(low != Null) Ans = Math.min(ans, Math.abs(nums.get(i) - Low));<br/>        }<br/>        Return Ans;<br/>    }<br/>}</td>
</tr>
<tr>
<td align="right">26</td>
<td align="right">3</td>
<td>Python</td>
<td>medium</td>
<td>ChatGPT</td>
<td>Chatbot</td>
<td>You are given a 0-indexed integer array nums and an integer x.<br/><br/>Find the minimum absolute difference between two elements in the array that are at least x indices apart.<br/><br/>In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.<br/><br/>Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.<br/><br/>Example 1:<br/><br/>Input: nums = [4,3,2,4], x = 2<br/>Output: 0<br/>Explanation: We can select nums[0] = 4 and nums[3] = 4. <br/>They are at least 2 indices apart, and their absolute difference is the minimum, 0. <br/>It can be shown that 0 is the optimal answer.<br/><br/>Example 2:<br/><br/>Input: nums = [5,3,2,10,15], x = 1<br/>Output: 1<br/>Explanation: We can select nums[1] = 3 and nums[2] = 2.<br/>They are at least 1 index apart, and their absolute difference is the minimum, 1.<br/>It can be shown that 1 is the optimal answer.<br/><br/>Example 3:<br/><br/>Input: nums = [1,2,3,4], x = 3<br/>Output: 3<br/>Explanation: We can select nums[0] = 1 and nums[3] = 4.<br/>They are at least 3 indices apart, and their absolute difference is the minimum, 3.<br/>It can be shown that 3 is the optimal answer.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^9<br/>0 &lt;= x &lt; nums.length </td>
<td>Solve the following problem with python3 code. Class name: Solution, Method name: def minAbsoluteDifference(self, nums: List[int], x: int) -&gt; int:.<br/><br/>You are given a 0-indexed integer array nums and an integer x.<br/><br/>Find the minimum absolute difference between two elements in the array that are at least x indices apart.<br/><br/>In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.<br/><br/>Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.<br/><br/>Example 1:<br/><br/>Input: nums = [4,3,2,4], x = 2<br/>Output: 0<br/>Explanation: We can select nums[0] = 4 and nums[3] = 4. <br/>They are at least 2 indices apart, and their absolute difference is the minimum, 0. <br/>It can be shown that 0 is the optimal answer.<br/><br/>Example 2:<br/><br/>Input: nums = [5,3,2,10,15], x = 1<br/>Output: 1<br/>Explanation: We can select nums[1] = 3 and nums[2] = 2.<br/>They are at least 1 index apart, and their absolute difference is the minimum, 1.<br/>It can be shown that 1 is the optimal answer.<br/><br/>Example 3:<br/><br/>Input: nums = [1,2,3,4], x = 3<br/>Output: 3<br/>Explanation: We can select nums[0] = 1 and nums[3] = 4.<br/>They are at least 3 indices apart, and their absolute difference is the minimum, 3.<br/>It can be shown that 3 is the optimal answer.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^9<br/>0 &lt;= x &lt; nums.length</td>
<td>Class Solution:<br/>    Def Minabsolutedifference(self, Nums: List[int], X: Int) -&gt; Int:<br/>        Nums.sort()  # Sort The Input Array<br/>        <br/>        Min_diff = Float(&#39;inf&#39;)  # Initialize The Minimum Difference To Positive Infinity<br/>        <br/>        Left = 0  # Initialize The Left Pointer<br/>        Right = X  # Initialize The Right Pointer<br/>        <br/>        While Right &lt; Len(nums):<br/>            Min_diff = Min(min_diff, Nums[right] - Nums[left])  # Update The Minimum Difference<br/>            <br/>            Left += 1  # Move The Left Pointer<br/>            Right += 1  # Move The Right Pointer<br/>        <br/>        Return Min_diff</td>
<td>Class Solution:<br/>  Def Minabsolutedifference(self, Nums: List[int], X: Int) -&gt; Int:<br/>    If X == 0:<br/>      Return 0<br/><br/>    Arr, Best_dist = Sortedlist([]), Float(&#39;inf&#39;)<br/>    For I In Range(x, Len(nums)):<br/>      Arr.add(nums[i - X])<br/>      V = Nums[i]<br/><br/>      Pos = Arr.bisect_left(v)<br/>      If Pos &lt; Len(arr):<br/>        Best_dist = Min(best_dist, Abs(arr[pos] - V))<br/>      If Pos &gt; 0:<br/>        Best_dist = Min(best_dist, Abs(arr[pos - 1] - V))<br/>    <br/>    Return Best_dist</td>
</tr>
<tr>
<td align="right">27</td>
<td align="right">3</td>
<td>C++</td>
<td>medium</td>
<td>ChatGPT</td>
<td>Chatbot</td>
<td>You are given a 0-indexed integer array nums and an integer x.<br/><br/>Find the minimum absolute difference between two elements in the array that are at least x indices apart.<br/><br/>In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.<br/><br/>Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.<br/><br/>Example 1:<br/><br/>Input: nums = [4,3,2,4], x = 2<br/>Output: 0<br/>Explanation: We can select nums[0] = 4 and nums[3] = 4. <br/>They are at least 2 indices apart, and their absolute difference is the minimum, 0. <br/>It can be shown that 0 is the optimal answer.<br/><br/>Example 2:<br/><br/>Input: nums = [5,3,2,10,15], x = 1<br/>Output: 1<br/>Explanation: We can select nums[1] = 3 and nums[2] = 2.<br/>They are at least 1 index apart, and their absolute difference is the minimum, 1.<br/>It can be shown that 1 is the optimal answer.<br/><br/>Example 3:<br/><br/>Input: nums = [1,2,3,4], x = 3<br/>Output: 3<br/>Explanation: We can select nums[0] = 1 and nums[3] = 4.<br/>They are at least 3 indices apart, and their absolute difference is the minimum, 3.<br/>It can be shown that 3 is the optimal answer.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^9<br/>0 &lt;= x &lt; nums.length </td>
<td>Solve the following problem with C++ code. Class name: Solution, Method name: int minAbsoluteDifference(vector&lt;int&gt;&amp; nums, int x).<br/><br/>You are given a 0-indexed integer array nums and an integer x.<br/><br/>Find the minimum absolute difference between two elements in the array that are at least x indices apart.<br/><br/>In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.<br/><br/>Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.<br/><br/>Example 1:<br/><br/>Input: nums = [4,3,2,4], x = 2<br/>Output: 0<br/>Explanation: We can select nums[0] = 4 and nums[3] = 4. <br/>They are at least 2 indices apart, and their absolute difference is the minimum, 0. <br/>It can be shown that 0 is the optimal answer.<br/><br/>Example 2:<br/><br/>Input: nums = [5,3,2,10,15], x = 1<br/>Output: 1<br/>Explanation: We can select nums[1] = 3 and nums[2] = 2.<br/>They are at least 1 index apart, and their absolute difference is the minimum, 1.<br/>It can be shown that 1 is the optimal answer.<br/><br/>Example 3:<br/><br/>Input: nums = [1,2,3,4], x = 3<br/>Output: 3<br/>Explanation: We can select nums[0] = 1 and nums[3] = 4.<br/>They are at least 3 indices apart, and their absolute difference is the minimum, 3.<br/>It can be shown that 3 is the optimal answer.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^9<br/>0 &lt;= x &lt; nums.length</td>
<td>Class Solution {<br/>Public:<br/>    Int Minabsolutedifference(std::vector&lt;int&gt;&amp; Nums, Int X) {<br/>        Int N = Nums.size();<br/>        Std::vector&lt;std::pair&lt;int, Int&gt;&gt; Indexednums; // Store The Numbers Along With Their Indices<br/>        <br/>        // Create A Vector Of Pairs (Number, Index)<br/>        For (Int I = 0; I &lt; N; ++I) {<br/>            Indexednums.push_back({nums[i], I});<br/>        }<br/>        <br/>        // Sort The Vector Based On Numbers<br/>        Std::sort(indexednums.begin(), Indexednums.end());<br/>        <br/>        Int Mindiff = Int_max; // Initialize The Minimum Difference To A Large Value<br/>        <br/>        // Traverse The Sorted Vector And Find The Minimum Absolute Difference<br/>        For (Int I = 0; I &lt; N; ++I) {<br/>            // Find The Index Of The Element That Is At Least X Indices Apart<br/>            Int J = I + X;<br/>            If (J &lt; N) {<br/>                Int Diff = Abs(indexednums[i].first - Indexednums[j].first);<br/>                Mindiff = Std::min(mindiff, Diff);<br/>            }<br/>        }<br/>        <br/>        Return Mindiff;<br/>    }<br/>};</td>
<td>Class Solution {<br/>Public:<br/>    Int Minabsolutedifference(vector&lt;int&gt;&amp; Nums, Int X) {<br/>        Int Ans = Int_max;<br/>        Set&lt;int&gt; S;<br/>        For(int I = X; I &lt; Nums.size(); ++I){<br/>            S.insert(nums[i-x]);<br/>            Auto It = S.upper_bound(nums[i]);<br/>            If(it != S.end()) Ans = Min(ans, Abs(nums[i] - *It));<br/>            If(it != S.begin()) Ans = Min(ans, Abs(nums[i] - *Prev(it)));<br/>        }<br/>        Return Ans;<br/>    }<br/>};</td>
</tr>
<tr>
<td align="right">28</td>
<td align="right">4</td>
<td>Java</td>
<td>medium</td>
<td>ChatGPT</td>
<td>Chatbot</td>
<td>You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.<br/><br/>Return the head of the linked list after doubling it.<br/><br/>Example 1:<br/><br/>Input: head = [1,8,9]<br/>Output: [3,7,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.<br/><br/>Example 2:<br/><br/>Input: head = [9,9,9]<br/>Output: [1,9,9,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. <br/><br/>Constraints:<br/><br/>The number of nodes in the list is in the range [1, 10^4]<br/>0 &lt;= Node.val &lt;= 9<br/>The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself. </td>
<td>Solve the following problem with java code. Class name: Solution, Method name: doubleIt(ListNode head).<br/><br/>You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.<br/><br/>Return the head of the linked list after doubling it.<br/><br/>Example 1:<br/><br/>Input: head = [1,8,9]<br/>Output: [3,7,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.<br/><br/>Example 2:<br/><br/>Input: head = [9,9,9]<br/>Output: [1,9,9,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. <br/><br/>Constraints:<br/><br/>The number of nodes in the list is in the range [1, 10^4]<br/>0 &lt;= Node.val &lt;= 9<br/>The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.</td>
<td>Public Class Solution {<br/>    Public Listnode Doubleit(listnode Head) {<br/>        If (Head == Null) {<br/>            Return Null;<br/>        }<br/><br/>        Int Carry = 0;<br/>        Listnode Current = Head;<br/>        Listnode Prev = Null;<br/><br/>        // Traverse The List In Reverse Order And Double The Values<br/>        While (Current != Null) {<br/>            Int Newval = Current.val * 2 + Carry;<br/>            Carry = Newval / 10;<br/>            Current.val = Newval % 10;<br/><br/>            Prev = Current;<br/>            Current = Current.next;<br/>        }<br/><br/>        // If There&#39;s A Remaining Carry, Add A New Node For It<br/>        If (Carry &gt; 0) {<br/>            Listnode Newnode = New Listnode(carry);<br/>            Prev.next = Newnode;<br/>        }<br/><br/>        Return Reverselist(head);<br/>    }<br/><br/>    Public Listnode Reverselist(listnode Head) {<br/>        Listnode Prev = Null;<br/>        Listnode Current = Head;<br/><br/>        While (Current != Null) {<br/>            Listnode Nextnode = Current.next;<br/>            Current.next = Prev;<br/>            Prev = Current;<br/>            Current = Nextnode;<br/>        }<br/><br/>        Return Prev;<br/>    }<br/>}</td>
<td>Class Solution {<br/>    Public Listnode Doubleit(listnode Head) {<br/>        If (Head.val &gt; 4)<br/>            Head = New Listnode(0, Head);<br/>        For(listnode Node = Head; Node != Null; Node = Node.next) {<br/>            Node.val = (Node.val * 2) % 10;<br/>            If (Node.next != Null &amp;&amp; Node.next.val &gt; 4)<br/>                Node.val++;<br/>        }<br/>        Return Head;<br/>    }<br/>}</td>
</tr>
<tr>
<td align="right">29</td>
<td align="right">4</td>
<td>Python</td>
<td>medium</td>
<td>ChatGPT</td>
<td>Chatbot</td>
<td>You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.<br/><br/>Return the head of the linked list after doubling it.<br/><br/>Example 1:<br/><br/>Input: head = [1,8,9]<br/>Output: [3,7,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.<br/><br/>Example 2:<br/><br/>Input: head = [9,9,9]<br/>Output: [1,9,9,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. <br/><br/>Constraints:<br/><br/>The number of nodes in the list is in the range [1, 10^4]<br/>0 &lt;= Node.val &lt;= 9<br/>The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself. </td>
<td>Solve the following problem with python3 code. Class name: Solution, Method name: def doubleIt(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:.<br/><br/>You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.<br/><br/>Return the head of the linked list after doubling it.<br/><br/>Example 1:<br/><br/>Input: head = [1,8,9]<br/>Output: [3,7,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.<br/><br/>Example 2:<br/><br/>Input: head = [9,9,9]<br/>Output: [1,9,9,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. <br/><br/>Constraints:<br/><br/>The number of nodes in the list is in the range [1, 10^4]<br/>0 &lt;= Node.val &lt;= 9<br/>The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.</td>
<td>Class Solution:<br/>    Def Doubleit(self, Head: Optional[listnode]) -&gt; Optional[listnode]:<br/>        If Not Head:<br/>            Return None<br/>        <br/>        Carry = 0<br/>        Current = Head<br/>        Prev = None<br/>        <br/>        # Traverse The List In Reverse Order And Double The Values<br/>        While Current:<br/>            Newval = Current.val * 2 + Carry<br/>            Carry = Newval // 10<br/>            Current.val = Newval % 10<br/>            <br/>            Prev = Current<br/>            Current = Current.next<br/>        <br/>        # If There&#39;s A Remaining Carry, Add A New Node For It<br/>        If Carry &gt; 0:<br/>            Newnode = Listnode(carry)<br/>            Prev.next = Newnode<br/>        <br/>        Return Self.reverselist(head)<br/>    <br/>    Def Reverselist(self, Head: Optional[listnode]) -&gt; Optional[listnode]:<br/>        Prev = None<br/>        Current = Head<br/>        <br/>        While Current:<br/>            Nextnode = Current.next<br/>            Current.next = Prev<br/>            Prev = Current<br/>            Current = Nextnode<br/>        <br/>        Return Prev</td>
<td>Class Solution:<br/>    Def Doubleit(self, Head: Optional[listnode]) -&gt; Optional[listnode]:<br/>        If Head.val &gt; 4:<br/>            Head = Listnode(0, Head)<br/>        Node = Head<br/>        While Node:<br/>            Node.val = (Node.val * 2) % 10<br/>            If Node.next And Node.next.val &gt; 4:<br/>                Node.val += 1<br/>            Node = Node.next<br/>        Return Head</td>
</tr>
<tr>
<td align="right">30</td>
<td align="right">4</td>
<td>C++</td>
<td>medium</td>
<td>ChatGPT</td>
<td>Chatbot</td>
<td>You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.<br/><br/>Return the head of the linked list after doubling it.<br/><br/>Example 1:<br/><br/>Input: head = [1,8,9]<br/>Output: [3,7,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.<br/><br/>Example 2:<br/><br/>Input: head = [9,9,9]<br/>Output: [1,9,9,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. <br/><br/>Constraints:<br/><br/>The number of nodes in the list is in the range [1, 10^4]<br/>0 &lt;= Node.val &lt;= 9<br/>The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself. </td>
<td>Solve the following problem with C++ code. Class name: Solution, Method name: ListNode* doubleIt(ListNode* head).<br/><br/>You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.<br/><br/>Return the head of the linked list after doubling it.<br/><br/>Example 1:<br/><br/>Input: head = [1,8,9]<br/>Output: [3,7,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.<br/><br/>Example 2:<br/><br/>Input: head = [9,9,9]<br/>Output: [1,9,9,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. <br/><br/>Constraints:<br/><br/>The number of nodes in the list is in the range [1, 10^4]<br/>0 &lt;= Node.val &lt;= 9<br/>The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.</td>
<td>Class Solution {<br/>Public:<br/>    Listnode* Doubleit(listnode* Head) {<br/>        If (!Head) {<br/>            Return Nullptr;<br/>        }<br/><br/>        Int Carry = 0;<br/>        Listnode* Current = Head;<br/>        Listnode* Prev = Nullptr;<br/><br/>        // Traverse The List In Reverse Order And Double The Values<br/>        While (Current) {<br/>            Int Newval = Current-&gt;val * 2 + Carry;<br/>            Carry = Newval / 10;<br/>            Current-&gt;val = Newval % 10;<br/><br/>            Prev = Current;<br/>            Current = Current-&gt;next;<br/>        }<br/><br/>        // If There&#39;s A Remaining Carry, Add A New Node For It<br/>        If (Carry &gt; 0) {<br/>            Listnode* Newnode = New Listnode(carry);<br/>            Prev-&gt;next = Newnode;<br/>        }<br/><br/>        Return Reverselist(head);<br/>    }<br/><br/>    Listnode* Reverselist(listnode* Head) {<br/>        Listnode* Prev = Nullptr;<br/>        Listnode* Current = Head;<br/><br/>        While (Current) {<br/>            Listnode* Nextnode = Current-&gt;next;<br/>            Current-&gt;next = Prev;<br/>            Prev = Current;<br/>            Current = Nextnode;<br/>        }<br/><br/>        Return Prev;<br/>    }<br/>};</td>
<td>Class Solution {<br/>Public:<br/>    Listnode* Doubleit(listnode* Head) {<br/>        If (Head-&gt;val &gt; 4)<br/>            Head = New Listnode(0, Head);<br/>        For(listnode* Node = Head; Node; Node = Node-&gt;next) {<br/>            Node-&gt;val = (Node-&gt;val * 2) % 10;<br/>            If (Node-&gt;next &amp;&amp; Node-&gt;next-&gt;val &gt; 4)<br/>                Node-&gt;val++;<br/>        }<br/>        Return Head;<br/>    }<br/>};</td>
</tr>
<tr>
<td align="right">31</td>
<td align="right">5</td>
<td>Java</td>
<td>hard</td>
<td>ChatGPT</td>
<td>Chatbot</td>
<td>You are given an array nums of n positive integers and an integer k.<br/><br/>Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:<br/><br/>Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.<br/>Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.<br/>Multiply your score by x.<br/>Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.<br/><br/>The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.<br/><br/>Return the maximum possible score after applying at most k operations.<br/><br/>Since the answer may be large, return it modulo 10^9 + 7.<br/><br/>Example 1:<br/><br/>Input: nums = [8,3,9,3,8], k = 2<br/>Output: 81<br/>Explanation: To get a score of 81, we can apply the following operations:<br/>- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.<br/>It can be proven that 81 is the highest score one can obtain.<br/><br/>Example 2:<br/><br/>Input: nums = [19,12,14,6,10,18], k = 3<br/>Output: 4788<br/>Explanation: To get a score of 4788, we can apply the following operations: <br/>- Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.<br/>- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.<br/>It can be proven that 4788 is the highest score one can obtain.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length == n &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^5<br/>1 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9) </td>
<td>Solve the following problem with java code. Class name: Solution, Method name: maximumScore(List&lt;Integer&gt; nums, int k).<br/><br/>You are given an array nums of n positive integers and an integer k.<br/><br/>Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:<br/><br/>Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.<br/>Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.<br/>Multiply your score by x.<br/>Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.<br/><br/>The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.<br/><br/>Return the maximum possible score after applying at most k operations.<br/><br/>Since the answer may be large, return it modulo 10^9 + 7.<br/><br/>Example 1:<br/><br/>Input: nums = [8,3,9,3,8], k = 2<br/>Output: 81<br/>Explanation: To get a score of 81, we can apply the following operations:<br/>- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.<br/>It can be proven that 81 is the highest score one can obtain.<br/><br/>Example 2:<br/><br/>Input: nums = [19,12,14,6,10,18], k = 3<br/>Output: 4788<br/>Explanation: To get a score of 4788, we can apply the following operations: <br/>- Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.<br/>- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.<br/>It can be proven that 4788 is the highest score one can obtain.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length == n &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^5<br/>1 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9).</td>
<td>Public Class Solution {<br/>    Public Int Maximumscore(list&lt;integer&gt; Nums, Int K) {<br/>        Int Mod = 1000000007;<br/>        Int N = Nums.size();<br/>        <br/>        // Create An Array To Store The Prime Scores For Each Element.<br/>        Int[] Primescores = New Int[n];<br/>        <br/>        // Calculate The Prime Scores For Each Element Using A Helper Function.<br/>        For (Int I = 0; I &lt; N; I++) {<br/>            Primescores[i] = Calculateprimescore(nums.get(i));<br/>        }<br/>        <br/>        Long Score = 1l; // Initialize The Score As A Long Integer To Avoid Overflow.<br/>        <br/>        // Create A Max Heap To Keep Track Of The Elements With The Highest Prime Scores.<br/>        Priorityqueue&lt;integer&gt; Maxheap = New Priorityqueue&lt;&gt;((a, B) -&gt; Integer.compare(primescores[b], Primescores[a]));<br/>        <br/>        // Initialize The Max Heap With The Element At Index K.<br/>        Maxheap.offer(k);<br/>        <br/>        // Create Two Arrays To Keep Track Of The Left And Right Boundaries Of The Subarray.<br/>        Int[] Left = New Int[n];<br/>        Int[] Right = New Int[n];<br/>        <br/>        // Initialize The Left And Right Boundaries.<br/>        Left[k] = K;<br/>        Right[k] = K;<br/>        <br/>        // Perform At Most K Operations.<br/>        For (Int I = 0; I &lt; K; I++) {<br/>            Int Maxindex = Maxheap.poll(); // Get The Index With The Highest Prime Score.<br/>            <br/>            // Calculate The New Score By Multiplying The Current Score By The Selected Element.<br/>            Score = (Score * Nums.get(maxindex)) % Mod;<br/>            <br/>            // Update The Left And Right Boundaries For The Subarray.<br/>            Int Newleft = Left[maxindex] - 1;<br/>            Int Newright = Right[maxindex] + 1;<br/>            <br/>            // Add The New Potential Candidates To The Max Heap.<br/>            If (Newleft &gt;= 0) {<br/>                Maxheap.offer(newleft);<br/>                Left[newleft] = Newleft;<br/>                Right[newleft] = Right[maxindex];<br/>            }<br/>            If (Newright &lt; N) {<br/>                Maxheap.offer(newright);<br/>                Left[newright] = Left[maxindex];<br/>                Right[newright] = Newright;<br/>            }<br/>        }<br/>        <br/>        Return (Int)score;<br/>    }<br/>    <br/>    // Helper Function To Calculate The Prime Score Of An Integer.<br/>    Private Int Calculateprimescore(int Num) {<br/>        Set&lt;integer&gt; Factors = New Hashset&lt;&gt;();<br/>        <br/>        // Find Prime Factors Of The Number.<br/>        While (Num % 2 == 0) {<br/>            Factors.add(2);<br/>            Num /= 2;<br/>        }<br/>        <br/>        For (Int I = 3; I &lt;= Math.sqrt(num); I += 2) {<br/>            While (Num % I == 0) {<br/>                Factors.add(i);<br/>                Num /= I;<br/>            }<br/>        }<br/>        <br/>        If (Num &gt; 2) {<br/>            Factors.add(num);<br/>        }<br/>        <br/>        Return Factors.size();<br/>    }<br/>}</td>
<td>Class Solution {<br/>    Static Final Int Mod = 1000000007;<br/><br/>    Public Int Maximumscore(list&lt;integer&gt; Nums, Int K) {<br/>        Int N = Nums.size();<br/><br/>        Int Upper = Collections.max(nums) + 1;<br/><br/>        Boolean[] Prime = New Boolean[upper];<br/>        Int[] Primescore = New Int[upper];<br/>        Arrays.fill(prime, True);<br/>        Prime[0] = Prime[1] = False;<br/>        For (Int I = 2; I &lt; Upper; I++) {<br/>            If (Prime[i]) {<br/>                For (Int J = I; J &lt; Upper; J += I) {<br/>                    Primescore[j]++;<br/>                    Prime[j] = False;<br/>                }<br/>            }<br/>        }<br/><br/>        Int[] Nextgreaterelement = New Int[n];<br/>        Arrays.fill(nextgreaterelement, N);<br/>        Stack&lt;integer&gt; S = New Stack&lt;&gt;();<br/>        For (Int I = N - 1; I &gt;= 0; I--) {<br/>            While (!S.empty() &amp;&amp; Primescore[nums.get(i)] &gt;= Primescore[nums.get(s.peek())]) {<br/>                S.pop();<br/>            }<br/>            Nextgreaterelement[i] = S.empty() ? N : S.peek();<br/>            S.push(i);<br/>        }<br/><br/>        Int[] Prevgreaterorequalelement = New Int[n];<br/>        Arrays.fill(prevgreaterorequalelement, -1);<br/>        S = New Stack&lt;&gt;();<br/>        For (Int I = 0; I &lt; N; I++) {<br/>            While (!S.empty() &amp;&amp; Primescore[nums.get(i)] &gt; Primescore[nums.get(s.peek())]) {<br/>                S.pop();<br/>            }<br/>            Prevgreaterorequalelement[i] = S.empty() ? -1 : S.peek();<br/>            S.push(i);<br/>        }<br/><br/>        Int Res = 1;<br/>        Int[][] Tuples = New Int[n][2];<br/>        For (Int I = 0; I &lt; N; I++) {<br/>            Tuples[i][0] = Nums.get(i);<br/>            Tuples[i][1] = I;<br/>        }<br/>        Arrays.sort(tuples, New Comparator&lt;int[]&gt;() {<br/>            Public Int Compare(int[] A, Int[] B) {<br/>                Return B[0] - A[0];<br/>            }<br/>        });<br/>        For (Int I = 0; I &lt; N; I++) {<br/>            Int Num = Tuples[i][0];<br/>            Int Idx = Tuples[i][1];<br/>            Int Operations = Math.min((idx - Prevgreaterorequalelement[idx]) * (Nextgreaterelement[idx] - Idx), K);<br/>            Res = (Int)((1l * Res * Pow(num, Operations)) % Mod);<br/>            K -= Operations;<br/>            If (K == 0) {<br/>                Return Res;<br/>            }<br/>        }<br/><br/>        Return Res;<br/>    }<br/><br/>    Public Int Pow(int X, Int N) {<br/>        Int Res = 1;<br/>        While (N &gt; 0) {<br/>            If (N % 2 == 1) {<br/>                Res = (Int)((1l * Res * X) % Mod);<br/>            }<br/>            X = (Int)((1l * X * X) % Mod);<br/>            N /= 2;<br/>        }<br/>        Return Res;<br/>    }<br/>}</td>
</tr>
<tr>
<td align="right">32</td>
<td align="right">5</td>
<td>Python</td>
<td>hard</td>
<td>ChatGPT</td>
<td>Chatbot</td>
<td>You are given an array nums of n positive integers and an integer k.<br/><br/>Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:<br/><br/>Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.<br/>Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.<br/>Multiply your score by x.<br/>Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.<br/><br/>The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.<br/><br/>Return the maximum possible score after applying at most k operations.<br/><br/>Since the answer may be large, return it modulo 10^9 + 7.<br/><br/>Example 1:<br/><br/>Input: nums = [8,3,9,3,8], k = 2<br/>Output: 81<br/>Explanation: To get a score of 81, we can apply the following operations:<br/>- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.<br/>It can be proven that 81 is the highest score one can obtain.<br/><br/>Example 2:<br/><br/>Input: nums = [19,12,14,6,10,18], k = 3<br/>Output: 4788<br/>Explanation: To get a score of 4788, we can apply the following operations: <br/>- Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.<br/>- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.<br/>It can be proven that 4788 is the highest score one can obtain.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length == n &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^5<br/>1 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9) </td>
<td>Solve the following problem with python3 code. Class name: Solution, Method name: def maximumScore(self, nums: List[int], k: int) -&gt; int:.<br/><br/>You are given an array nums of n positive integers and an integer k.<br/><br/>Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:<br/><br/>Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.<br/>Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.<br/>Multiply your score by x.<br/>Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.<br/><br/>The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.<br/><br/>Return the maximum possible score after applying at most k operations.<br/><br/>Since the answer may be large, return it modulo 10^9 + 7.<br/><br/>Example 1:<br/><br/>Input: nums = [8,3,9,3,8], k = 2<br/>Output: 81<br/>Explanation: To get a score of 81, we can apply the following operations:<br/>- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.<br/>It can be proven that 81 is the highest score one can obtain.<br/><br/>Example 2:<br/><br/>Input: nums = [19,12,14,6,10,18], k = 3<br/>Output: 4788<br/>Explanation: To get a score of 4788, we can apply the following operations: <br/>- Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.<br/>- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.<br/>It can be proven that 4788 is the highest score one can obtain.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length == n &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^5<br/>1 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9).</td>
<td>Class Solution:<br/>    Def Maximumscore(self, Nums: List[int], K: Int) -&gt; Int:<br/>        Def Prime_score(x):<br/>            Factors = Set()<br/>            While X % 2 == 0:<br/>                Factors.add(2)<br/>                X //= 2<br/>            For I In Range(3, Int(x ** 0.5) + 1, 2):<br/>                While X % I == 0:<br/>                    Factors.add(i)<br/>                    X //= I<br/>            If X &gt; 2:<br/>                Factors.add(x)<br/>            Return Len(factors)<br/>        <br/>        Max_score = 1<br/>        Mod = 10 ** 9 + 7<br/>        <br/>        Pq = []  # Priority Queue To Store Elements By Their Prime Scores<br/>        <br/>        For Num In Nums:<br/>            Heapq.heappush(pq, (-Prime_score(num), Num))  # Use A Negative Score To Get The Maximum Prime Score First<br/>        <br/>        While K &gt; 0:<br/>            Prime_score, Num = Heapq.heappop(pq)  # Pop The Element With The Highest Prime Score<br/>            Max_score = (Max_score * Num) % Mod<br/>            K -= 1<br/>        <br/>        Return Max_score</td>
<td>Class Solution: <br/>    Mod = 1000000007<br/><br/>    Def Maximumscore(self, Nums: List[int], K: Int) -&gt; Int:<br/>        N = Len(nums)<br/><br/>        Upper = Max(nums) + 1<br/><br/>        Prime = [True]*upper<br/>        Prime[0] = Prime[1] = False<br/>        Primescore = [0]*upper<br/>        For I In Range(2, Upper):<br/>            If Prime[i]:<br/>                For J In Range(i, Upper, I):<br/>                    Primescore[j] += 1<br/>                    Prime[j] = False<br/><br/>        Nextgreaterelement = [N]*n<br/>        S = []<br/>        For I In Range(n - 1, -1, -1):<br/>            While S And Primescore[nums[i]] &gt;= Primescore[nums[s[-1]]]:<br/>                S.pop()<br/>            Nextgreaterelement[i] = S[-1] If S Else N<br/>            S.append(i)<br/><br/>        Prevgreaterorequalelement = [-1]*n<br/>        S = []<br/>        For I In Range(n):<br/>            While S And Primescore[nums[i]] &gt; Primescore[nums[s[-1]]]:<br/>                S.pop()<br/>            Prevgreaterorequalelement[i] = S[-1] If S Else -1<br/>            S.append(i)<br/><br/>        Res = 1<br/>        Tuples = [[Nums[i], I] For I In Range(n)]<br/>        Tuples.sort(reverse=true)<br/>        For Num, Idx In Tuples:<br/>            Operations = Min((idx - Prevgreaterorequalelement[idx]) * (Nextgreaterelement[idx] - Idx), K)<br/>            Res = (Res * Self.pow(num, Operations)) % Self.mod<br/>            K -= Operations<br/>            If K == 0:<br/>                Return Res<br/><br/>        Return Res<br/><br/>    Def Pow(self, X: Int, N: Int) -&gt; Int:<br/>        Res = 1<br/>        While N &gt; 0:<br/>            If N % 2 == 1:<br/>                Res = (Res * X) % Self.mod<br/>            X = (X * X) % Self.mod<br/>            N //= 2<br/>        Return Res</td>
</tr>
<tr>
<td align="right">33</td>
<td align="right">5</td>
<td>C++</td>
<td>hard</td>
<td>ChatGPT</td>
<td>Chatbot</td>
<td>You are given an array nums of n positive integers and an integer k.<br/><br/>Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:<br/><br/>Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.<br/>Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.<br/>Multiply your score by x.<br/>Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.<br/><br/>The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.<br/><br/>Return the maximum possible score after applying at most k operations.<br/><br/>Since the answer may be large, return it modulo 10^9 + 7.<br/><br/>Example 1:<br/><br/>Input: nums = [8,3,9,3,8], k = 2<br/>Output: 81<br/>Explanation: To get a score of 81, we can apply the following operations:<br/>- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.<br/>It can be proven that 81 is the highest score one can obtain.<br/><br/>Example 2:<br/><br/>Input: nums = [19,12,14,6,10,18], k = 3<br/>Output: 4788<br/>Explanation: To get a score of 4788, we can apply the following operations: <br/>- Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.<br/>- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.<br/>It can be proven that 4788 is the highest score one can obtain.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length == n &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^5<br/>1 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9) </td>
<td>Solve the following problem with C++ code. Class name: Solution, Method name: int maximumScore(vector&lt;int&gt;&amp; nums, int k).<br/><br/>You are given an array nums of n positive integers and an integer k.<br/><br/>Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:<br/><br/>Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.<br/>Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.<br/>Multiply your score by x.<br/>Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.<br/><br/>The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.<br/><br/>Return the maximum possible score after applying at most k operations.<br/><br/>Since the answer may be large, return it modulo 10^9 + 7.<br/><br/>Example 1:<br/><br/>Input: nums = [8,3,9,3,8], k = 2<br/>Output: 81<br/>Explanation: To get a score of 81, we can apply the following operations:<br/>- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.<br/>It can be proven that 81 is the highest score one can obtain.<br/><br/>Example 2:<br/><br/>Input: nums = [19,12,14,6,10,18], k = 3<br/>Output: 4788<br/>Explanation: To get a score of 4788, we can apply the following operations: <br/>- Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.<br/>- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.<br/>It can be proven that 4788 is the highest score one can obtain.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length == n &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^5<br/>1 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9).</td>
<td>Class Solution {<br/>Public:<br/>    Const Int Mod = 1e9 + 7;<br/><br/>    Int Maximumscore(std::vector&lt;int&gt;&amp; Nums, Int K) {<br/>        Int N = Nums.size();<br/>        Std::unordered_map&lt;int, Int&gt; Primescore; // Map To Store Prime Scores Of Elements<br/>        Int Left = 0; // Left Pointer Of The Sliding Window<br/>        Long Long Score = 1; // Initial Score<br/>        Int Maxscore = 1; // Maximum Score<br/><br/>        For (Int Right = 0; Right &lt; N; ++Right) {<br/>            // Calculate Prime Score For The New Element<br/>            Int Curscore = Calculateprimescore(nums[right]);<br/><br/>            // Update Prime Score Map<br/>            Primescore[nums[right]]++;<br/><br/>            // Increment The Score By Multiplying It With The Prime Score<br/>            Score = (Score * Curscore) % Mod;<br/><br/>            // Check If The Window Size Exceeds K, Then We Need To Shrink The Window<br/>            While (Right - Left + 1 &gt; K) {<br/>                Int Leftelem = Nums[left];<br/>                Primescore[leftelem]--;<br/><br/>                // If The Left Element Has No More Occurrences In The Window, Remove It From The Map<br/>                If (Primescore[leftelem] == 0) {<br/>                    Primescore.erase(leftelem);<br/>                }<br/><br/>                // Move The Left Pointer To The Right<br/>                Left++;<br/>            }<br/><br/>            // Update The Maximum Score<br/>            Maxscore = Std::max(maxscore, Static_cast&lt;int&gt;(score));<br/>        }<br/><br/>        Return Maxscore;<br/>    }<br/><br/>    // Helper Function To Calculate The Prime Score Of An Integer<br/>    Int Calculateprimescore(int X) {<br/>        Int Score = 0;<br/>        For (Int I = 2; I * I &lt;= X; ++I) {<br/>            While (X % I == 0) {<br/>                X /= I;<br/>                Score++;<br/>            }<br/>        }<br/>        If (X &gt; 1) {<br/>            Score++;<br/>        }<br/>        Return Score;<br/>    }<br/>};</td>
<td>Class Solution {<br/>Public:<br/>    Const Int Mod = 1000000007;<br/><br/>    Int Maximumscore(vector&lt;int&gt;&amp; Nums, Int K) {<br/>        Int N = Nums.size();<br/><br/>        Int Upper = *Max_element(nums.begin(), Nums.end()) + 1;<br/><br/>        Vector&lt;bool&gt; Prime(upper, True);<br/>        Prime[0] = Prime[1] = False;<br/>        Vector&lt;int&gt; Primescore(upper, 0);<br/>        For (Int I = 2; I &lt; Upper; I++) {<br/>            If (Prime[i]) {<br/>                For (Int J = I; J &lt; Upper; J += I) {<br/>                    Primescore[j]++;<br/>                    Prime[j] = False;<br/>                }<br/>            }<br/>        }<br/><br/>        Vector&lt;int&gt; Nextgreaterelement(n, N);<br/>        Stack&lt;int&gt; S;<br/>        For (Int I = N - 1; I &gt;= 0; I--) {<br/>            While (!S.empty() &amp;&amp; Primescore[nums[i]] &gt;= Primescore[nums[s.top()]]) {<br/>                S.pop();<br/>            }<br/>            Nextgreaterelement[i] = S.empty() ? N : S.top();<br/>            S.push(i);<br/>        }<br/><br/>        Vector&lt;int&gt; Prevgreaterorequalelement(n, -1);<br/>        S = Stack&lt;int&gt;();<br/>        For (Int I = 0; I &lt; N; I++) {<br/>            While (!S.empty() &amp;&amp; Primescore[nums[i]] &gt; Primescore[nums[s.top()]]) {<br/>                S.pop();<br/>            }<br/>            Prevgreaterorequalelement[i] = S.empty() ? -1 : S.top();<br/>            S.push(i);<br/>        }<br/><br/>        Int Res = 1;<br/>        Vector&lt;pair&lt;int, Int&gt;&gt; Tuples(n);<br/>        For (Int I = 0; I &lt; N; I++) {<br/>            Tuples[i].first = Nums[i];<br/>            Tuples[i].second = I;<br/>        }<br/>        Sort(tuples.rbegin(), Tuples.rend());<br/>        For (Const Auto&amp; [Num, I] : Tuples) {<br/>            Int Operations = Min((i - Prevgreaterorequalelement[i]) * (Nextgreaterelement[i] - I), K);<br/>            Res = (Int)((1l * Res * Pow(num, Operations)) % Mod);<br/>            K -= Operations;<br/>            If (K == 0) {<br/>                Return Res;<br/>            }<br/>        }<br/><br/>        Return Res;<br/>    }<br/><br/>    Int Pow(int X, Int N) {<br/>        Int Res = 1;<br/>        While (N &gt; 0) {<br/>            If (N % 2 == 1) {<br/>                Res = (Int)((1l * Res * X) % Mod);<br/>            }<br/>            X = (Int)((1l * X * X) % Mod);<br/>            N /= 2;<br/>        }<br/>        Return Res;<br/>    }<br/>};</td>
</tr>
<tr>
<td align="right">34</td>
<td align="right">6</td>
<td>Java</td>
<td>hard</td>
<td>ChatGPT</td>
<td>Chatbot</td>
<td>You are given a 0-indexed 2D integer array items of length n and an integer k.<br/><br/>items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.<br/><br/>Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.<br/><br/>Your task is to find the maximum elegance from all subsequences of size k in items.<br/><br/>Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.<br/><br/>Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.<br/><br/>Example 1:<br/><br/>Input: items = [[3,2],[5,1],[10,1]], k = 2<br/>Output: 17<br/>Explanation: In this example, we have to select a subsequence of size 2.<br/>We can select items[0] = [3,2] and items[2] = [10,1].<br/>The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].<br/>Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. <br/><br/>Example 2:<br/><br/>Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3<br/>Output: 19<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. <br/>The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. <br/>Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.<br/><br/>Example 3:<br/><br/>Input: items = [[1,1],[2,1],[3,1]], k = 3<br/>Output: 7<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We should select all the items. <br/>The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. <br/>Hence, the maximum elegance is 6 + 1^2 = 7.  <br/> <br/>Constraints:<br/><br/>1 &lt;= items.length == n &lt;= 10^5<br/>items[i].length == 2<br/>items[i][0] == profit_i<br/>items[i][1] == category_i<br/>1 &lt;= profit_i &lt;= 10^9<br/>1 &lt;= category_i &lt;= n <br/>1 &lt;= k &lt;= n </td>
<td>Solve the following problem with java code. Class name: Solution, Method name: findMaximumElegance(int [][] items, int k).<br/><br/>You are given a 0-indexed 2D integer array items of length n and an integer k.<br/><br/>items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.<br/><br/>Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.<br/><br/>Your task is to find the maximum elegance from all subsequences of size k in items.<br/><br/>Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.<br/><br/>Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.<br/><br/>Example 1:<br/><br/>Input: items = [[3,2],[5,1],[10,1]], k = 2<br/>Output: 17<br/>Explanation: In this example, we have to select a subsequence of size 2.<br/>We can select items[0] = [3,2] and items[2] = [10,1].<br/>The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].<br/>Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. <br/><br/>Example 2:<br/><br/>Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3<br/>Output: 19<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. <br/>The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. <br/>Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.<br/><br/>Example 3:<br/><br/>Input: items = [[1,1],[2,1],[3,1]], k = 3<br/>Output: 7<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We should select all the items. <br/>The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. <br/>Hence, the maximum elegance is 6 + 1^2 = 7.  <br/> <br/>Constraints:<br/><br/>1 &lt;= items.length == n &lt;= 10^5<br/>items[i].length == 2<br/>items[i][0] == profit_i<br/>items[i][1] == category_i<br/>1 &lt;= profit_i &lt;= 10^9<br/>1 &lt;= category_i &lt;= n <br/>1 &lt;= k &lt;= n</td>
<td>Public Class Solution {<br/>    Public Int Findmaximumelegance(int[][] Items, Int K) {<br/>        List&lt;int[]&gt; Itemlist = New Arraylist&lt;&gt;();<br/>        Map&lt;integer, Integer&gt; Categoryfreq = New Hashmap&lt;&gt;();<br/>        Int Totalprofit = 0;<br/>        Int Distinctcategories = 0;<br/>        Int Maxelegance = 0;<br/><br/>        For (Int[] Item : Items) {<br/>            Itemlist.add(item);<br/>        }<br/><br/>        Collections.sort(itemlist, (A, B) -&gt; B[0] - A[0]); // Sort By Profit In Descending Order<br/><br/>        For (Int I = 0; I &lt; Itemlist.size(); I++) {<br/>            Int[] Item = Itemlist.get(i);<br/>            Int Profit = Item[0];<br/>            Int Category = Item[1];<br/><br/>            Categoryfreq.put(category, Categoryfreq.getordefault(category, 0) + 1);<br/>            Totalprofit += Profit;<br/><br/>            If (Categoryfreq.get(category) == 1) {<br/>                Distinctcategories++;<br/>            }<br/><br/>            Int Elegance = Totalprofit + Distinctcategories * Distinctcategories;<br/>            Maxelegance = Math.max(maxelegance, Elegance);<br/><br/>            If (Distinctcategories == K) {<br/>                Break; // We Have Reached The Required Number Of Distinct Categories<br/>            }<br/>        }<br/><br/>        Return Maxelegance;<br/>    }<br/>}</td>
<td>Class Solution {<br/>    Public Long Findmaximumelegance(int[][] A, Int K) {<br/>        Arrays.sort(a, (A, B) -&gt; B[0] - A[0]);<br/>        Long Res = 0, Cur = 0;<br/>        List&lt;integer&gt; Dup = New Arraylist&lt;&gt;();<br/>        Set&lt;integer&gt; Seen = New Hashset&lt;&gt;();<br/>        For (Int I = 0; I &lt; A.length; ++I) {<br/>            If (I &lt; K) {<br/>                If (Seen.contains(a[i][1])) {<br/>                    Dup.add(a[i][0]);<br/>                }<br/>                Cur += A[i][0];<br/>            } Else If (!Seen.contains(a[i][1])) {<br/>                If (Dup.isempty()) Break;<br/>                Cur += A[i][0] - Dup.remove(dup.size() - 1);<br/>            }<br/>            Seen.add(a[i][1]);<br/>            Res = Math.max(res, Cur + 1l * Seen.size() * Seen.size());<br/>        }<br/>        Return Res;<br/>    }<br/>}</td>
</tr>
<tr>
<td align="right">35</td>
<td align="right">6</td>
<td>Python</td>
<td>hard</td>
<td>ChatGPT</td>
<td>Chatbot</td>
<td>You are given a 0-indexed 2D integer array items of length n and an integer k.<br/><br/>items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.<br/><br/>Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.<br/><br/>Your task is to find the maximum elegance from all subsequences of size k in items.<br/><br/>Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.<br/><br/>Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.<br/><br/>Example 1:<br/><br/>Input: items = [[3,2],[5,1],[10,1]], k = 2<br/>Output: 17<br/>Explanation: In this example, we have to select a subsequence of size 2.<br/>We can select items[0] = [3,2] and items[2] = [10,1].<br/>The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].<br/>Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. <br/><br/>Example 2:<br/><br/>Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3<br/>Output: 19<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. <br/>The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. <br/>Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.<br/><br/>Example 3:<br/><br/>Input: items = [[1,1],[2,1],[3,1]], k = 3<br/>Output: 7<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We should select all the items. <br/>The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. <br/>Hence, the maximum elegance is 6 + 1^2 = 7.  <br/> <br/>Constraints:<br/><br/>1 &lt;= items.length == n &lt;= 10^5<br/>items[i].length == 2<br/>items[i][0] == profit_i<br/>items[i][1] == category_i<br/>1 &lt;= profit_i &lt;= 10^9<br/>1 &lt;= category_i &lt;= n <br/>1 &lt;= k &lt;= n </td>
<td>Solve the following problem with python3 code. Class name: Solution, Method name: def findMaximumElegance(self, items: List[List[int]], k: int) -&gt; int:.<br/><br/>You are given a 0-indexed 2D integer array items of length n and an integer k.<br/><br/>items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.<br/><br/>Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.<br/><br/>Your task is to find the maximum elegance from all subsequences of size k in items.<br/><br/>Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.<br/><br/>Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.<br/><br/>Example 1:<br/><br/>Input: items = [[3,2],[5,1],[10,1]], k = 2<br/>Output: 17<br/>Explanation: In this example, we have to select a subsequence of size 2.<br/>We can select items[0] = [3,2] and items[2] = [10,1].<br/>The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].<br/>Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. <br/><br/>Example 2:<br/><br/>Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3<br/>Output: 19<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. <br/>The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. <br/>Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.<br/><br/>Example 3:<br/><br/>Input: items = [[1,1],[2,1],[3,1]], k = 3<br/>Output: 7<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We should select all the items. <br/>The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. <br/>Hence, the maximum elegance is 6 + 1^2 = 7.  <br/> <br/>Constraints:<br/><br/>1 &lt;= items.length == n &lt;= 10^5<br/>items[i].length == 2<br/>items[i][0] == profit_i<br/>items[i][1] == category_i<br/>1 &lt;= profit_i &lt;= 10^9<br/>1 &lt;= category_i &lt;= n <br/>1 &lt;= k &lt;= n</td>
<td>Class Solution:<br/>    Def Findmaximumelegance(self, Items: List[list[int]], K: Int) -&gt; Int:<br/>        N = Len(items)<br/>        Max_elegance = 0<br/>        <br/>        # Generate All Possible Combinations Of Items With Size K<br/>        For Combo In Combinations(items, K):<br/>            Total_profit = Sum(item[0] For Item In Combo)<br/>            Categories = [Item[1] For Item In Combo]<br/>            Distinct_categories = Len(counter(categories))<br/>            Elegance = Total_profit + Distinct_categories ** 2<br/>            Max_elegance = Max(max_elegance, Elegance)<br/>        <br/>        Return Max_elegance</td>
<td>Class Solution:<br/>    Def Findmaximumelegance(self, Items: List[list[int]], K: Int) -&gt; Int:<br/>        Items = Sorted(items, Key=lambda V: -V[0])<br/>        Res = Cur = 0<br/>        A = []<br/>        Seen = Set()<br/>        For I, (P, C) In Enumerate(items):<br/>            If I &lt; K:<br/>                If C In Seen:<br/>                    A.append(p)<br/>                Cur += P<br/>            Elif C Not In Seen:<br/>                If Not A: Break<br/>                Cur += P - A.pop()<br/>            Seen.add(c)<br/>            Res = Max(res, Cur + Len(seen) * Len(seen))<br/>        Return Res</td>
</tr>
<tr>
<td align="right">36</td>
<td align="right">6</td>
<td>C++</td>
<td>hard</td>
<td>ChatGPT</td>
<td>Chatbot</td>
<td>You are given a 0-indexed 2D integer array items of length n and an integer k.<br/><br/>items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.<br/><br/>Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.<br/><br/>Your task is to find the maximum elegance from all subsequences of size k in items.<br/><br/>Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.<br/><br/>Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.<br/><br/>Example 1:<br/><br/>Input: items = [[3,2],[5,1],[10,1]], k = 2<br/>Output: 17<br/>Explanation: In this example, we have to select a subsequence of size 2.<br/>We can select items[0] = [3,2] and items[2] = [10,1].<br/>The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].<br/>Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. <br/><br/>Example 2:<br/><br/>Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3<br/>Output: 19<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. <br/>The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. <br/>Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.<br/><br/>Example 3:<br/><br/>Input: items = [[1,1],[2,1],[3,1]], k = 3<br/>Output: 7<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We should select all the items. <br/>The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. <br/>Hence, the maximum elegance is 6 + 1^2 = 7.  <br/> <br/>Constraints:<br/><br/>1 &lt;= items.length == n &lt;= 10^5<br/>items[i].length == 2<br/>items[i][0] == profit_i<br/>items[i][1] == category_i<br/>1 &lt;= profit_i &lt;= 10^9<br/>1 &lt;= category_i &lt;= n <br/>1 &lt;= k &lt;= n </td>
<td>Solve the following problem with C++ code. Class name: Solution, Method name: long long findMaximumElegance(vector&lt;vector&lt;int&gt;&gt;&amp; items, int k).<br/><br/>You are given a 0-indexed 2D integer array items of length n and an integer k.<br/><br/>items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.<br/><br/>Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.<br/><br/>Your task is to find the maximum elegance from all subsequences of size k in items.<br/><br/>Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.<br/><br/>Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.<br/><br/>Example 1:<br/><br/>Input: items = [[3,2],[5,1],[10,1]], k = 2<br/>Output: 17<br/>Explanation: In this example, we have to select a subsequence of size 2.<br/>We can select items[0] = [3,2] and items[2] = [10,1].<br/>The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].<br/>Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. <br/><br/>Example 2:<br/><br/>Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3<br/>Output: 19<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. <br/>The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. <br/>Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.<br/><br/>Example 3:<br/><br/>Input: items = [[1,1],[2,1],[3,1]], k = 3<br/>Output: 7<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We should select all the items. <br/>The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. <br/>Hence, the maximum elegance is 6 + 1^2 = 7.  <br/> <br/>Constraints:<br/><br/>1 &lt;= items.length == n &lt;= 10^5<br/>items[i].length == 2<br/>items[i][0] == profit_i<br/>items[i][1] == category_i<br/>1 &lt;= profit_i &lt;= 10^9<br/>1 &lt;= category_i &lt;= n <br/>1 &lt;= k &lt;= n</td>
<td>Class Solution {<br/>Public:<br/>    Long Long Findmaximumelegance(std::vector&lt;std::vector&lt;int&gt;&gt;&amp; Items, Int K) {<br/>        Std::unordered_map&lt;int, Std::vector&lt;int&gt;&gt; Categorytoprofits;<br/>        Std::unordered_map&lt;int, Long Long&gt; Categorytototalprofit;<br/><br/>        For (Auto&amp; Item : Items) {<br/>            Int Profit = Item[0];<br/>            Int Category = Item[1];<br/>            Categorytoprofits[category].push_back(profit);<br/>            Categorytototalprofit[category] += Profit;<br/>        }<br/><br/>        Std::vector&lt;long Long&gt; Maxprofits;<br/>        Long Long Totalelegance = 0;<br/><br/>        For (Auto&amp; Pair : Categorytoprofits) {<br/>            Int Category = Pair.first;<br/>            Std::vector&lt;int&gt;&amp; Profits = Pair.second;<br/><br/>            Std::sort(profits.rbegin(), Profits.rend());<br/><br/>            Long Long Categorytotalprofit = Categorytototalprofit[category];<br/>            Int Categorydistinctcount = Profits.size();<br/><br/>            For (Int I = 0; I &lt; K &amp;&amp; I &lt; Categorydistinctcount; ++I) {<br/>                Totalelegance += Profits[i] + Static_cast&lt;long Long&gt;(categorydistinctcount) * Categorydistinctcount;<br/>                Maxprofits.push_back(profits[i]);<br/>            }<br/>        }<br/><br/>        Std::sort(maxprofits.rbegin(), Maxprofits.rend());<br/><br/>        For (Int I = K; I &lt; Maxprofits.size(); ++I) {<br/>            Totalelegance -= Maxprofits[i];<br/>        }<br/><br/>        Return Totalelegance;<br/>    }<br/>};</td>
<td>Class Solution {<br/>Public:<br/>    Long Long Findmaximumelegance(vector&lt;vector&lt;int&gt;&gt;&amp; A, Int K) {<br/>        Sort(a.begin(), A.end(), [](Const Vector&lt;int&gt;&amp; A, Const Vector&lt;int&gt;&amp; B) {<br/>            Return A[0] &gt; B[0];<br/>        });<br/>        Long Long Res = 0, Cur = 0;<br/>        Vector&lt;int&gt; Dup;<br/>        Unordered_set&lt;int&gt; Seen;<br/>        For (Int I = 0; I &lt; A.size(); ++I) {<br/>            If (I &lt; K) {<br/>                If (Seen.count(a[i][1])) {<br/>                    Dup.push_back(a[i][0]);<br/>                }<br/>                Cur += A[i][0];<br/>            } Else If (Seen.find(a[i][1]) == Seen.end()) {<br/>                If (Dup.empty()) Break;<br/>                Cur += A[i][0] - Dup.back();<br/>                Dup.pop_back();<br/>            }<br/>            Seen.insert(a[i][1]);<br/>            Res = Fmax(res, Cur + 1l * Seen.size() * Seen.size());<br/>        }<br/>        Return Res;<br/>    }<br/>};</td>
</tr>
<tr>
<td align="right">37</td>
<td align="right">1</td>
<td>Java</td>
<td>easy</td>
<td>Code Llama</td>
<td>IDE Extension</td>
<td>You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.<br/><br/>Return the maximum sum or -1 if no such pair exists.<br/><br/>Example 1:<br/><br/>Input: nums = [51,71,17,24,42]<br/>Output: 88<br/>Explanation: <br/>For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. <br/>For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.<br/>It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.<br/><br/>Example 2:<br/><br/>Input: nums = [1,2,3,4]<br/>Output: -1<br/>Explanation: No pair exists in nums with equal maximum digits.<br/><br/>Constraints:<br/><br/>2 &lt;= nums.length &lt;= 100<br/>1 &lt;= nums[i] &lt;= 10^4 </td>
<td>class Solution {<br/>    public int maxSum(int[] nums) {<br/>/*You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.<br/><br/>Return the maximum sum or -1 if no such pair exists.<br/><br/>Example 1:<br/><br/>Input: nums = [51,71,17,24,42]<br/>Output: 88<br/>Explanation: <br/>For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. <br/>For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.<br/>It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.<br/><br/>Example 2:<br/><br/>Input: nums = [1,2,3,4]<br/>Output: -1<br/>Explanation: No pair exists in nums with equal maximum digits.<br/><br/>Constraints:<br/><br/>2 &lt;= nums.length &lt;= 100<br/>1 &lt;= nums[i] &lt;= 10^4*/</td>
<td>Class Solution {<br/>    Public Int Maxsum(int[] Nums) {<br/>        Int Max = 0;<br/>        Int Maxdigit = 0;<br/>        For(int I = 0; I &lt; Nums.length; I++){<br/>            Int Digit = 0;<br/>            Int Num = Nums[i];<br/>            While(num &gt; 0){<br/>                Digit = Math.max(digit, Num % 10);<br/>                Num /= 10;<br/>            }<br/>            If(digit &gt; Maxdigit){<br/>                Maxdigit = Digit;<br/>                Max = Nums[i];<br/>            }<br/>            Else If(digit == Maxdigit){<br/>                Max = Math.max(max, Nums[i]);<br/>            }<br/>        }<br/>        <br/>        Int Maxsum = 0;<br/>        For(int I = 0; I &lt; Nums.length; I++){<br/>            Int Digit = 0;<br/>            Int Num = Nums[i];<br/>            While(num &gt; 0){<br/>                Digit = Math.max(digit, Num % 10);<br/>                Num /= 10;<br/>            }<br/>            If(digit == Maxdigit){<br/>                Maxsum = Math.max(maxsum, Nums[i]);<br/>            }<br/>        }<br/>        <br/>        If(maxsum == 0){<br/>            Return -1;<br/>        }<br/>        <br/>        Int Sum = 0;<br/>        For(int I = 0; I &lt; Nums.length; I++){<br/>            If(nums[i] == Max){<br/>                Sum += Nums[i];<br/>            }<br/>            Else If(nums[i] == Maxsum){<br/>                Sum += Nums[i];<br/>            }<br/>        }<br/>        <br/>        Return Sum;<br/>    }<br/>}</td>
<td>Class Solution {<br/>    Public Int Maxsum(int[] Nums) {<br/>    Int Ans = -1;<br/>    Map&lt;integer,list&lt;integer&gt;&gt; Ump = New Hashmap&lt;&gt;();<br/>    For(int I = 0; I &lt; Nums.length; ++I){<br/>        Int T = Nums[i], Maxdigit = 0;<br/>        While(t != 0){ //Evaluate Max Digit In The Number<br/>            Maxdigit = Math.max(t%10, Maxdigit);<br/>            T = T/10;<br/>        }<br/>        If(!ump.containskey(maxdigit)) Ump.put(maxdigit, New Arraylist&lt;&gt;());<br/>        Ump.get(maxdigit).add(nums[i]); // Add The Number To The Map <br/>    }<br/>    For(map.entry&lt;integer, List&lt;integer&gt;&gt; Entry: Ump.entryset()){<br/>        Entry.getvalue().sort(comparator.reverseorder()); //To Find Max Two Number In Each Max Digit <br/>        If(entry.getvalue().size() &gt;= 2) Ans = Math.max(ans, Entry.getvalue().get(0) + Entry.getvalue().get(1)); //Sum Max Two Number And Take Max<br/>    }<br/>    Return Ans;<br/>    }<br/>}</td>
</tr>
<tr>
<td align="right">38</td>
<td align="right">1</td>
<td>Python</td>
<td>easy</td>
<td>Code Llama</td>
<td>IDE Extension</td>
<td>You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.<br/><br/>Return the maximum sum or -1 if no such pair exists.<br/><br/>Example 1:<br/><br/>Input: nums = [51,71,17,24,42]<br/>Output: 88<br/>Explanation: <br/>For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. <br/>For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.<br/>It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.<br/><br/>Example 2:<br/><br/>Input: nums = [1,2,3,4]<br/>Output: -1<br/>Explanation: No pair exists in nums with equal maximum digits.<br/><br/>Constraints:<br/><br/>2 &lt;= nums.length &lt;= 100<br/>1 &lt;= nums[i] &lt;= 10^4 </td>
<td>class Solution:<br/>    def maxSum(self, nums: List[int]) -&gt; int:<br/>&quot;&quot;&quot;You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.<br/><br/>Return the maximum sum or -1 if no such pair exists.<br/><br/>Example 1:<br/><br/>Input: nums = [51,71,17,24,42]<br/>Output: 88<br/>Explanation: <br/>For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. <br/>For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.<br/>It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.<br/><br/>Example 2:<br/><br/>Input: nums = [1,2,3,4]<br/>Output: -1<br/>Explanation: No pair exists in nums with equal maximum digits.<br/><br/>Constraints:<br/><br/>2 &lt;= nums.length &lt;= 100<br/>1 &lt;= nums[i] &lt;= 10^4&quot;&quot;&quot;</td>
<td>Class Solution:<br/>    Def Maxsum(self, Nums: List[int]) -&gt; Int:<br/>        For I In Range(len(nums)):<br/>            For J In Range(i+1, Len(nums)):<br/>                If Max(nums[i], Nums[j]) % 10 == Max(nums[i] // 10, Nums[j] // 10):<br/>                    Return Max(nums[i], Nums[j])<br/>        Return -1</td>
<td>Class Solution:<br/>    Def Maxsum(self, Nums: List[int]) -&gt; Int:<br/>        Max_by_digit = Defaultdict(int)<br/>        Max_sum = -1<br/><br/>        For Num In Nums:<br/>            Digit = Max(str(num))<br/><br/>            If Digit In Max_by_digit:<br/>                Max_sum = Max(max_sum, Max_by_digit[digit] + Num)<br/><br/>            Max_by_digit[digit] = Max(max_by_digit[digit], Num)<br/><br/>        Return Max_sum</td>
</tr>
<tr>
<td align="right">39</td>
<td align="right">1</td>
<td>C++</td>
<td>easy</td>
<td>Code Llama</td>
<td>IDE Extension</td>
<td>You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.<br/><br/>Return the maximum sum or -1 if no such pair exists.<br/><br/>Example 1:<br/><br/>Input: nums = [51,71,17,24,42]<br/>Output: 88<br/>Explanation: <br/>For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. <br/>For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.<br/>It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.<br/><br/>Example 2:<br/><br/>Input: nums = [1,2,3,4]<br/>Output: -1<br/>Explanation: No pair exists in nums with equal maximum digits.<br/><br/>Constraints:<br/><br/>2 &lt;= nums.length &lt;= 100<br/>1 &lt;= nums[i] &lt;= 10^4 </td>
<td>class Solution {<br/>public:<br/>    int maxSum(vector&lt;int&gt;&amp; nums) {<br/>/*You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.<br/><br/>Return the maximum sum or -1 if no such pair exists.<br/><br/>Example 1:<br/><br/>Input: nums = [51,71,17,24,42]<br/>Output: 88<br/>Explanation: <br/>For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. <br/>For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.<br/>It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.<br/><br/>Example 2:<br/><br/>Input: nums = [1,2,3,4]<br/>Output: -1<br/>Explanation: No pair exists in nums with equal maximum digits.<br/><br/>Constraints:<br/><br/>2 &lt;= nums.length &lt;= 100<br/>1 &lt;= nums[i] &lt;= 10^4*/</td>
<td>Class Solution {<br/>Public:<br/>    Int Maxsum(vector&lt;int&gt;&amp; Nums) {<br/>       Int N = Nums.size();<br/>        Int Max_digit = 0;<br/>        For(int I = 0; I &lt; N; I++){<br/>            Int Digit = 0;<br/>            Int Num = Nums[i];<br/>            While(num){<br/>                Digit = Max(digit, Num % 10);<br/>                Num /= 10;<br/>            }<br/>            Max_digit = Max(max_digit, Digit);<br/>        }<br/>        <br/>        Int Max_sum = -1;<br/>        For(int I = 0; I &lt; N; I++){<br/>            For(int J = I + 1; J &lt; N; J++){<br/>                Int Digit = 0;<br/>                Int Num = Nums[i] + Nums[j];<br/>                While(num){<br/>                    Digit = Max(digit, Num % 10);<br/>                    Num /= 10;<br/>                }<br/>                If(digit == Max_digit){<br/>                    Max_sum = Max(max_sum, Nums[i] + Nums[j]);<br/>                }<br/>            }<br/>        }<br/>        <br/>        Return Max_sum;<br/>    }<br/>};</td>
<td>Class Solution {<br/>    Public:<br/>        Int Maxsum(vector&lt;int&gt;&amp; Nums) {<br/>        Int Res = -1, Max_num[10] = {};<br/>        For (Auto Num : Nums) {<br/>            Int Max_d = 0;<br/>            For (Int V = Num; V; V /= 10)<br/>                Max_d = Max(max_d, V % 10);<br/>            If (Max_num[max_d])<br/>                Res = Max(res, Max_num[max_d] + Num);<br/>            Max_num[max_d] = Max(max_num[max_d], Num);<br/>        }<br/>        Return Res;<br/>    }<br/>};</td>
</tr>
<tr>
<td align="right">40</td>
<td align="right">2</td>
<td>Java</td>
<td>easy</td>
<td>Code Llama</td>
<td>IDE Extension</td>
<td>Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.<br/><br/>You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.<br/><br/>Return the final string that will be present on your laptop screen.<br/><br/>Example 1:<br/><br/>Input: s = &quot;string&quot;<br/>Output: &quot;rtsng&quot;<br/>Explanation: <br/>After typing first character, the text on the screen is &quot;s&quot;.<br/>After the second character, the text is &quot;st&quot;. <br/>After the third character, the text is &quot;str&quot;.<br/>Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.<br/>After the fifth character, the text is &quot;rtsn&quot;. <br/>After the sixth character, the text is &quot;rtsng&quot;. <br/>Therefore, we return &quot;rtsng&quot;.<br/><br/>Example 2:<br/><br/>Input: s = &quot;poiinter&quot;<br/>Output: &quot;ponter&quot;<br/>Explanation: <br/>After the first character, the text on the screen is &quot;p&quot;.<br/>After the second character, the text is &quot;po&quot;. <br/>Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. <br/>Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.<br/>After the fifth character, the text is &quot;pon&quot;.<br/>After the sixth character, the text is &quot;pont&quot;. <br/>After the seventh character, the text is &quot;ponte&quot;. <br/>After the eighth character, the text is &quot;ponter&quot;. <br/>Therefore, we return &quot;ponter&quot;.<br/> <br/>Constraints:<br/><br/>1 &lt;= s.length &lt;= 100<br/>s consists of lowercase English letters.<br/>s[0] != &#39;i&#39;</td>
<td>class Solution {<br/>    public String finalString(String s) {<br/>/*Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.<br/><br/>You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.<br/><br/>Return the final string that will be present on your laptop screen.<br/><br/>Example 1:<br/><br/>Input: s = &quot;string&quot;<br/>Output: &quot;rtsng&quot;<br/>Explanation: <br/>After typing first character, the text on the screen is &quot;s&quot;.<br/>After the second character, the text is &quot;st&quot;. <br/>After the third character, the text is &quot;str&quot;.<br/>Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.<br/>After the fifth character, the text is &quot;rtsn&quot;. <br/>After the sixth character, the text is &quot;rtsng&quot;. <br/>Therefore, we return &quot;rtsng&quot;.<br/><br/>Example 2:<br/><br/>Input: s = &quot;poiinter&quot;<br/>Output: &quot;ponter&quot;<br/>Explanation: <br/>After the first character, the text on the screen is &quot;p&quot;.<br/>After the second character, the text is &quot;po&quot;. <br/>Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. <br/>Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.<br/>After the fifth character, the text is &quot;pon&quot;.<br/>After the sixth character, the text is &quot;pont&quot;. <br/>After the seventh character, the text is &quot;ponte&quot;. <br/>After the eighth character, the text is &quot;ponter&quot;. <br/>Therefore, we return &quot;ponter&quot;.<br/> <br/>Constraints:<br/><br/>1 &lt;= s.length &lt;= 100<br/>s consists of lowercase English letters.<br/>s[0] != &#39;i&#39;*/</td>
<td>Class Solution {<br/>    Public String Finalstring(string S) {<br/>        Stringbuilder Sb = New Stringbuilder();<br/>        For(int I = 0; I &lt; S.length(); I++){<br/>            If(s.charat(i) == &#39;I&#39;){<br/>                Sb.reverse();<br/>            }<br/>            Else{<br/>                Sb.append(s.charat(i));<br/>            }<br/>        }<br/>        Return Sb.tostring();<br/>    }<br/>}</td>
<td>Class Solution {<br/>    Public String Finalstring(string S) {<br/>        Stringbuilder Nm=new Stringbuilder();<br/>        For(char C:s.tochararray())<br/>        {<br/>            If(c==&#39;i&#39;)<br/>            {<br/>                Nm.reverse();<br/>            }<br/>            Else<br/>            {<br/>                Nm.append(c);<br/>            }<br/>        }<br/>        Return Nm.tostring();<br/>    }<br/>}</td>
</tr>
<tr>
<td align="right">41</td>
<td align="right">2</td>
<td>Python</td>
<td>easy</td>
<td>Code Llama</td>
<td>IDE Extension</td>
<td>Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.<br/><br/>You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.<br/><br/>Return the final string that will be present on your laptop screen.<br/><br/>Example 1:<br/><br/>Input: s = &quot;string&quot;<br/>Output: &quot;rtsng&quot;<br/>Explanation: <br/>After typing first character, the text on the screen is &quot;s&quot;.<br/>After the second character, the text is &quot;st&quot;. <br/>After the third character, the text is &quot;str&quot;.<br/>Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.<br/>After the fifth character, the text is &quot;rtsn&quot;. <br/>After the sixth character, the text is &quot;rtsng&quot;. <br/>Therefore, we return &quot;rtsng&quot;.<br/><br/>Example 2:<br/><br/>Input: s = &quot;poiinter&quot;<br/>Output: &quot;ponter&quot;<br/>Explanation: <br/>After the first character, the text on the screen is &quot;p&quot;.<br/>After the second character, the text is &quot;po&quot;. <br/>Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. <br/>Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.<br/>After the fifth character, the text is &quot;pon&quot;.<br/>After the sixth character, the text is &quot;pont&quot;. <br/>After the seventh character, the text is &quot;ponte&quot;. <br/>After the eighth character, the text is &quot;ponter&quot;. <br/>Therefore, we return &quot;ponter&quot;.<br/> <br/>Constraints:<br/><br/>1 &lt;= s.length &lt;= 100<br/>s consists of lowercase English letters.<br/>s[0] != &#39;i&#39;</td>
<td>class Solution:<br/>    def finalString(self, s: str) -&gt; str:<br/>&quot;&quot;&quot;Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.<br/><br/>You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.<br/><br/>Return the final string that will be present on your laptop screen.<br/><br/>Example 1:<br/><br/>Input: s = &quot;string&quot;<br/>Output: &quot;rtsng&quot;<br/>Explanation: <br/>After typing first character, the text on the screen is &quot;s&quot;.<br/>After the second character, the text is &quot;st&quot;. <br/>After the third character, the text is &quot;str&quot;.<br/>Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.<br/>After the fifth character, the text is &quot;rtsn&quot;. <br/>After the sixth character, the text is &quot;rtsng&quot;. <br/>Therefore, we return &quot;rtsng&quot;.<br/><br/>Example 2:<br/><br/>Input: s = &quot;poiinter&quot;<br/>Output: &quot;ponter&quot;<br/>Explanation: <br/>After the first character, the text on the screen is &quot;p&quot;.<br/>After the second character, the text is &quot;po&quot;. <br/>Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. <br/>Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.<br/>After the fifth character, the text is &quot;pon&quot;.<br/>After the sixth character, the text is &quot;pont&quot;. <br/>After the seventh character, the text is &quot;ponte&quot;. <br/>After the eighth character, the text is &quot;ponter&quot;. <br/>Therefore, we return &quot;ponter&quot;.<br/> <br/>Constraints:<br/><br/>1 &lt;= s.length &lt;= 100<br/>s consists of lowercase English letters.<br/>s[0] != &#39;i&#39;&quot;&quot;&quot;</td>
<td>Class Solution:<br/>    Def Finalstring(self, S: Str) -&gt; Str:<br/>        Res = &quot;&quot;<br/>        For I In S:<br/>            If I == &quot;I&quot;:<br/>                Res = Res[::-1]<br/>            Else:<br/>                Res += I<br/>        Return Res</td>
<td>Class Solution:<br/>    Def Finalstring(self, S: Str) -&gt; Str:<br/>        While &quot;I&quot; In S:<br/>            Index=s.index(&quot;i&quot;)<br/><br/>            #First Half And Second Half<br/>            First=s[:index][::-1]<br/>            Second=s[index+1:]<br/><br/>            S=&quot;&quot;.join([first,second])<br/>        Return S</td>
</tr>
<tr>
<td align="right">42</td>
<td align="right">2</td>
<td>C++</td>
<td>easy</td>
<td>Code Llama</td>
<td>IDE Extension</td>
<td>Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.<br/><br/>You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.<br/><br/>Return the final string that will be present on your laptop screen.<br/><br/>Example 1:<br/><br/>Input: s = &quot;string&quot;<br/>Output: &quot;rtsng&quot;<br/>Explanation: <br/>After typing first character, the text on the screen is &quot;s&quot;.<br/>After the second character, the text is &quot;st&quot;. <br/>After the third character, the text is &quot;str&quot;.<br/>Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.<br/>After the fifth character, the text is &quot;rtsn&quot;. <br/>After the sixth character, the text is &quot;rtsng&quot;. <br/>Therefore, we return &quot;rtsng&quot;.<br/><br/>Example 2:<br/><br/>Input: s = &quot;poiinter&quot;<br/>Output: &quot;ponter&quot;<br/>Explanation: <br/>After the first character, the text on the screen is &quot;p&quot;.<br/>After the second character, the text is &quot;po&quot;. <br/>Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. <br/>Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.<br/>After the fifth character, the text is &quot;pon&quot;.<br/>After the sixth character, the text is &quot;pont&quot;. <br/>After the seventh character, the text is &quot;ponte&quot;. <br/>After the eighth character, the text is &quot;ponter&quot;. <br/>Therefore, we return &quot;ponter&quot;.<br/> <br/>Constraints:<br/><br/>1 &lt;= s.length &lt;= 100<br/>s consists of lowercase English letters.<br/>s[0] != &#39;i&#39;</td>
<td>class Solution {<br/>public:<br/>    string finalString(string s) {<br/>/*Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.<br/><br/>You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.<br/><br/>Return the final string that will be present on your laptop screen.<br/><br/>Example 1:<br/><br/>Input: s = &quot;string&quot;<br/>Output: &quot;rtsng&quot;<br/>Explanation: <br/>After typing first character, the text on the screen is &quot;s&quot;.<br/>After the second character, the text is &quot;st&quot;. <br/>After the third character, the text is &quot;str&quot;.<br/>Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.<br/>After the fifth character, the text is &quot;rtsn&quot;. <br/>After the sixth character, the text is &quot;rtsng&quot;. <br/>Therefore, we return &quot;rtsng&quot;.<br/><br/>Example 2:<br/><br/>Input: s = &quot;poiinter&quot;<br/>Output: &quot;ponter&quot;<br/>Explanation: <br/>After the first character, the text on the screen is &quot;p&quot;.<br/>After the second character, the text is &quot;po&quot;. <br/>Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. <br/>Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.<br/>After the fifth character, the text is &quot;pon&quot;.<br/>After the sixth character, the text is &quot;pont&quot;. <br/>After the seventh character, the text is &quot;ponte&quot;. <br/>After the eighth character, the text is &quot;ponter&quot;. <br/>Therefore, we return &quot;ponter&quot;.<br/> <br/>Constraints:<br/><br/>1 &lt;= s.length &lt;= 100<br/>s consists of lowercase English letters.<br/>s[0] != &#39;i&#39;*/</td>
<td>Class Solution {<br/>Public:<br/>    String Finalstring(string S) {<br/>        String Ans;<br/>        For(int I = 0; I &lt; S.length(); I++){<br/>            If(s[i] == &#39;I&#39;){<br/>                Reverse(ans.begin(), Ans.end());<br/>            }<br/>            Else{<br/>                Ans.push_back(s[i]);<br/>            }<br/>        }<br/>        Return Ans;<br/>    }<br/>};</td>
<td>Class Solution {<br/>Public:<br/>    String Finalstring(const String &amp;S) {<br/>        String A, B;<br/>        For (Char Ch : S)<br/>            If (Ch == &#39;I&#39;)<br/>                Swap(a, B);<br/>            Else<br/>                A += Ch;<br/>        Return String(rbegin(b), Rend(b)) + A;<br/>    }<br/>};</td>
</tr>
<tr>
<td align="right">43</td>
<td align="right">3</td>
<td>Java</td>
<td>medium</td>
<td>Code Llama</td>
<td>IDE Extension</td>
<td>You are given a 0-indexed integer array nums and an integer x.<br/><br/>Find the minimum absolute difference between two elements in the array that are at least x indices apart.<br/><br/>In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.<br/><br/>Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.<br/><br/>Example 1:<br/><br/>Input: nums = [4,3,2,4], x = 2<br/>Output: 0<br/>Explanation: We can select nums[0] = 4 and nums[3] = 4. <br/>They are at least 2 indices apart, and their absolute difference is the minimum, 0. <br/>It can be shown that 0 is the optimal answer.<br/><br/>Example 2:<br/><br/>Input: nums = [5,3,2,10,15], x = 1<br/>Output: 1<br/>Explanation: We can select nums[1] = 3 and nums[2] = 2.<br/>They are at least 1 index apart, and their absolute difference is the minimum, 1.<br/>It can be shown that 1 is the optimal answer.<br/><br/>Example 3:<br/><br/>Input: nums = [1,2,3,4], x = 3<br/>Output: 3<br/>Explanation: We can select nums[0] = 1 and nums[3] = 4.<br/>They are at least 3 indices apart, and their absolute difference is the minimum, 3.<br/>It can be shown that 3 is the optimal answer.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^9<br/>0 &lt;= x &lt; nums.length </td>
<td>class Solution {<br/>    public int minAbsoluteDifference(List&lt;Integer&gt; nums, int x) {<br/>/*You are given a 0-indexed integer array nums and an integer x.<br/><br/>Find the minimum absolute difference between two elements in the array that are at least x indices apart.<br/><br/>In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.<br/><br/>Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.<br/><br/>Example 1:<br/><br/>Input: nums = [4,3,2,4], x = 2<br/>Output: 0<br/>Explanation: We can select nums[0] = 4 and nums[3] = 4. <br/>They are at least 2 indices apart, and their absolute difference is the minimum, 0. <br/>It can be shown that 0 is the optimal answer.<br/><br/>Example 2:<br/><br/>Input: nums = [5,3,2,10,15], x = 1<br/>Output: 1<br/>Explanation: We can select nums[1] = 3 and nums[2] = 2.<br/>They are at least 1 index apart, and their absolute difference is the minimum, 1.<br/>It can be shown that 1 is the optimal answer.<br/><br/>Example 3:<br/><br/>Input: nums = [1,2,3,4], x = 3<br/>Output: 3<br/>Explanation: We can select nums[0] = 1 and nums[3] = 4.<br/>They are at least 3 indices apart, and their absolute difference is the minimum, 3.<br/>It can be shown that 3 is the optimal answer.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^9<br/>0 &lt;= x &lt; nums.length*/</td>
<td>Class Solution {<br/>    Public Int Minabsolutedifference(list&lt;integer&gt; Nums, Int X) {<br/>        Int Min = Integer.max_value;<br/>        Int N = Nums.size();<br/>        For(int I = 0; I &lt; N; I++){<br/>            For(int J = I + X; J &lt; N; J++){<br/>                Min = Math.min(min, Math.abs(nums.get(i) - Nums.get(j)));<br/>            }<br/>        }<br/>        Return Min;<br/>    }<br/>}</td>
<td>Class Solution {<br/>    Int Minabsolutedifference(list&lt;integer&gt; Nums, Int X) {<br/>        Int Ans = Integer.max_value;<br/>        Treeset&lt;integer&gt; S = New Treeset&lt;&gt;();<br/>        For(int I = X; I &lt; Nums.size(); ++I){<br/>            S.add(nums.get(i-x));<br/>            Integer High = S.ceiling(nums.get(i)), Low = S.floor(nums.get(i));<br/>            If(high != Null) Ans = Math.min(ans, Math.abs(nums.get(i) - High));<br/>            If(low != Null) Ans = Math.min(ans, Math.abs(nums.get(i) - Low));<br/>        }<br/>        Return Ans;<br/>    }<br/>}</td>
</tr>
<tr>
<td align="right">44</td>
<td align="right">3</td>
<td>Python</td>
<td>medium</td>
<td>Code Llama</td>
<td>IDE Extension</td>
<td>You are given a 0-indexed integer array nums and an integer x.<br/><br/>Find the minimum absolute difference between two elements in the array that are at least x indices apart.<br/><br/>In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.<br/><br/>Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.<br/><br/>Example 1:<br/><br/>Input: nums = [4,3,2,4], x = 2<br/>Output: 0<br/>Explanation: We can select nums[0] = 4 and nums[3] = 4. <br/>They are at least 2 indices apart, and their absolute difference is the minimum, 0. <br/>It can be shown that 0 is the optimal answer.<br/><br/>Example 2:<br/><br/>Input: nums = [5,3,2,10,15], x = 1<br/>Output: 1<br/>Explanation: We can select nums[1] = 3 and nums[2] = 2.<br/>They are at least 1 index apart, and their absolute difference is the minimum, 1.<br/>It can be shown that 1 is the optimal answer.<br/><br/>Example 3:<br/><br/>Input: nums = [1,2,3,4], x = 3<br/>Output: 3<br/>Explanation: We can select nums[0] = 1 and nums[3] = 4.<br/>They are at least 3 indices apart, and their absolute difference is the minimum, 3.<br/>It can be shown that 3 is the optimal answer.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^9<br/>0 &lt;= x &lt; nums.length </td>
<td>class Solution:<br/>    def minAbsoluteDifference(self, nums: List[int], x: int) -&gt; int:<br/>&quot;&quot;&quot;You are given a 0-indexed integer array nums and an integer x.<br/><br/>Find the minimum absolute difference between two elements in the array that are at least x indices apart.<br/><br/>In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.<br/><br/>Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.<br/><br/>Example 1:<br/><br/>Input: nums = [4,3,2,4], x = 2<br/>Output: 0<br/>Explanation: We can select nums[0] = 4 and nums[3] = 4. <br/>They are at least 2 indices apart, and their absolute difference is the minimum, 0. <br/>It can be shown that 0 is the optimal answer.<br/><br/>Example 2:<br/><br/>Input: nums = [5,3,2,10,15], x = 1<br/>Output: 1<br/>Explanation: We can select nums[1] = 3 and nums[2] = 2.<br/>They are at least 1 index apart, and their absolute difference is the minimum, 1.<br/>It can be shown that 1 is the optimal answer.<br/><br/>Example 3:<br/><br/>Input: nums = [1,2,3,4], x = 3<br/>Output: 3<br/>Explanation: We can select nums[0] = 1 and nums[3] = 4.<br/>They are at least 3 indices apart, and their absolute difference is the minimum, 3.<br/>It can be shown that 3 is the optimal answer.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^9<br/>0 &lt;= x &lt; nums.length&quot;&quot;&quot;</td>
<td>Class Solution:<br/>    Def Minabsolutedifference(self, Nums: List[int], X: Int) -&gt; Int:<br/>        Nums.sort()<br/>        Min_diff = Float(&#39;inf&#39;)<br/>        For I In Range(len(nums)):<br/>            If I + X &lt; Len(nums):<br/>                Min_diff = Min(min_diff, Abs(nums[i] - Nums[i + X]))<br/>        Return Min_diff</td>
<td>Class Solution:<br/>  Def Minabsolutedifference(self, Nums: List[int], X: Int) -&gt; Int:<br/>    If X == 0:<br/>      Return 0<br/><br/>    Arr, Best_dist = Sortedlist([]), Float(&#39;inf&#39;)<br/>    For I In Range(x, Len(nums)):<br/>      Arr.add(nums[i - X])<br/>      V = Nums[i]<br/><br/>      Pos = Arr.bisect_left(v)<br/>      If Pos &lt; Len(arr):<br/>        Best_dist = Min(best_dist, Abs(arr[pos] - V))<br/>      If Pos &gt; 0:<br/>        Best_dist = Min(best_dist, Abs(arr[pos - 1] - V))<br/>    <br/>    Return Best_dist</td>
</tr>
<tr>
<td align="right">45</td>
<td align="right">3</td>
<td>C++</td>
<td>medium</td>
<td>Code Llama</td>
<td>IDE Extension</td>
<td>You are given a 0-indexed integer array nums and an integer x.<br/><br/>Find the minimum absolute difference between two elements in the array that are at least x indices apart.<br/><br/>In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.<br/><br/>Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.<br/><br/>Example 1:<br/><br/>Input: nums = [4,3,2,4], x = 2<br/>Output: 0<br/>Explanation: We can select nums[0] = 4 and nums[3] = 4. <br/>They are at least 2 indices apart, and their absolute difference is the minimum, 0. <br/>It can be shown that 0 is the optimal answer.<br/><br/>Example 2:<br/><br/>Input: nums = [5,3,2,10,15], x = 1<br/>Output: 1<br/>Explanation: We can select nums[1] = 3 and nums[2] = 2.<br/>They are at least 1 index apart, and their absolute difference is the minimum, 1.<br/>It can be shown that 1 is the optimal answer.<br/><br/>Example 3:<br/><br/>Input: nums = [1,2,3,4], x = 3<br/>Output: 3<br/>Explanation: We can select nums[0] = 1 and nums[3] = 4.<br/>They are at least 3 indices apart, and their absolute difference is the minimum, 3.<br/>It can be shown that 3 is the optimal answer.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^9<br/>0 &lt;= x &lt; nums.length </td>
<td>class Solution {<br/>public:<br/>    int minAbsoluteDifference(vector&lt;int&gt;&amp; nums, int x) {<br/>/*You are given a 0-indexed integer array nums and an integer x.<br/><br/>Find the minimum absolute difference between two elements in the array that are at least x indices apart.<br/><br/>In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.<br/><br/>Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^9<br/>0 &lt;= x &lt; nums.length*/</td>
<td>Class Solution {<br/>Public:<br/>    Int Minabsolutedifference(vector&lt;int&gt;&amp; Nums, Int X) {<br/>        Int N=nums.size();<br/>        Int Min=int_max;<br/>        Int I=0;<br/>        Int J=0;<br/>        For(i=0;i&lt;n;i++){<br/>            For(j=i+1;j&lt;n;j++){<br/>                If(abs(nums[i]-nums[j])&lt;min &amp;&amp; Abs(i-j)&gt;=x){<br/>                    Min=abs(nums[i]-nums[j]);<br/>                }<br/>            }<br/>        }<br/>        Return Min;<br/>    }<br/>};</td>
<td>Class Solution {<br/>Public:<br/>    Int Minabsolutedifference(vector&lt;int&gt;&amp; Nums, Int X) {<br/>        Int Ans = Int_max;<br/>        Set&lt;int&gt; S;<br/>        For(int I = X; I &lt; Nums.size(); ++I){<br/>            S.insert(nums[i-x]);<br/>            Auto It = S.upper_bound(nums[i]);<br/>            If(it != S.end()) Ans = Min(ans, Abs(nums[i] - *It));<br/>            If(it != S.begin()) Ans = Min(ans, Abs(nums[i] - *Prev(it)));<br/>        }<br/>        Return Ans;<br/>    }<br/>};</td>
</tr>
<tr>
<td align="right">46</td>
<td align="right">4</td>
<td>Java</td>
<td>medium</td>
<td>Code Llama</td>
<td>IDE Extension</td>
<td>You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.<br/><br/>Return the head of the linked list after doubling it.<br/><br/>Example 1:<br/><br/>Input: head = [1,8,9]<br/>Output: [3,7,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.<br/><br/>Example 2:<br/><br/>Input: head = [9,9,9]<br/>Output: [1,9,9,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. <br/><br/>Constraints:<br/><br/>The number of nodes in the list is in the range [1, 10^4]<br/>0 &lt;= Node.val &lt;= 9<br/>The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself. </td>
<td>/*You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.<br/><br/>Return the head of the linked list after doubling it.<br/><br/>Example 1:<br/><br/>Input: head = [1,8,9]<br/>Output: [3,7,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.<br/><br/>Example 2:<br/><br/>Input: head = [9,9,9]<br/>Output: [1,9,9,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. <br/><br/>Constraints:<br/><br/>The number of nodes in the list is in the range [1, 10^4]<br/>0 &lt;= Node.val &lt;= 9<br/>The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.*/<br/>class Solution {<br/>    public ListNode doubleIt(ListNode head) {</td>
<td>Class Solution {<br/>    Public Listnode Doubleit(listnode Head) {<br/>        Listnode Temp = Head;<br/>        Listnode Prev = Null;<br/>        While(temp!=null){<br/>            Int Val = Temp.val;<br/>            Temp.val = Val*2;<br/>            If(temp.val&gt;9){<br/>                Temp.val = Temp.val%10;<br/>                If(prev!=null){<br/>                    Prev.val+=1;<br/>                }<br/>            }<br/>            Prev = Temp;<br/>            Temp = Temp.next;<br/>        }<br/>        Return Head;<br/>    }<br/>}</td>
<td>Class Solution {<br/>    Public Listnode Doubleit(listnode Head) {<br/>        If (Head.val &gt; 4)<br/>            Head = New Listnode(0, Head);<br/>        For(listnode Node = Head; Node != Null; Node = Node.next) {<br/>            Node.val = (Node.val * 2) % 10;<br/>            If (Node.next != Null &amp;&amp; Node.next.val &gt; 4)<br/>                Node.val++;<br/>        }<br/>        Return Head;<br/>    }<br/>}</td>
</tr>
<tr>
<td align="right">47</td>
<td align="right">4</td>
<td>Python</td>
<td>medium</td>
<td>Code Llama</td>
<td>IDE Extension</td>
<td>You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.<br/><br/>Return the head of the linked list after doubling it.<br/><br/>Example 1:<br/><br/>Input: head = [1,8,9]<br/>Output: [3,7,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.<br/><br/>Example 2:<br/><br/>Input: head = [9,9,9]<br/>Output: [1,9,9,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. <br/><br/>Constraints:<br/><br/>The number of nodes in the list is in the range [1, 10^4]<br/>0 &lt;= Node.val &lt;= 9<br/>The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself. </td>
<td>#You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.<br/>#<br/>#Return the head of the linked list after doubling it.<br/>#<br/>#Example 1:<br/>#<br/>#Input: head = [1,8,9]<br/>#Output: [3,7,8]<br/>#Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.<br/>#<br/>#Example 2:<br/>#<br/>#Input: head = [9,9,9]<br/>#Output: [1,9,9,8]<br/>#Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. <br/>#<br/>#Constraints:<br/>#<br/>#The number of nodes in the list is in the range [1, 10^4]<br/>#0 &lt;= Node.val &lt;= 9<br/>#The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.<br/>class Solution:<br/>    def doubleIt(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:</td>
<td>Class Solution:<br/>    Def Doubleit(self, Head: Optional[listnode]) -&gt; Optional[listnode]:<br/>        If Head Is None:<br/>            Return None<br/>        <br/>        Head.val = Head.val * 2<br/>        <br/>        If Head.next Is None:<br/>            Return Head<br/>        <br/>        Head.next = Self.doubleit(head.next)<br/>        <br/>        If Head.val &gt; 9:<br/>            Head.val = Head.val - 10<br/>            Head.next.val = Head.next.val + 1<br/>            <br/>        Return Head</td>
<td>Class Solution:<br/>    Def Doubleit(self, Head: Optional[listnode]) -&gt; Optional[listnode]:<br/>        If Head.val &gt; 4:<br/>            Head = Listnode(0, Head)<br/>        Node = Head<br/>        While Node:<br/>            Node.val = (Node.val * 2) % 10<br/>            If Node.next And Node.next.val &gt; 4:<br/>                Node.val += 1<br/>            Node = Node.next<br/>        Return Head</td>
</tr>
<tr>
<td align="right">48</td>
<td align="right">4</td>
<td>C++</td>
<td>medium</td>
<td>Code Llama</td>
<td>IDE Extension</td>
<td>You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.<br/><br/>Return the head of the linked list after doubling it.<br/><br/>Example 1:<br/><br/>Input: head = [1,8,9]<br/>Output: [3,7,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.<br/><br/>Example 2:<br/><br/>Input: head = [9,9,9]<br/>Output: [1,9,9,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. <br/><br/>Constraints:<br/><br/>The number of nodes in the list is in the range [1, 10^4]<br/>0 &lt;= Node.val &lt;= 9<br/>The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself. </td>
<td>/*You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.<br/><br/>Return the head of the linked list after doubling it.<br/><br/>Example 1:<br/><br/>Input: head = [1,8,9]<br/>Output: [3,7,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.<br/><br/>Example 2:<br/><br/>Input: head = [9,9,9]<br/>Output: [1,9,9,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. <br/><br/>Constraints:<br/><br/>The number of nodes in the list is in the range [1, 10^4]<br/>0 &lt;= Node.val &lt;= 9<br/>The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.*/<br/>class Solution {<br/>public:<br/>    ListNode* doubleIt(ListNode* head) {</td>
<td>Class Solution {<br/>Public:<br/>    Listnode* Doubleit(listnode* Head) {<br/>        Listnode* Temp = Head;<br/>         Listnode* Temp2 = Head;<br/>         While(temp-&gt;next!=null){<br/>             Temp2 = Temp2-&gt;next;<br/>             Temp = Temp-&gt;next;<br/>         }<br/>         Temp2-&gt;next = Head;<br/>         Temp = Temp2;<br/>         While(temp-&gt;next!=null){<br/>             Temp-&gt;val = Temp-&gt;val*2;<br/>             If(temp-&gt;val&gt;9){<br/>                 Temp-&gt;val = Temp-&gt;val%10;<br/>                 Temp-&gt;next-&gt;val = Temp-&gt;next-&gt;val+1;<br/>             }<br/>             Temp = Temp-&gt;next;<br/>         }<br/>         If(temp-&gt;val&gt;9){<br/>             Temp-&gt;val = Temp-&gt;val%10;<br/>             Temp-&gt;next = New Listnode(1);<br/>         }<br/>         Return Head;<br/>    }<br/>};</td>
<td>Class Solution {<br/>Public:<br/>    Listnode* Doubleit(listnode* Head) {<br/>        If (Head-&gt;val &gt; 4)<br/>            Head = New Listnode(0, Head);<br/>        For(listnode* Node = Head; Node; Node = Node-&gt;next) {<br/>            Node-&gt;val = (Node-&gt;val * 2) % 10;<br/>            If (Node-&gt;next &amp;&amp; Node-&gt;next-&gt;val &gt; 4)<br/>                Node-&gt;val++;<br/>        }<br/>        Return Head;<br/>    }<br/>};</td>
</tr>
<tr>
<td align="right">49</td>
<td align="right">5</td>
<td>Java</td>
<td>hard</td>
<td>Code Llama</td>
<td>IDE Extension</td>
<td>You are given an array nums of n positive integers and an integer k.<br/><br/>Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:<br/><br/>Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.<br/>Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.<br/>Multiply your score by x.<br/>Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.<br/><br/>The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.<br/><br/>Return the maximum possible score after applying at most k operations.<br/><br/>Since the answer may be large, return it modulo 10^9 + 7.<br/><br/>Example 1:<br/><br/>Input: nums = [8,3,9,3,8], k = 2<br/>Output: 81<br/>Explanation: To get a score of 81, we can apply the following operations:<br/>- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.<br/>It can be proven that 81 is the highest score one can obtain.<br/><br/>Example 2:<br/><br/>Input: nums = [19,12,14,6,10,18], k = 3<br/>Output: 4788<br/>Explanation: To get a score of 4788, we can apply the following operations: <br/>- Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.<br/>- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.<br/>It can be proven that 4788 is the highest score one can obtain.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length == n &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^5<br/>1 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9) </td>
<td>/*You are given an array nums of n positive integers and an integer k.<br/><br/>Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:<br/><br/>Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.<br/>Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.<br/>Multiply your score by x.<br/>Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.<br/><br/>The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.<br/><br/>Return the maximum possible score after applying at most k operations.<br/><br/>Since the answer may be large, return it modulo 10^9 + 7.<br/><br/>Example 1:<br/><br/>Input: nums = [8,3,9,3,8], k = 2<br/>Output: 81<br/>Explanation: To get a score of 81, we can apply the following operations:<br/>- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.<br/>It can be proven that 81 is the highest score one can obtain.<br/><br/>Example 2:<br/><br/>Input: nums = [19,12,14,6,10,18], k = 3<br/>Output: 4788<br/>Explanation: To get a score of 4788, we can apply the following operations: <br/>- Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.<br/>- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.<br/>It can be proven that 4788 is the highest score one can obtain.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length == n &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^5<br/>1 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9)*/<br/>class Solution {<br/>    public int maximumScore(List&lt;Integer&gt; nums, int k) {</td>
<td>Class Solution {<br/>    Public Int Maximumscore(list&lt;integer&gt; Nums, Int K) {<br/>        Int N = Nums.size();<br/>        Int[][] Dp = New Int[n][k + 1];<br/>        For(int I = 0; I &lt; N; I++)<br/>            Arrays.fill(dp[i], -1);<br/>        Return Dfs(nums, 0, K, Dp);<br/>    }<br/>    Public Int Dfs(list&lt;integer&gt; Nums, Int I, Int K, Int[][] Dp){<br/>        If(i == Nums.size())<br/>            Return 1;<br/>        If(k == 0)<br/>            Return 0;<br/>        If(dp[i][k] != -1)<br/>            Return Dp[i][k];<br/>        Int Ans = 0;<br/>        For(int J = I; J &lt; Nums.size(); J++){<br/>            Ans = Math.max(ans, Nums.get(j) * Dfs(nums, J + 1, K - 1, Dp));<br/>        }<br/>        Return Dp[i][k] = Ans;<br/>    }<br/>}</td>
<td>Class Solution {<br/>    Static Final Int Mod = 1000000007;<br/><br/>    Public Int Maximumscore(list&lt;integer&gt; Nums, Int K) {<br/>        Int N = Nums.size();<br/><br/>        Int Upper = Collections.max(nums) + 1;<br/><br/>        Boolean[] Prime = New Boolean[upper];<br/>        Int[] Primescore = New Int[upper];<br/>        Arrays.fill(prime, True);<br/>        Prime[0] = Prime[1] = False;<br/>        For (Int I = 2; I &lt; Upper; I++) {<br/>            If (Prime[i]) {<br/>                For (Int J = I; J &lt; Upper; J += I) {<br/>                    Primescore[j]++;<br/>                    Prime[j] = False;<br/>                }<br/>            }<br/>        }<br/><br/>        Int[] Nextgreaterelement = New Int[n];<br/>        Arrays.fill(nextgreaterelement, N);<br/>        Stack&lt;integer&gt; S = New Stack&lt;&gt;();<br/>        For (Int I = N - 1; I &gt;= 0; I--) {<br/>            While (!S.empty() &amp;&amp; Primescore[nums.get(i)] &gt;= Primescore[nums.get(s.peek())]) {<br/>                S.pop();<br/>            }<br/>            Nextgreaterelement[i] = S.empty() ? N : S.peek();<br/>            S.push(i);<br/>        }<br/><br/>        Int[] Prevgreaterorequalelement = New Int[n];<br/>        Arrays.fill(prevgreaterorequalelement, -1);<br/>        S = New Stack&lt;&gt;();<br/>        For (Int I = 0; I &lt; N; I++) {<br/>            While (!S.empty() &amp;&amp; Primescore[nums.get(i)] &gt; Primescore[nums.get(s.peek())]) {<br/>                S.pop();<br/>            }<br/>            Prevgreaterorequalelement[i] = S.empty() ? -1 : S.peek();<br/>            S.push(i);<br/>        }<br/><br/>        Int Res = 1;<br/>        Int[][] Tuples = New Int[n][2];<br/>        For (Int I = 0; I &lt; N; I++) {<br/>            Tuples[i][0] = Nums.get(i);<br/>            Tuples[i][1] = I;<br/>        }<br/>        Arrays.sort(tuples, New Comparator&lt;int[]&gt;() {<br/>            Public Int Compare(int[] A, Int[] B) {<br/>                Return B[0] - A[0];<br/>            }<br/>        });<br/>        For (Int I = 0; I &lt; N; I++) {<br/>            Int Num = Tuples[i][0];<br/>            Int Idx = Tuples[i][1];<br/>            Int Operations = Math.min((idx - Prevgreaterorequalelement[idx]) * (Nextgreaterelement[idx] - Idx), K);<br/>            Res = (Int)((1l * Res * Pow(num, Operations)) % Mod);<br/>            K -= Operations;<br/>            If (K == 0) {<br/>                Return Res;<br/>            }<br/>        }<br/><br/>        Return Res;<br/>    }<br/><br/>    Public Int Pow(int X, Int N) {<br/>        Int Res = 1;<br/>        While (N &gt; 0) {<br/>            If (N % 2 == 1) {<br/>                Res = (Int)((1l * Res * X) % Mod);<br/>            }<br/>            X = (Int)((1l * X * X) % Mod);<br/>            N /= 2;<br/>        }<br/>        Return Res;<br/>    }<br/>}</td>
</tr>
<tr>
<td align="right">50</td>
<td align="right">5</td>
<td>Python</td>
<td>hard</td>
<td>Code Llama</td>
<td>IDE Extension</td>
<td>You are given an array nums of n positive integers and an integer k.<br/><br/>Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:<br/><br/>Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.<br/>Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.<br/>Multiply your score by x.<br/>Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.<br/><br/>The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.<br/><br/>Return the maximum possible score after applying at most k operations.<br/><br/>Since the answer may be large, return it modulo 10^9 + 7.<br/><br/>Example 1:<br/><br/>Input: nums = [8,3,9,3,8], k = 2<br/>Output: 81<br/>Explanation: To get a score of 81, we can apply the following operations:<br/>- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.<br/>It can be proven that 81 is the highest score one can obtain.<br/><br/>Example 2:<br/><br/>Input: nums = [19,12,14,6,10,18], k = 3<br/>Output: 4788<br/>Explanation: To get a score of 4788, we can apply the following operations: <br/>- Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.<br/>- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.<br/>It can be proven that 4788 is the highest score one can obtain.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length == n &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^5<br/>1 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9) </td>
<td>&quot;&quot;&quot;You are given an array nums of n positive integers and an integer k.<br/><br/>Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:<br/><br/>Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.<br/>Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.<br/>Multiply your score by x.<br/>Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.<br/><br/>The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.<br/><br/>Return the maximum possible score after applying at most k operations.<br/><br/>Since the answer may be large, return it modulo 10^9 + 7.<br/><br/>Example 1:<br/><br/>Input: nums = [8,3,9,3,8], k = 2<br/>Output: 81<br/>Explanation: To get a score of 81, we can apply the following operations:<br/>- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.<br/>It can be proven that 81 is the highest score one can obtain.<br/><br/>Example 2:<br/><br/>Input: nums = [19,12,14,6,10,18], k = 3<br/>Output: 4788<br/>Explanation: To get a score of 4788, we can apply the following operations: <br/>- Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.<br/>- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.<br/>It can be proven that 4788 is the highest score one can obtain.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length == n &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^5<br/>1 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9)&quot;&quot;&quot;<br/>class Solution:<br/>    def maximumScore(self, nums: List[int], k: int) -&gt; int:</td>
<td>Class Solution:<br/>    Def Maximumscore(self, Nums: List[int], K: Int) -&gt; Int:<br/>        Def Prime_score(num):<br/>            Prime_factors = Set()<br/>            While Num &gt; 1:<br/>                For I In Range(2, Num + 1):<br/>                    If Num % I == 0:<br/>                        Prime_factors.add(i)<br/>                        Num //= I<br/>                        Break<br/>            Return Len(prime_factors)<br/>        <br/>        N = Len(nums)<br/>        Dp = [[0] * N For _ In Range(k + 1)]<br/>        Dp[0][0] = 1<br/>        For I In Range(1, K + 1):<br/>            For J In Range(1, N):<br/>                For K In Range(j):<br/>                    If Prime_score(nums[k]) &gt; Prime_score(nums[j]):<br/>                        Dp[i][j] = Max(dp[i][j], Dp[i - 1][k] * Nums[j])<br/>                    Else:<br/>                        Dp[i][j] = Max(dp[i][j], Dp[i][k] * Nums[j])<br/>        Return Dp[k][n - 1] % (10 ** 9 + 7)</td>
<td>Class Solution: <br/>    Mod = 1000000007<br/><br/>    Def Maximumscore(self, Nums: List[int], K: Int) -&gt; Int:<br/>        N = Len(nums)<br/><br/>        Upper = Max(nums) + 1<br/><br/>        Prime = [True]*upper<br/>        Prime[0] = Prime[1] = False<br/>        Primescore = [0]*upper<br/>        For I In Range(2, Upper):<br/>            If Prime[i]:<br/>                For J In Range(i, Upper, I):<br/>                    Primescore[j] += 1<br/>                    Prime[j] = False<br/><br/>        Nextgreaterelement = [N]*n<br/>        S = []<br/>        For I In Range(n - 1, -1, -1):<br/>            While S And Primescore[nums[i]] &gt;= Primescore[nums[s[-1]]]:<br/>                S.pop()<br/>            Nextgreaterelement[i] = S[-1] If S Else N<br/>            S.append(i)<br/><br/>        Prevgreaterorequalelement = [-1]*n<br/>        S = []<br/>        For I In Range(n):<br/>            While S And Primescore[nums[i]] &gt; Primescore[nums[s[-1]]]:<br/>                S.pop()<br/>            Prevgreaterorequalelement[i] = S[-1] If S Else -1<br/>            S.append(i)<br/><br/>        Res = 1<br/>        Tuples = [[Nums[i], I] For I In Range(n)]<br/>        Tuples.sort(reverse=true)<br/>        For Num, Idx In Tuples:<br/>            Operations = Min((idx - Prevgreaterorequalelement[idx]) * (Nextgreaterelement[idx] - Idx), K)<br/>            Res = (Res * Self.pow(num, Operations)) % Self.mod<br/>            K -= Operations<br/>            If K == 0:<br/>                Return Res<br/><br/>        Return Res<br/><br/>    Def Pow(self, X: Int, N: Int) -&gt; Int:<br/>        Res = 1<br/>        While N &gt; 0:<br/>            If N % 2 == 1:<br/>                Res = (Res * X) % Self.mod<br/>            X = (X * X) % Self.mod<br/>            N //= 2<br/>        Return Res</td>
</tr>
<tr>
<td align="right">51</td>
<td align="right">5</td>
<td>C++</td>
<td>hard</td>
<td>Code Llama</td>
<td>IDE Extension</td>
<td>You are given an array nums of n positive integers and an integer k.<br/><br/>Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:<br/><br/>Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.<br/>Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.<br/>Multiply your score by x.<br/>Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.<br/><br/>The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.<br/><br/>Return the maximum possible score after applying at most k operations.<br/><br/>Since the answer may be large, return it modulo 10^9 + 7.<br/><br/>Example 1:<br/><br/>Input: nums = [8,3,9,3,8], k = 2<br/>Output: 81<br/>Explanation: To get a score of 81, we can apply the following operations:<br/>- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.<br/>It can be proven that 81 is the highest score one can obtain.<br/><br/>Example 2:<br/><br/>Input: nums = [19,12,14,6,10,18], k = 3<br/>Output: 4788<br/>Explanation: To get a score of 4788, we can apply the following operations: <br/>- Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.<br/>- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.<br/>It can be proven that 4788 is the highest score one can obtain.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length == n &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^5<br/>1 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9) </td>
<td>class Solution {<br/>public:<br/>    int maximumScore(vector&lt;int&gt;&amp; nums, int k) {<br/>/*You are given an array nums of n positive integers and an integer k.<br/><br/>Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:<br/><br/>Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.<br/>Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.<br/>Multiply your score by x.<br/>Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.<br/><br/>The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.<br/><br/>Return the maximum possible score after applying at most k operations.<br/><br/>Since the answer may be large, return it modulo 10^9 + 7.<br/><br/>Example 1:<br/><br/>Input: nums = [8,3,9,3,8], k = 2<br/>Output: 81<br/>Explanation: To get a score of 81, we can apply the following operations:<br/>- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.<br/>It can be proven that 81 is the highest score one can obtain.<br/><br/>Example 2:<br/><br/>Input: nums = [19,12,14,6,10,18], k = 3<br/>Output: 4788<br/>Explanation: To get a score of 4788, we can apply the following operations: <br/>- Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.<br/>- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.<br/>It can be proven that 4788 is the highest score one can obtain.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length == n &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^5<br/>1 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9)*/</td>
<td>Class Solution {<br/>Public:<br/>    Int Maximumscore(vector&lt;int&gt;&amp; Nums, Int K) { <br/>       Int N = Nums.size();<br/>        Vector&lt;int&gt; Primes;<br/>        For(int I = 2; I &lt;= N; I++){<br/>            Bool Isprime = True;<br/>            For(int J = 2; J &lt;= Sqrt(i); J++){<br/>                If(i % J == 0){<br/>                    Isprime = False;<br/>                    Break;<br/>                }<br/>            }<br/>            If(isprime){<br/>                Primes.push_back(i);<br/>            }<br/>        }<br/>        Vector&lt;int&gt; Dp(n + 1, 0);<br/>        Dp[0] = 1;<br/>        For(int I = 1; I &lt;= N; I++){<br/>            For(int J = 0; J &lt; Primes.size(); J++){<br/>                If(primes[j] &lt;= Nums[i - 1]){<br/>                    Dp[i] = (Dp[i] + Dp[i - 1]) % Mod;<br/>                }<br/>            }<br/>        }<br/>        Int Ans = 0;<br/>        For(int I = 0; I &lt;= N; I++){<br/>            For(int J = 0; J &lt;= N; J++){<br/>                If(i + J &lt;= N){<br/>                    Ans = (Ans + Dp[i] * Dp[n - I - J] % Mod) % Mod;<br/>                }<br/>            }<br/>        }<br/>        Return Ans;<br/>    }<br/>    <br/>    Int Mod = 1e9 + 7;<br/>};</td>
<td>Class Solution {<br/>Public:<br/>    Const Int Mod = 1000000007;<br/><br/>    Int Maximumscore(vector&lt;int&gt;&amp; Nums, Int K) {<br/>        Int N = Nums.size();<br/><br/>        Int Upper = *Max_element(nums.begin(), Nums.end()) + 1;<br/><br/>        Vector&lt;bool&gt; Prime(upper, True);<br/>        Prime[0] = Prime[1] = False;<br/>        Vector&lt;int&gt; Primescore(upper, 0);<br/>        For (Int I = 2; I &lt; Upper; I++) {<br/>            If (Prime[i]) {<br/>                For (Int J = I; J &lt; Upper; J += I) {<br/>                    Primescore[j]++;<br/>                    Prime[j] = False;<br/>                }<br/>            }<br/>        }<br/><br/>        Vector&lt;int&gt; Nextgreaterelement(n, N);<br/>        Stack&lt;int&gt; S;<br/>        For (Int I = N - 1; I &gt;= 0; I--) {<br/>            While (!S.empty() &amp;&amp; Primescore[nums[i]] &gt;= Primescore[nums[s.top()]]) {<br/>                S.pop();<br/>            }<br/>            Nextgreaterelement[i] = S.empty() ? N : S.top();<br/>            S.push(i);<br/>        }<br/><br/>        Vector&lt;int&gt; Prevgreaterorequalelement(n, -1);<br/>        S = Stack&lt;int&gt;();<br/>        For (Int I = 0; I &lt; N; I++) {<br/>            While (!S.empty() &amp;&amp; Primescore[nums[i]] &gt; Primescore[nums[s.top()]]) {<br/>                S.pop();<br/>            }<br/>            Prevgreaterorequalelement[i] = S.empty() ? -1 : S.top();<br/>            S.push(i);<br/>        }<br/><br/>        Int Res = 1;<br/>        Vector&lt;pair&lt;int, Int&gt;&gt; Tuples(n);<br/>        For (Int I = 0; I &lt; N; I++) {<br/>            Tuples[i].first = Nums[i];<br/>            Tuples[i].second = I;<br/>        }<br/>        Sort(tuples.rbegin(), Tuples.rend());<br/>        For (Const Auto&amp; [Num, I] : Tuples) {<br/>            Int Operations = Min((i - Prevgreaterorequalelement[i]) * (Nextgreaterelement[i] - I), K);<br/>            Res = (Int)((1l * Res * Pow(num, Operations)) % Mod);<br/>            K -= Operations;<br/>            If (K == 0) {<br/>                Return Res;<br/>            }<br/>        }<br/><br/>        Return Res;<br/>    }<br/><br/>    Int Pow(int X, Int N) {<br/>        Int Res = 1;<br/>        While (N &gt; 0) {<br/>            If (N % 2 == 1) {<br/>                Res = (Int)((1l * Res * X) % Mod);<br/>            }<br/>            X = (Int)((1l * X * X) % Mod);<br/>            N /= 2;<br/>        }<br/>        Return Res;<br/>    }<br/>};</td>
</tr>
<tr>
<td align="right">52</td>
<td align="right">6</td>
<td>Java</td>
<td>hard</td>
<td>Code Llama</td>
<td>IDE Extension</td>
<td>You are given a 0-indexed 2D integer array items of length n and an integer k.<br/><br/>items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.<br/><br/>Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.<br/><br/>Your task is to find the maximum elegance from all subsequences of size k in items.<br/><br/>Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.<br/><br/>Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.<br/><br/>Example 1:<br/><br/>Input: items = [[3,2],[5,1],[10,1]], k = 2<br/>Output: 17<br/>Explanation: In this example, we have to select a subsequence of size 2.<br/>We can select items[0] = [3,2] and items[2] = [10,1].<br/>The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].<br/>Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. <br/><br/>Example 2:<br/><br/>Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3<br/>Output: 19<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. <br/>The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. <br/>Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.<br/><br/>Example 3:<br/><br/>Input: items = [[1,1],[2,1],[3,1]], k = 3<br/>Output: 7<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We should select all the items. <br/>The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. <br/>Hence, the maximum elegance is 6 + 1^2 = 7.  <br/> <br/>Constraints:<br/><br/>1 &lt;= items.length == n &lt;= 10^5<br/>items[i].length == 2<br/>items[i][0] == profit_i<br/>items[i][1] == category_i<br/>1 &lt;= profit_i &lt;= 10^9<br/>1 &lt;= category_i &lt;= n <br/>1 &lt;= k &lt;= n </td>
<td>/*You are given a 0-indexed 2D integer array items of length n and an integer k.<br/><br/>items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.<br/><br/>Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.<br/><br/>Your task is to find the maximum elegance from all subsequences of size k in items.<br/><br/>Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.<br/><br/>Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.<br/><br/>Example 1:<br/><br/>Input: items = [[3,2],[5,1],[10,1]], k = 2<br/>Output: 17<br/>Explanation: In this example, we have to select a subsequence of size 2.<br/>We can select items[0] = [3,2] and items[2] = [10,1].<br/>The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].<br/>Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. <br/><br/>Example 2:<br/><br/>Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3<br/>Output: 19<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. <br/>The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. <br/>Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.<br/><br/>Example 3:<br/><br/>Input: items = [[1,1],[2,1],[3,1]], k = 3<br/>Output: 7<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We should select all the items. <br/>The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. <br/>Hence, the maximum elegance is 6 + 1^2 = 7.  <br/> <br/>Constraints:<br/><br/>1 &lt;= items.length == n &lt;= 10^5<br/>items[i].length == 2<br/>items[i][0] == profit_i<br/>items[i][1] == category_i<br/>1 &lt;= profit_i &lt;= 10^9<br/>1 &lt;= category_i &lt;= n <br/>1 &lt;= k &lt;= n*/<br/>class Solution {<br/>    public long findMaximumElegance(int[][] items, int k) {</td>
<td>Class Solution {<br/>    Public Long Findmaximumelegance(int[][] Items, Int K) {<br/>        Int N = Items.length;<br/>        Long[][] Dp = New Long[n + 1][k + 1];<br/>        For (Int I = 1; I &lt;= N; I++) {<br/>            Int Profit = Items[i - 1][0];<br/>            Int Category = Items[i - 1][1];<br/>            For (Int J = 1; J &lt;= K; J++) {<br/>                Dp[i][j] = Math.max(dp[i - 1][j], Dp[i - 1][j - 1] + Profit);<br/>                If (Category != Items[i - 1][1]) {<br/>                    Dp[i][j] = Math.max(dp[i][j], Dp[i - 1][j] + Profit);<br/>                }<br/>            }<br/>        }<br/>        Long Max = 0;<br/>        For (Int I = 1; I &lt;= K; I++) {<br/>            Max = Math.max(max, Dp[n][i]);<br/>        }<br/>        Return Max;<br/>    }<br/>}</td>
<td>Class Solution {<br/>    Public Long Findmaximumelegance(int[][] A, Int K) {<br/>        Arrays.sort(a, (A, B) -&gt; B[0] - A[0]);<br/>        Long Res = 0, Cur = 0;<br/>        List&lt;integer&gt; Dup = New Arraylist&lt;&gt;();<br/>        Set&lt;integer&gt; Seen = New Hashset&lt;&gt;();<br/>        For (Int I = 0; I &lt; A.length; ++I) {<br/>            If (I &lt; K) {<br/>                If (Seen.contains(a[i][1])) {<br/>                    Dup.add(a[i][0]);<br/>                }<br/>                Cur += A[i][0];<br/>            } Else If (!Seen.contains(a[i][1])) {<br/>                If (Dup.isempty()) Break;<br/>                Cur += A[i][0] - Dup.remove(dup.size() - 1);<br/>            }<br/>            Seen.add(a[i][1]);<br/>            Res = Math.max(res, Cur + 1l * Seen.size() * Seen.size());<br/>        }<br/>        Return Res;<br/>    }<br/>}</td>
</tr>
<tr>
<td align="right">53</td>
<td align="right">6</td>
<td>Python</td>
<td>hard</td>
<td>Code Llama</td>
<td>IDE Extension</td>
<td>You are given a 0-indexed 2D integer array items of length n and an integer k.<br/><br/>items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.<br/><br/>Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.<br/><br/>Your task is to find the maximum elegance from all subsequences of size k in items.<br/><br/>Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.<br/><br/>Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.<br/><br/>Example 1:<br/><br/>Input: items = [[3,2],[5,1],[10,1]], k = 2<br/>Output: 17<br/>Explanation: In this example, we have to select a subsequence of size 2.<br/>We can select items[0] = [3,2] and items[2] = [10,1].<br/>The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].<br/>Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. <br/><br/>Example 2:<br/><br/>Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3<br/>Output: 19<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. <br/>The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. <br/>Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.<br/><br/>Example 3:<br/><br/>Input: items = [[1,1],[2,1],[3,1]], k = 3<br/>Output: 7<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We should select all the items. <br/>The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. <br/>Hence, the maximum elegance is 6 + 1^2 = 7.  <br/> <br/>Constraints:<br/><br/>1 &lt;= items.length == n &lt;= 10^5<br/>items[i].length == 2<br/>items[i][0] == profit_i<br/>items[i][1] == category_i<br/>1 &lt;= profit_i &lt;= 10^9<br/>1 &lt;= category_i &lt;= n <br/>1 &lt;= k &lt;= n </td>
<td>&quot;&quot;&quot;You are given a 0-indexed 2D integer array items of length n and an integer k.<br/><br/>items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.<br/><br/>Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.<br/><br/>Your task is to find the maximum elegance from all subsequences of size k in items.<br/><br/>Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.<br/><br/>Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.<br/><br/>Example 1:<br/><br/>Input: items = [[3,2],[5,1],[10,1]], k = 2<br/>Output: 17<br/>Explanation: In this example, we have to select a subsequence of size 2.<br/>We can select items[0] = [3,2] and items[2] = [10,1].<br/>The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].<br/>Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. <br/><br/>Example 2:<br/><br/>Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3<br/>Output: 19<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. <br/>The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. <br/>Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.<br/><br/>Example 3:<br/><br/>Input: items = [[1,1],[2,1],[3,1]], k = 3<br/>Output: 7<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We should select all the items. <br/>The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. <br/>Hence, the maximum elegance is 6 + 1^2 = 7.  <br/> <br/>Constraints:<br/><br/>1 &lt;= items.length == n &lt;= 10^5<br/>items[i].length == 2<br/>items[i][0] == profit_i<br/>items[i][1] == category_i<br/>1 &lt;= profit_i &lt;= 10^9<br/>1 &lt;= category_i &lt;= n <br/>1 &lt;= k &lt;= n&quot;&quot;&quot;<br/>class Solution:<br/>    def findMaximumElegance(self, items: List[List[int]], k: int) -&gt; int:</td>
<td>Class Solution:<br/>    Def Findmaximumelegance(self, Items: List[list[int]], K: Int) -&gt; Int:<br/>        N = Len(items)<br/>        Profit = [0] * N<br/>        Category = [0] * N<br/>        For I In Range(n):<br/>            Profit[i] = Items[i][0]<br/>            Category[i] = Items[i][1]<br/>        Profit.sort(reverse=true)<br/>        Category.sort(reverse=true)<br/>        Profit = Profit[:k]<br/>        Category = Category[:k]<br/>        <br/>        Profit_set = Set(profit)<br/>        Category_set = Set(category)<br/>        <br/>        Profit_sum = Sum(profit)<br/>        Category_sum = Sum(category)<br/>        <br/>        Return Profit_sum + Category_sum ** 2</td>
<td>Class Solution:<br/>    Def Findmaximumelegance(self, Items: List[list[int]], K: Int) -&gt; Int:<br/>        Items = Sorted(items, Key=lambda V: -V[0])<br/>        Res = Cur = 0<br/>        A = []<br/>        Seen = Set()<br/>        For I, (P, C) In Enumerate(items):<br/>            If I &lt; K:<br/>                If C In Seen:<br/>                    A.append(p)<br/>                Cur += P<br/>            Elif C Not In Seen:<br/>                If Not A: Break<br/>                Cur += P - A.pop()<br/>            Seen.add(c)<br/>            Res = Max(res, Cur + Len(seen) * Len(seen))<br/>        Return Res</td>
</tr>
<tr>
<td align="right">54</td>
<td align="right">6</td>
<td>C++</td>
<td>hard</td>
<td>Code Llama</td>
<td>IDE Extension</td>
<td>You are given a 0-indexed 2D integer array items of length n and an integer k.<br/><br/>items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.<br/><br/>Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.<br/><br/>Your task is to find the maximum elegance from all subsequences of size k in items.<br/><br/>Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.<br/><br/>Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.<br/><br/>Example 1:<br/><br/>Input: items = [[3,2],[5,1],[10,1]], k = 2<br/>Output: 17<br/>Explanation: In this example, we have to select a subsequence of size 2.<br/>We can select items[0] = [3,2] and items[2] = [10,1].<br/>The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].<br/>Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. <br/><br/>Example 2:<br/><br/>Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3<br/>Output: 19<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. <br/>The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. <br/>Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.<br/><br/>Example 3:<br/><br/>Input: items = [[1,1],[2,1],[3,1]], k = 3<br/>Output: 7<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We should select all the items. <br/>The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. <br/>Hence, the maximum elegance is 6 + 1^2 = 7.  <br/> <br/>Constraints:<br/><br/>1 &lt;= items.length == n &lt;= 10^5<br/>items[i].length == 2<br/>items[i][0] == profit_i<br/>items[i][1] == category_i<br/>1 &lt;= profit_i &lt;= 10^9<br/>1 &lt;= category_i &lt;= n <br/>1 &lt;= k &lt;= n </td>
<td>class Solution {<br/>public:<br/>    long long findMaximumElegance(vector&lt;vector&lt;int&gt;&gt;&amp; items, int k) {<br/>/*You are given a 0-indexed 2D integer array items of length n and an integer k.<br/><br/>items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.<br/><br/>Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.<br/><br/>Your task is to find the maximum elegance from all subsequences of size k in items.<br/><br/>Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.<br/><br/>Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.<br/><br/>Example 1:<br/><br/>Input: items = [[3,2],[5,1],[10,1]], k = 2<br/>Output: 17<br/>Explanation: In this example, we have to select a subsequence of size 2.<br/>We can select items[0] = [3,2] and items[2] = [10,1].<br/>The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].<br/>Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. <br/><br/>Example 2:<br/><br/>Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3<br/>Output: 19<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. <br/>The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. <br/>Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.<br/><br/>Example 3:<br/><br/>Input: items = [[1,1],[2,1],[3,1]], k = 3<br/>Output: 7<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We should select all the items. <br/>The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. <br/>Hence, the maximum elegance is 6 + 1^2 = 7.  <br/> <br/>Constraints:<br/><br/>1 &lt;= items.length == n &lt;= 10^5<br/>items[i].length == 2<br/>items[i][0] == profit_i<br/>items[i][1] == category_i<br/>1 &lt;= profit_i &lt;= 10^9<br/>1 &lt;= category_i &lt;= n <br/>1 &lt;= k &lt;= n*/</td>
<td>Class Solution {<br/>Public:<br/>    Long Long Findmaximumelegance(vector&lt;vector&lt;int&gt;&gt;&amp; Items, Int K) {<br/>        Int N = Items.size();<br/>        Vector&lt;int&gt; Profit(n);<br/>        Vector&lt;int&gt; Category(n);<br/>        <br/>        For(int I = 0; I &lt; N; I++){<br/>            Profit[i] = Items[i][0];<br/>            Category[i] = Items[i][1];<br/>        }<br/>        <br/>        Sort(profit.begin(), Profit.end());<br/>        Sort(category.begin(), Category.end());<br/>        <br/>        Int Max_elegance = 0;<br/>        <br/>        For(int I = 0; I &lt; N; I++){<br/>            Int J = I + K - 1;<br/>            If(j &gt;= N) Break;<br/>            <br/>            Int Total_profit = Profit[j] - Profit[i];<br/>            Int Distinct_categories = Upper_bound(category.begin(), Category.end(), Category[j]) - Upper_bound(category.begin(), Category.end(), Category[i]);<br/>            <br/>            Max_elegance = Max(max_elegance, Total_profit + Distinct_categories * Distinct_categories);<br/>        }<br/>        <br/>        Return Max_elegance;<br/>    }<br/>};</td>
<td>Class Solution {<br/>Public:<br/>    Long Long Findmaximumelegance(vector&lt;vector&lt;int&gt;&gt;&amp; A, Int K) {<br/>        Sort(a.begin(), A.end(), [](Const Vector&lt;int&gt;&amp; A, Const Vector&lt;int&gt;&amp; B) {<br/>            Return A[0] &gt; B[0];<br/>        });<br/>        Long Long Res = 0, Cur = 0;<br/>        Vector&lt;int&gt; Dup;<br/>        Unordered_set&lt;int&gt; Seen;<br/>        For (Int I = 0; I &lt; A.size(); ++I) {<br/>            If (I &lt; K) {<br/>                If (Seen.count(a[i][1])) {<br/>                    Dup.push_back(a[i][0]);<br/>                }<br/>                Cur += A[i][0];<br/>            } Else If (Seen.find(a[i][1]) == Seen.end()) {<br/>                If (Dup.empty()) Break;<br/>                Cur += A[i][0] - Dup.back();<br/>                Dup.pop_back();<br/>            }<br/>            Seen.insert(a[i][1]);<br/>            Res = Fmax(res, Cur + 1l * Seen.size() * Seen.size());<br/>        }<br/>        Return Res;<br/>    }<br/>};</td>
</tr>
<tr>
<td align="right">55</td>
<td align="right">1</td>
<td>Java</td>
<td>easy</td>
<td>CodeWhisperer</td>
<td>IDE Extension</td>
<td>You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.<br/><br/>Return the maximum sum or -1 if no such pair exists.<br/><br/>Example 1:<br/><br/>Input: nums = [51,71,17,24,42]<br/>Output: 88<br/>Explanation: <br/>For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. <br/>For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.<br/>It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.<br/><br/>Example 2:<br/><br/>Input: nums = [1,2,3,4]<br/>Output: -1<br/>Explanation: No pair exists in nums with equal maximum digits.<br/><br/>Constraints:<br/><br/>2 &lt;= nums.length &lt;= 100<br/>1 &lt;= nums[i] &lt;= 10^4 </td>
<td>public class Solution{<br/>    public int maxSum(int[] nums) {<br/>/*You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.<br/><br/>Return the maximum sum or -1 if no such pair exists.<br/><br/>Example 1:<br/><br/>Input: nums = [51,71,17,24,42]<br/>Output: 88<br/>Explanation: <br/>For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. <br/>For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.<br/>It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.<br/><br/>Example 2:<br/><br/>Input: nums = [1,2,3,4]<br/>Output: -1<br/>Explanation: No pair exists in nums with equal maximum digits.<br/> <br/>Constraints:<br/><br/>2 &lt;= nums.length &lt;= 100<br/>1 &lt;= nums[i] &lt;= 10^4<br/>*/</td>
<td>Public Class Solution{<br/>    Public Int Maxsum(int[] Nums) {<br/>        Int Max = -1;<br/>        For(int I = 0; I &lt; Nums.length; I++) {<br/>            For(int J = I + 1; J &lt; Nums.length;<br/>                    J++) {<br/>                If(nums[i] % 10 == Nums[j] % 10) {<br/>                    Max = Math.max(max, Nums[i] + Nums[j]);<br/>                }<br/>            }<br/>            <br/>        }<br/>        Return Max;<br/>        <br/>    }<br/>    <br/>}</td>
<td>Class Solution {<br/>    Public Int Maxsum(int[] Nums) {<br/>    Int Ans = -1;<br/>    Map&lt;integer,list&lt;integer&gt;&gt; Ump = New Hashmap&lt;&gt;();<br/>    For(int I = 0; I &lt; Nums.length; ++I){<br/>        Int T = Nums[i], Maxdigit = 0;<br/>        While(t != 0){ //Evaluate Max Digit In The Number<br/>            Maxdigit = Math.max(t%10, Maxdigit);<br/>            T = T/10;<br/>        }<br/>        If(!ump.containskey(maxdigit)) Ump.put(maxdigit, New Arraylist&lt;&gt;());<br/>        Ump.get(maxdigit).add(nums[i]); // Add The Number To The Map <br/>    }<br/>    For(map.entry&lt;integer, List&lt;integer&gt;&gt; Entry: Ump.entryset()){<br/>        Entry.getvalue().sort(comparator.reverseorder()); //To Find Max Two Number In Each Max Digit <br/>        If(entry.getvalue().size() &gt;= 2) Ans = Math.max(ans, Entry.getvalue().get(0) + Entry.getvalue().get(1)); //Sum Max Two Number And Take Max<br/>    }<br/>    Return Ans;<br/>    }<br/>}</td>
</tr>
<tr>
<td align="right">56</td>
<td align="right">1</td>
<td>Python</td>
<td>easy</td>
<td>CodeWhisperer</td>
<td>IDE Extension</td>
<td>You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.<br/><br/>Return the maximum sum or -1 if no such pair exists.<br/><br/>Example 1:<br/><br/>Input: nums = [51,71,17,24,42]<br/>Output: 88<br/>Explanation: <br/>For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. <br/>For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.<br/>It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.<br/><br/>Example 2:<br/><br/>Input: nums = [1,2,3,4]<br/>Output: -1<br/>Explanation: No pair exists in nums with equal maximum digits.<br/><br/>Constraints:<br/><br/>2 &lt;= nums.length &lt;= 100<br/>1 &lt;= nums[i] &lt;= 10^4 </td>
<td>class Solution:<br/>    def maxSum(self, nums: List[int]) -&gt; int:<br/>&quot;&quot;&quot;You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.<br/><br/>Return the maximum sum or -1 if no such pair exists.<br/><br/>Example 1:<br/><br/>Input: nums = [51,71,17,24,42]<br/>Output: 88<br/>Explanation: <br/>For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. <br/>For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.<br/>It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.<br/><br/>Example 2:<br/><br/>Input: nums = [1,2,3,4]<br/>Output: -1<br/>Explanation: No pair exists in nums with equal maximum digits.<br/> <br/>Constraints:<br/><br/>2 &lt;= nums.length &lt;= 100<br/>1 &lt;= nums[i] &lt;= 10^4&quot;&quot;&quot;</td>
<td>Class Solution:<br/>    Def Maxsum(self, Nums: List[int]) -&gt; Int:<br/>        Nums.sort(reverse=true)<br/>        For I In Range(len(nums)-1):<br/>            If Nums[i]%10==nums[i+1]%10:<br/>                Return Nums[i]+nums[i+1]<br/>        Return -1</td>
<td>Class Solution:<br/>    Def Maxsum(self, Nums: List[int]) -&gt; Int:<br/>        Max_by_digit = Defaultdict(int)<br/>        Max_sum = -1<br/><br/>        For Num In Nums:<br/>            Digit = Max(str(num))<br/><br/>            If Digit In Max_by_digit:<br/>                Max_sum = Max(max_sum, Max_by_digit[digit] + Num)<br/><br/>            Max_by_digit[digit] = Max(max_by_digit[digit], Num)<br/><br/>        Return Max_sum</td>
</tr>
<tr>
<td align="right">57</td>
<td align="right">1</td>
<td>C++</td>
<td>easy</td>
<td>CodeWhisperer</td>
<td>IDE Extension</td>
<td>You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.<br/><br/>Return the maximum sum or -1 if no such pair exists.<br/><br/>Example 1:<br/><br/>Input: nums = [51,71,17,24,42]<br/>Output: 88<br/>Explanation: <br/>For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. <br/>For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.<br/>It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.<br/><br/>Example 2:<br/><br/>Input: nums = [1,2,3,4]<br/>Output: -1<br/>Explanation: No pair exists in nums with equal maximum digits.<br/><br/>Constraints:<br/><br/>2 &lt;= nums.length &lt;= 100<br/>1 &lt;= nums[i] &lt;= 10^4 </td>
<td>/*You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.<br/><br/>Return the maximum sum or -1 if no such pair exists.<br/><br/>Example 1:<br/><br/>Input: nums = [51,71,17,24,42]<br/>Output: 88<br/>Explanation: <br/>For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. <br/>For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.<br/>It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.<br/><br/>Example 2:<br/><br/>Input: nums = [1,2,3,4]<br/>Output: -1<br/>Explanation: No pair exists in nums with equal maximum digits.<br/><br/>Constraints:<br/><br/>2 &lt;= nums.length &lt;= 100<br/>1 &lt;= nums[i] &lt;= 10^4<br/>*/<br/>class Solution {<br/>public:<br/>    int maxSum(vector&lt;int&gt;&amp; nums) {</td>
<td>Class Solution {<br/>Public:<br/>    Int Maxsum(vector&lt;int&gt;&amp; Nums) {<br/>        Int Ans = -1;<br/>        Int N = Nums.size();<br/>        For(int I = 0; I &lt; N; I++){<br/>            For(int J = I + 1; J &lt; N; J++){<br/>                If(nums[i] % 10 == Nums[j] % 10){<br/>                    Ans = Max(ans, Nums[i] + Nums[j]);<br/>                    Break;<br/>                }<br/>            }<br/>        }<br/>        Return Ans;<br/>    }<br/>};</td>
<td>Class Solution {<br/>    Public:<br/>        Int Maxsum(vector&lt;int&gt;&amp; Nums) {<br/>        Int Res = -1, Max_num[10] = {};<br/>        For (Auto Num : Nums) {<br/>            Int Max_d = 0;<br/>            For (Int V = Num; V; V /= 10)<br/>                Max_d = Max(max_d, V % 10);<br/>            If (Max_num[max_d])<br/>                Res = Max(res, Max_num[max_d] + Num);<br/>            Max_num[max_d] = Max(max_num[max_d], Num);<br/>        }<br/>        Return Res;<br/>    }<br/>};</td>
</tr>
<tr>
<td align="right">58</td>
<td align="right">2</td>
<td>Java</td>
<td>easy</td>
<td>CodeWhisperer</td>
<td>IDE Extension</td>
<td>Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.<br/><br/>You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.<br/><br/>Return the final string that will be present on your laptop screen.<br/><br/>Example 1:<br/><br/>Input: s = &quot;string&quot;<br/>Output: &quot;rtsng&quot;<br/>Explanation: <br/>After typing first character, the text on the screen is &quot;s&quot;.<br/>After the second character, the text is &quot;st&quot;. <br/>After the third character, the text is &quot;str&quot;.<br/>Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.<br/>After the fifth character, the text is &quot;rtsn&quot;. <br/>After the sixth character, the text is &quot;rtsng&quot;. <br/>Therefore, we return &quot;rtsng&quot;.<br/><br/>Example 2:<br/><br/>Input: s = &quot;poiinter&quot;<br/>Output: &quot;ponter&quot;<br/>Explanation: <br/>After the first character, the text on the screen is &quot;p&quot;.<br/>After the second character, the text is &quot;po&quot;. <br/>Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. <br/>Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.<br/>After the fifth character, the text is &quot;pon&quot;.<br/>After the sixth character, the text is &quot;pont&quot;. <br/>After the seventh character, the text is &quot;ponte&quot;. <br/>After the eighth character, the text is &quot;ponter&quot;. <br/>Therefore, we return &quot;ponter&quot;.<br/> <br/>Constraints:<br/><br/>1 &lt;= s.length &lt;= 100<br/>s consists of lowercase English letters.<br/>s[0] != &#39;i&#39;</td>
<td>public class Solution {<br/>    public String finalString(String s) {<br/>        /*<br/>         * Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.<br/><br/>You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.<br/><br/>Return the final string that will be present on your laptop screen.<br/><br/>Example 1:<br/><br/>Input: s = &quot;string&quot;<br/>Output: &quot;rtsng&quot;<br/>Explanation: <br/>After typing first character, the text on the screen is &quot;s&quot;.<br/>After the second character, the text is &quot;st&quot;. <br/>After the third character, the text is &quot;str&quot;.<br/>Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.<br/>After the fifth character, the text is &quot;rtsn&quot;. <br/>After the sixth character, the text is &quot;rtsng&quot;. <br/>Therefore, we return &quot;rtsng&quot;.<br/><br/>Example 2:<br/><br/>Input: s = &quot;poiinter&quot;<br/>Output: &quot;ponter&quot;<br/>Explanation: <br/>After the first character, the text on the screen is &quot;p&quot;.<br/>After the second character, the text is &quot;po&quot;. <br/>Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. <br/>Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.<br/>After the fifth character, the text is &quot;pon&quot;.<br/>After the sixth character, the text is &quot;pont&quot;. <br/>After the seventh character, the text is &quot;ponte&quot;. <br/>After the eighth character, the text is &quot;ponter&quot;. <br/>Therefore, we return &quot;ponter&quot;.<br/> <br/>Constraints:<br/><br/>1 &lt;= s.length &lt;= 100<br/>s consists of lowercase English letters.<br/>s[0] != &#39;i&#39;<br/><br/>*/</td>
<td>Public Class Solution {<br/>    Public String Finalstring(string S) {<br/>        Stringbuilder Sb = New Stringbuilder();<br/>        For (Int I = 0; I &lt; S.length(); I++) {<br/>            Char C = S.charat(i);<br/>            If (C == &#39;I&#39;) {<br/>                Sb.append(s.substring(i));<br/>                Break;<br/>            }<br/>            Sb.append(c);<br/>        }<br/>        Return Sb.tostring();<br/>        <br/>    }<br/>    <br/>}</td>
<td>Class Solution {<br/>    Public String Finalstring(string S) {<br/>        Stringbuilder Nm=new Stringbuilder();<br/>        For(char C:s.tochararray())<br/>        {<br/>            If(c==&#39;i&#39;)<br/>            {<br/>                Nm.reverse();<br/>            }<br/>            Else<br/>            {<br/>                Nm.append(c);<br/>            }<br/>        }<br/>        Return Nm.tostring();<br/>    }<br/>}</td>
</tr>
<tr>
<td align="right">59</td>
<td align="right">2</td>
<td>Python</td>
<td>easy</td>
<td>CodeWhisperer</td>
<td>IDE Extension</td>
<td>Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.<br/><br/>You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.<br/><br/>Return the final string that will be present on your laptop screen.<br/><br/>Example 1:<br/><br/>Input: s = &quot;string&quot;<br/>Output: &quot;rtsng&quot;<br/>Explanation: <br/>After typing first character, the text on the screen is &quot;s&quot;.<br/>After the second character, the text is &quot;st&quot;. <br/>After the third character, the text is &quot;str&quot;.<br/>Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.<br/>After the fifth character, the text is &quot;rtsn&quot;. <br/>After the sixth character, the text is &quot;rtsng&quot;. <br/>Therefore, we return &quot;rtsng&quot;.<br/><br/>Example 2:<br/><br/>Input: s = &quot;poiinter&quot;<br/>Output: &quot;ponter&quot;<br/>Explanation: <br/>After the first character, the text on the screen is &quot;p&quot;.<br/>After the second character, the text is &quot;po&quot;. <br/>Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. <br/>Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.<br/>After the fifth character, the text is &quot;pon&quot;.<br/>After the sixth character, the text is &quot;pont&quot;. <br/>After the seventh character, the text is &quot;ponte&quot;. <br/>After the eighth character, the text is &quot;ponter&quot;. <br/>Therefore, we return &quot;ponter&quot;.<br/> <br/>Constraints:<br/><br/>1 &lt;= s.length &lt;= 100<br/>s consists of lowercase English letters.<br/>s[0] != &#39;i&#39;</td>
<td>class Solution:<br/>    def finalString(self, s: str) -&gt; str:<br/>&quot;&quot;&quot;Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.<br/><br/>You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.<br/><br/>Return the final string that will be present on your laptop screen.<br/><br/>Example 1:<br/><br/>Input: s = &quot;string&quot;<br/>Output: &quot;rtsng&quot;<br/>Explanation: <br/>After typing first character, the text on the screen is &quot;s&quot;.<br/>After the second character, the text is &quot;st&quot;. <br/>After the third character, the text is &quot;str&quot;.<br/>Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.<br/>After the fifth character, the text is &quot;rtsn&quot;. <br/>After the sixth character, the text is &quot;rtsng&quot;. <br/>Therefore, we return &quot;rtsng&quot;.<br/><br/>Example 2:<br/><br/>Input: s = &quot;poiinter&quot;<br/>Output: &quot;ponter&quot;<br/>Explanation: <br/>After the first character, the text on the screen is &quot;p&quot;.<br/>After the second character, the text is &quot;po&quot;. <br/>Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. <br/>Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.<br/>After the fifth character, the text is &quot;pon&quot;.<br/>After the sixth character, the text is &quot;pont&quot;. <br/>After the seventh character, the text is &quot;ponte&quot;. <br/>After the eighth character, the text is &quot;ponter&quot;. <br/>Therefore, we return &quot;ponter&quot;.<br/> <br/>Constraints:<br/><br/>1 &lt;= s.length &lt;= 100<br/>s consists of lowercase English letters.<br/>s[0] != &#39;i&#39;&quot;&quot;&quot;</td>
<td>Class Solution:<br/>    Def Finalstring(self, S: Str) -&gt; Str:<br/>        Ans = &quot;&quot;<br/>        For I In Range(len(s)):<br/>            If S[i] == &#39;I&#39;:<br/>                Ans = Ans[:-1]<br/>            Else:<br/>                Ans += S[i]<br/>        Return Ans</td>
<td>Class Solution:<br/>    Def Finalstring(self, S: Str) -&gt; Str:<br/>        While &quot;I&quot; In S:<br/>            Index=s.index(&quot;i&quot;)<br/><br/>            #First Half And Second Half<br/>            First=s[:index][::-1]<br/>            Second=s[index+1:]<br/><br/>            S=&quot;&quot;.join([first,second])<br/>        Return S</td>
</tr>
<tr>
<td align="right">60</td>
<td align="right">2</td>
<td>C++</td>
<td>easy</td>
<td>CodeWhisperer</td>
<td>IDE Extension</td>
<td>Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.<br/><br/>You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.<br/><br/>Return the final string that will be present on your laptop screen.<br/><br/>Example 1:<br/><br/>Input: s = &quot;string&quot;<br/>Output: &quot;rtsng&quot;<br/>Explanation: <br/>After typing first character, the text on the screen is &quot;s&quot;.<br/>After the second character, the text is &quot;st&quot;. <br/>After the third character, the text is &quot;str&quot;.<br/>Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.<br/>After the fifth character, the text is &quot;rtsn&quot;. <br/>After the sixth character, the text is &quot;rtsng&quot;. <br/>Therefore, we return &quot;rtsng&quot;.<br/><br/>Example 2:<br/><br/>Input: s = &quot;poiinter&quot;<br/>Output: &quot;ponter&quot;<br/>Explanation: <br/>After the first character, the text on the screen is &quot;p&quot;.<br/>After the second character, the text is &quot;po&quot;. <br/>Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. <br/>Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.<br/>After the fifth character, the text is &quot;pon&quot;.<br/>After the sixth character, the text is &quot;pont&quot;. <br/>After the seventh character, the text is &quot;ponte&quot;. <br/>After the eighth character, the text is &quot;ponter&quot;. <br/>Therefore, we return &quot;ponter&quot;.<br/> <br/>Constraints:<br/><br/>1 &lt;= s.length &lt;= 100<br/>s consists of lowercase English letters.<br/>s[0] != &#39;i&#39;</td>
<td>class Solution {<br/>public:<br/>    string finalString(string s) {<br/>/*Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.<br/><br/>You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.<br/><br/>Return the final string that will be present on your laptop screen.<br/><br/>Example 1:<br/><br/>Input: s = &quot;string&quot;<br/>Output: &quot;rtsng&quot;<br/>Explanation: <br/>After typing first character, the text on the screen is &quot;s&quot;.<br/>After the second character, the text is &quot;st&quot;. <br/>After the third character, the text is &quot;str&quot;.<br/>Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.<br/>After the fifth character, the text is &quot;rtsn&quot;. <br/>After the sixth character, the text is &quot;rtsng&quot;. <br/>Therefore, we return &quot;rtsng&quot;.<br/><br/>Example 2:<br/><br/>Input: s = &quot;poiinter&quot;<br/>Output: &quot;ponter&quot;<br/>Explanation: <br/>After the first character, the text on the screen is &quot;p&quot;.<br/>After the second character, the text is &quot;po&quot;. <br/>Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. <br/>Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.<br/>After the fifth character, the text is &quot;pon&quot;.<br/>After the sixth character, the text is &quot;pont&quot;. <br/>After the seventh character, the text is &quot;ponte&quot;. <br/>After the eighth character, the text is &quot;ponter&quot;. <br/>Therefore, we return &quot;ponter&quot;.<br/> <br/>Constraints:<br/><br/>1 &lt;= s.length &lt;= 100<br/>s consists of lowercase English letters.<br/>s[0] != &#39;i&#39;*/</td>
<td>Class Solution {<br/>Public:<br/>    String Finalstring(string S) {<br/>        String Ans=&quot;&quot;;<br/>        For(int I=0;i&lt;s.length();i++){<br/>            If(s[i]==&#39;i&#39;){<br/>                Reverse(ans.begin(),ans.end());<br/>                Ans=&quot;&quot;;<br/>                Continue;<br/>            }<br/>            Ans+=s[i];<br/>        }<br/>        Return Ans;<br/>    }<br/>};</td>
<td>Class Solution {<br/>Public:<br/>    String Finalstring(const String &amp;S) {<br/>        String A, B;<br/>        For (Char Ch : S)<br/>            If (Ch == &#39;I&#39;)<br/>                Swap(a, B);<br/>            Else<br/>                A += Ch;<br/>        Return String(rbegin(b), Rend(b)) + A;<br/>    }<br/>};</td>
</tr>
<tr>
<td align="right">61</td>
<td align="right">3</td>
<td>Java</td>
<td>medium</td>
<td>CodeWhisperer</td>
<td>IDE Extension</td>
<td>You are given a 0-indexed integer array nums and an integer x.<br/><br/>Find the minimum absolute difference between two elements in the array that are at least x indices apart.<br/><br/>In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.<br/><br/>Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.<br/><br/>Example 1:<br/><br/>Input: nums = [4,3,2,4], x = 2<br/>Output: 0<br/>Explanation: We can select nums[0] = 4 and nums[3] = 4. <br/>They are at least 2 indices apart, and their absolute difference is the minimum, 0. <br/>It can be shown that 0 is the optimal answer.<br/><br/>Example 2:<br/><br/>Input: nums = [5,3,2,10,15], x = 1<br/>Output: 1<br/>Explanation: We can select nums[1] = 3 and nums[2] = 2.<br/>They are at least 1 index apart, and their absolute difference is the minimum, 1.<br/>It can be shown that 1 is the optimal answer.<br/><br/>Example 3:<br/><br/>Input: nums = [1,2,3,4], x = 3<br/>Output: 3<br/>Explanation: We can select nums[0] = 1 and nums[3] = 4.<br/>They are at least 3 indices apart, and their absolute difference is the minimum, 3.<br/>It can be shown that 3 is the optimal answer.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^9<br/>0 &lt;= x &lt; nums.length </td>
<td>class Solution {<br/>    public int minAbsoluteDifference(List&lt;Integer&gt; nums, int x) {<br/>        /*<br/>         * You are given a 0-indexed integer array nums and an integer x.<br/><br/>Find the minimum absolute difference between two elements in the array that are at least x indices apart.<br/><br/>In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.<br/><br/>Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.<br/><br/>Example 1:<br/><br/>Input: nums = [4,3,2,4], x = 2<br/>Output: 0<br/>Explanation: We can select nums[0] = 4 and nums[3] = 4. <br/>They are at least 2 indices apart, and their absolute difference is the minimum, 0. <br/>It can be shown that 0 is the optimal answer.<br/><br/>Example 2:<br/><br/>Input: nums = [5,3,2,10,15], x = 1<br/>Output: 1<br/>Explanation: We can select nums[1] = 3 and nums[2] = 2.<br/>They are at least 1 index apart, and their absolute difference is the minimum, 1.<br/>It can be shown that 1 is the optimal answer.<br/><br/>Example 3:<br/><br/>Input: nums = [1,2,3,4], x = 3<br/>Output: 3<br/>Explanation: We can select nums[0] = 1 and nums[3] = 4.<br/>They are at least 3 indices apart, and their absolute difference is the minimum, 3.<br/>It can be shown that 3 is the optimal answer.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^9<br/>0 &lt;= x &lt; nums.length<br/><br/>*/</td>
<td>Class Solution {<br/>    Public Int Minabsolutedifference(list&lt;integer&gt; Nums, Int X) {<br/>        Int Min = Integer.max_value;<br/>        Int N = Nums.size();<br/>        For (Int I = 0; I &lt; N; I++) {<br/>            For (Int J = I + 1; J &lt; N; J++) {<br/>                If (Math.abs(i - J) &gt;= X) {<br/>                    Min = Math.min(min, Math.abs(nums.get(i) - Nums.get(j)));<br/>                }<br/>            }<br/>        }<br/>        Return Min;<br/>        <br/>    }<br/>    <br/>}</td>
<td>Class Solution {<br/>    Int Minabsolutedifference(list&lt;integer&gt; Nums, Int X) {<br/>        Int Ans = Integer.max_value;<br/>        Treeset&lt;integer&gt; S = New Treeset&lt;&gt;();<br/>        For(int I = X; I &lt; Nums.size(); ++I){<br/>            S.add(nums.get(i-x));<br/>            Integer High = S.ceiling(nums.get(i)), Low = S.floor(nums.get(i));<br/>            If(high != Null) Ans = Math.min(ans, Math.abs(nums.get(i) - High));<br/>            If(low != Null) Ans = Math.min(ans, Math.abs(nums.get(i) - Low));<br/>        }<br/>        Return Ans;<br/>    }<br/>}</td>
</tr>
<tr>
<td align="right">62</td>
<td align="right">3</td>
<td>Python</td>
<td>medium</td>
<td>CodeWhisperer</td>
<td>IDE Extension</td>
<td>You are given a 0-indexed integer array nums and an integer x.<br/><br/>Find the minimum absolute difference between two elements in the array that are at least x indices apart.<br/><br/>In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.<br/><br/>Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.<br/><br/>Example 1:<br/><br/>Input: nums = [4,3,2,4], x = 2<br/>Output: 0<br/>Explanation: We can select nums[0] = 4 and nums[3] = 4. <br/>They are at least 2 indices apart, and their absolute difference is the minimum, 0. <br/>It can be shown that 0 is the optimal answer.<br/><br/>Example 2:<br/><br/>Input: nums = [5,3,2,10,15], x = 1<br/>Output: 1<br/>Explanation: We can select nums[1] = 3 and nums[2] = 2.<br/>They are at least 1 index apart, and their absolute difference is the minimum, 1.<br/>It can be shown that 1 is the optimal answer.<br/><br/>Example 3:<br/><br/>Input: nums = [1,2,3,4], x = 3<br/>Output: 3<br/>Explanation: We can select nums[0] = 1 and nums[3] = 4.<br/>They are at least 3 indices apart, and their absolute difference is the minimum, 3.<br/>It can be shown that 3 is the optimal answer.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^9<br/>0 &lt;= x &lt; nums.length </td>
<td>class Solution:<br/>    def minAbsoluteDifference(self, nums: List[int], x: int) -&gt; int:<br/>&quot;&quot;&quot;You are given a 0-indexed integer array nums and an integer x.<br/><br/>Find the minimum absolute difference between two elements in the array that are at least x indices apart.<br/><br/>In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.<br/><br/>Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.<br/><br/>Example 1:<br/><br/>Input: nums = [4,3,2,4], x = 2<br/>Output: 0<br/>Explanation: We can select nums[0] = 4 and nums[3] = 4. <br/>They are at least 2 indices apart, and their absolute difference is the minimum, 0. <br/>It can be shown that 0 is the optimal answer.<br/><br/>Example 2:<br/><br/>Input: nums = [5,3,2,10,15], x = 1<br/>Output: 1<br/>Explanation: We can select nums[1] = 3 and nums[2] = 2.<br/>They are at least 1 index apart, and their absolute difference is the minimum, 1.<br/>It can be shown that 1 is the optimal answer.<br/><br/>Example 3:<br/><br/>Input: nums = [1,2,3,4], x = 3<br/>Output: 3<br/>Explanation: We can select nums[0] = 1 and nums[3] = 4.<br/>They are at least 3 indices apart, and their absolute difference is the minimum, 3.<br/>It can be shown that 3 is the optimal answer.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^9<br/>0 &lt;= x &lt; nums.length &quot;&quot;&quot;</td>
<td>Class Solution:<br/>    Def Minabsolutedifference(self, Nums: List[int], X: Int) -&gt; Int:<br/>        Nums.sort()<br/>        Ans = Float(&#39;inf&#39;)<br/>        For I In Range(len(nums)):<br/>            J = Bisect_left(nums, Nums[i] + X)<br/>            If J &lt; Len(nums):<br/>                Ans = Min(ans, Nums[j] - Nums[i])<br/>            If I + 1 &lt; Len(nums):<br/>                Ans = Min(ans, Nums[i + 1] - Nums[i])<br/>        Return Ans</td>
<td>Class Solution:<br/>  Def Minabsolutedifference(self, Nums: List[int], X: Int) -&gt; Int:<br/>    If X == 0:<br/>      Return 0<br/><br/>    Arr, Best_dist = Sortedlist([]), Float(&#39;inf&#39;)<br/>    For I In Range(x, Len(nums)):<br/>      Arr.add(nums[i - X])<br/>      V = Nums[i]<br/><br/>      Pos = Arr.bisect_left(v)<br/>      If Pos &lt; Len(arr):<br/>        Best_dist = Min(best_dist, Abs(arr[pos] - V))<br/>      If Pos &gt; 0:<br/>        Best_dist = Min(best_dist, Abs(arr[pos - 1] - V))<br/>    <br/>    Return Best_dist</td>
</tr>
<tr>
<td align="right">63</td>
<td align="right">3</td>
<td>C++</td>
<td>medium</td>
<td>CodeWhisperer</td>
<td>IDE Extension</td>
<td>You are given a 0-indexed integer array nums and an integer x.<br/><br/>Find the minimum absolute difference between two elements in the array that are at least x indices apart.<br/><br/>In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.<br/><br/>Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.<br/><br/>Example 1:<br/><br/>Input: nums = [4,3,2,4], x = 2<br/>Output: 0<br/>Explanation: We can select nums[0] = 4 and nums[3] = 4. <br/>They are at least 2 indices apart, and their absolute difference is the minimum, 0. <br/>It can be shown that 0 is the optimal answer.<br/><br/>Example 2:<br/><br/>Input: nums = [5,3,2,10,15], x = 1<br/>Output: 1<br/>Explanation: We can select nums[1] = 3 and nums[2] = 2.<br/>They are at least 1 index apart, and their absolute difference is the minimum, 1.<br/>It can be shown that 1 is the optimal answer.<br/><br/>Example 3:<br/><br/>Input: nums = [1,2,3,4], x = 3<br/>Output: 3<br/>Explanation: We can select nums[0] = 1 and nums[3] = 4.<br/>They are at least 3 indices apart, and their absolute difference is the minimum, 3.<br/>It can be shown that 3 is the optimal answer.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^9<br/>0 &lt;= x &lt; nums.length </td>
<td>class Solution {<br/>public:<br/>    int minAbsoluteDifference(vector&lt;int&gt;&amp; nums, int x) {<br/>/*You are given a 0-indexed integer array nums and an integer x.<br/><br/>Find the minimum absolute difference between two elements in the array that are at least x indices apart.<br/><br/>In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.<br/><br/>Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.<br/><br/>Example 1:<br/><br/>Input: nums = [4,3,2,4], x = 2<br/>Output: 0<br/>Explanation: We can select nums[0] = 4 and nums[3] = 4. <br/>They are at least 2 indices apart, and their absolute difference is the minimum, 0. <br/>It can be shown that 0 is the optimal answer.<br/><br/>Example 2:<br/><br/>Input: nums = [5,3,2,10,15], x = 1<br/>Output: 1<br/>Explanation: We can select nums[1] = 3 and nums[2] = 2.<br/>They are at least 1 index apart, and their absolute difference is the minimum, 1.<br/>It can be shown that 1 is the optimal answer.<br/><br/>Example 3:<br/><br/>Input: nums = [1,2,3,4], x = 3<br/>Output: 3<br/>Explanation: We can select nums[0] = 1 and nums[3] = 4.<br/>They are at least 3 indices apart, and their absolute difference is the minimum, 3.<br/>It can be shown that 3 is the optimal answer.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^9<br/>0 &lt;= x &lt; nums.length<br/>*/</td>
<td>Class Solution {<br/>Public:<br/>    Int Minabsolutedifference(vector&lt;int&gt;&amp; Nums, Int X) {<br/>        Int N = Nums.size();<br/>        Int Ans = Int_max;<br/>        For(int I = 0; I &lt; N; I++){<br/>            For(int J = I + 1; J &lt; N; J++){<br/>                If(abs(nums[i] - Nums[j]) &gt;= X){<br/>                    Ans = Min(ans, Abs(nums[i] - Nums[j]));<br/>                    Break;<br/>                }<br/>            }<br/>        }<br/>        Return Ans;<br/>    }<br/>};</td>
<td>Class Solution {<br/>Public:<br/>    Int Minabsolutedifference(vector&lt;int&gt;&amp; Nums, Int X) {<br/>        Int Ans = Int_max;<br/>        Set&lt;int&gt; S;<br/>        For(int I = X; I &lt; Nums.size(); ++I){<br/>            S.insert(nums[i-x]);<br/>            Auto It = S.upper_bound(nums[i]);<br/>            If(it != S.end()) Ans = Min(ans, Abs(nums[i] - *It));<br/>            If(it != S.begin()) Ans = Min(ans, Abs(nums[i] - *Prev(it)));<br/>        }<br/>        Return Ans;<br/>    }<br/>};</td>
</tr>
<tr>
<td align="right">64</td>
<td align="right">4</td>
<td>Java</td>
<td>medium</td>
<td>CodeWhisperer</td>
<td>IDE Extension</td>
<td>You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.<br/><br/>Return the head of the linked list after doubling it.<br/><br/>Example 1:<br/><br/>Input: head = [1,8,9]<br/>Output: [3,7,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.<br/><br/>Example 2:<br/><br/>Input: head = [9,9,9]<br/>Output: [1,9,9,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. <br/><br/>Constraints:<br/><br/>The number of nodes in the list is in the range [1, 10^4]<br/>0 &lt;= Node.val &lt;= 9<br/>The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself. </td>
<td>class Solution {<br/>    public ListNode doubleIt(ListNode head) {<br/>/*<br/> *You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.<br/><br/>Return the head of the linked list after doubling it.<br/><br/>Example 1:<br/><br/>Input: head = [1,8,9]<br/>Output: [3,7,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.<br/><br/>Example 2:<br/><br/>Input: head = [9,9,9]<br/>Output: [1,9,9,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. <br/><br/>Constraints:<br/><br/>The number of nodes in the list is in the range [1, 10^4]<br/>0 &lt;= Node.val &lt;= 9<br/>The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.<br/>*/</td>
<td>Class Solution {<br/>    Public Listnode Doubleit(listnode Head) {<br/>        Listnode Curr = Head;<br/>        While (Curr != Null) {<br/>            Curr.val *= 2;<br/>            Curr = Curr.next;<br/>        }<br/>        Return Head;<br/>        <br/>    }<br/>    <br/>}</td>
<td>Class Solution {<br/>    Public Listnode Doubleit(listnode Head) {<br/>        If (Head.val &gt; 4)<br/>            Head = New Listnode(0, Head);<br/>        For(listnode Node = Head; Node != Null; Node = Node.next) {<br/>            Node.val = (Node.val * 2) % 10;<br/>            If (Node.next != Null &amp;&amp; Node.next.val &gt; 4)<br/>                Node.val++;<br/>        }<br/>        Return Head;<br/>    }<br/>}</td>
</tr>
<tr>
<td align="right">65</td>
<td align="right">4</td>
<td>Python</td>
<td>medium</td>
<td>CodeWhisperer</td>
<td>IDE Extension</td>
<td>You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.<br/><br/>Return the head of the linked list after doubling it.<br/><br/>Example 1:<br/><br/>Input: head = [1,8,9]<br/>Output: [3,7,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.<br/><br/>Example 2:<br/><br/>Input: head = [9,9,9]<br/>Output: [1,9,9,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. <br/><br/>Constraints:<br/><br/>The number of nodes in the list is in the range [1, 10^4]<br/>0 &lt;= Node.val &lt;= 9<br/>The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself. </td>
<td>class Solution:<br/>    def doubleIt(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:<br/>&quot;&quot;&quot;You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.<br/><br/>Return the head of the linked list after doubling it.<br/><br/>Example 1:<br/><br/>Input: head = [1,8,9]<br/>Output: [3,7,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.<br/><br/>Example 2:<br/><br/>Input: head = [9,9,9]<br/>Output: [1,9,9,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. <br/><br/>Constraints:<br/><br/>The number of nodes in the list is in the range [1, 10^4]<br/>0 &lt;= Node.val &lt;= 9<br/>The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.&quot;&quot;&quot;</td>
<td>Class Solution:<br/>    Def Doubleit(self, Head: Optional[listnode]) -&gt; Optional[listnode]:<br/>        If Not Head:<br/>            Return Head<br/>        If Not Head.next:<br/>            Head.val *= 2<br/>            Return Head<br/>        Prev = Head<br/>        Curr = Head.next<br/>        While Curr:<br/>            Curr.val *= 2<br/>            Prev = Curr<br/>            Curr = Curr.next<br/>        Prev.val *= 2<br/>        Return Head</td>
<td>Class Solution:<br/>    Def Doubleit(self, Head: Optional[listnode]) -&gt; Optional[listnode]:<br/>        If Head.val &gt; 4:<br/>            Head = Listnode(0, Head)<br/>        Node = Head<br/>        While Node:<br/>            Node.val = (Node.val * 2) % 10<br/>            If Node.next And Node.next.val &gt; 4:<br/>                Node.val += 1<br/>            Node = Node.next<br/>        Return Head</td>
</tr>
<tr>
<td align="right">66</td>
<td align="right">4</td>
<td>C++</td>
<td>medium</td>
<td>CodeWhisperer</td>
<td>IDE Extension</td>
<td>You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.<br/><br/>Return the head of the linked list after doubling it.<br/><br/>Example 1:<br/><br/>Input: head = [1,8,9]<br/>Output: [3,7,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.<br/><br/>Example 2:<br/><br/>Input: head = [9,9,9]<br/>Output: [1,9,9,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. <br/><br/>Constraints:<br/><br/>The number of nodes in the list is in the range [1, 10^4]<br/>0 &lt;= Node.val &lt;= 9<br/>The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself. </td>
<td>/*You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.<br/><br/>Return the head of the linked list after doubling it.<br/><br/>Example 1:<br/><br/>Input: head = [1,8,9]<br/>Output: [3,7,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.<br/><br/>Example 2:<br/><br/>Input: head = [9,9,9]<br/>Output: [1,9,9,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. <br/><br/>Constraints:<br/><br/>The number of nodes in the list is in the range [1, 10^4]<br/>0 &lt;= Node.val &lt;= 9<br/>The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.<br/>*/<br/><br/>/**<br/> * Definition for singly-linked list.<br/> * struct ListNode {<br/> *     int val;<br/> *     ListNode *next;<br/> *     ListNode() : val(0), next(nullptr) {}<br/> *     ListNode(int x) : val(x), next(nullptr) {}<br/> *     ListNode(int x, ListNode *next) : val(x), next(next) {}<br/> * };<br/> */<br/>class Solution {<br/>public:<br/>    ListNode* doubleIt(ListNode* head) {</td>
<td>Class Solution {<br/>Public:<br/>    Listnode* Doubleit(listnode* Head) {<br/>        If(head == Null)<br/>            Return Null;<br/>        Listnode* Temp = Head;<br/>        While(temp-&gt;next != Null){<br/>            Temp-&gt;val *= 2;<br/>            Temp = Temp-&gt;next;<br/>            If(temp-&gt;next != Null) {<br/>                Temp-&gt;val *= 2;<br/>                Temp = Temp-&gt;next;<br/>                Continue;<br/>            }<br/>            Else {<br/>                Break;<br/>            }<br/>        }<br/>        Return Head;<br/>    }<br/>};</td>
<td>Class Solution {<br/>Public:<br/>    Listnode* Doubleit(listnode* Head) {<br/>        If (Head-&gt;val &gt; 4)<br/>            Head = New Listnode(0, Head);<br/>        For(listnode* Node = Head; Node; Node = Node-&gt;next) {<br/>            Node-&gt;val = (Node-&gt;val * 2) % 10;<br/>            If (Node-&gt;next &amp;&amp; Node-&gt;next-&gt;val &gt; 4)<br/>                Node-&gt;val++;<br/>        }<br/>        Return Head;<br/>    }<br/>};</td>
</tr>
<tr>
<td align="right">67</td>
<td align="right">5</td>
<td>Java</td>
<td>hard</td>
<td>CodeWhisperer</td>
<td>IDE Extension</td>
<td>You are given an array nums of n positive integers and an integer k.<br/><br/>Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:<br/><br/>Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.<br/>Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.<br/>Multiply your score by x.<br/>Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.<br/><br/>The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.<br/><br/>Return the maximum possible score after applying at most k operations.<br/><br/>Since the answer may be large, return it modulo 10^9 + 7.<br/><br/>Example 1:<br/><br/>Input: nums = [8,3,9,3,8], k = 2<br/>Output: 81<br/>Explanation: To get a score of 81, we can apply the following operations:<br/>- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.<br/>It can be proven that 81 is the highest score one can obtain.<br/><br/>Example 2:<br/><br/>Input: nums = [19,12,14,6,10,18], k = 3<br/>Output: 4788<br/>Explanation: To get a score of 4788, we can apply the following operations: <br/>- Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.<br/>- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.<br/>It can be proven that 4788 is the highest score one can obtain.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length == n &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^5<br/>1 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9) </td>
<td>public class Solution {<br/>    public int maximumScore(List&lt;Integer&gt; nums, int k) {<br/>/*You are given an array nums of n positive integers and an integer k.<br/><br/>Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:<br/><br/>Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.<br/>Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.<br/>Multiply your score by x.<br/>Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.<br/><br/>The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.<br/><br/>Return the maximum possible score after applying at most k operations.<br/><br/>Since the answer may be large, return it modulo 10^9 + 7.<br/><br/>Example 1:<br/><br/>Input: nums = [8,3,9,3,8], k = 2<br/>Output: 81<br/>Explanation: To get a score of 81, we can apply the following operations:<br/>- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.<br/>It can be proven that 81 is the highest score one can obtain.<br/><br/>Example 2:<br/><br/>Input: nums = [19,12,14,6,10,18], k = 3<br/>Output: 4788<br/>Explanation: To get a score of 4788, we can apply the following operations: <br/>- Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.<br/>- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.<br/>It can be proven that 4788 is the highest score one can obtain.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length == n &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^5<br/>1 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9).<br/>*/</td>
<td>Public Class Solution {<br/>    Public Int Maximumscore(list&lt;integer&gt; Nums, Int K) {<br/>        Int N = Nums.size();<br/>        Int[] Primes = New Int[n];<br/>        For (Int I = 0; I &lt; N; I++) {<br/>            Primes[i] = Primefactors(nums.get(i));<br/>            If (Primes[i] == 0) Primes[i] = 1;<br/>            //System.out.println(primes[i]);<br/>        }<br/>        Int[][] Dp = New Int[n][k + 1];<br/>        For (Int I = 0; I &lt; N; I++) {<br/>            Dp[i][0] = 1;<br/>        }<br/>        For (Int I = 1; I &lt;= K; I++) {<br/>            For (Int J = 0; J &lt; N; J++) {<br/>                Dp[j][i] = Math.max(dp[j][i - 1], Dp[j - 1][i - 1] * Primes[j]);<br/>            }<br/>        }<br/>        Return Dp[n - 1][k];<br/>        <br/>    }<br/>    <br/>    Public Int Primefactors(int N) {<br/>        Int Count = 0;<br/>        For (Int I = 2; I &lt;= N / I; I++) {<br/>            While (N % I == 0) {<br/>                N /= I;<br/>                Count++;<br/>            }<br/>        }<br/>        If (N &gt; 1) Count++;<br/>        Return Count;<br/>    }<br/>    <br/>}</td>
<td>Class Solution {<br/>    Static Final Int Mod = 1000000007;<br/><br/>    Public Int Maximumscore(list&lt;integer&gt; Nums, Int K) {<br/>        Int N = Nums.size();<br/><br/>        Int Upper = Collections.max(nums) + 1;<br/><br/>        Boolean[] Prime = New Boolean[upper];<br/>        Int[] Primescore = New Int[upper];<br/>        Arrays.fill(prime, True);<br/>        Prime[0] = Prime[1] = False;<br/>        For (Int I = 2; I &lt; Upper; I++) {<br/>            If (Prime[i]) {<br/>                For (Int J = I; J &lt; Upper; J += I) {<br/>                    Primescore[j]++;<br/>                    Prime[j] = False;<br/>                }<br/>            }<br/>        }<br/><br/>        Int[] Nextgreaterelement = New Int[n];<br/>        Arrays.fill(nextgreaterelement, N);<br/>        Stack&lt;integer&gt; S = New Stack&lt;&gt;();<br/>        For (Int I = N - 1; I &gt;= 0; I--) {<br/>            While (!S.empty() &amp;&amp; Primescore[nums.get(i)] &gt;= Primescore[nums.get(s.peek())]) {<br/>                S.pop();<br/>            }<br/>            Nextgreaterelement[i] = S.empty() ? N : S.peek();<br/>            S.push(i);<br/>        }<br/><br/>        Int[] Prevgreaterorequalelement = New Int[n];<br/>        Arrays.fill(prevgreaterorequalelement, -1);<br/>        S = New Stack&lt;&gt;();<br/>        For (Int I = 0; I &lt; N; I++) {<br/>            While (!S.empty() &amp;&amp; Primescore[nums.get(i)] &gt; Primescore[nums.get(s.peek())]) {<br/>                S.pop();<br/>            }<br/>            Prevgreaterorequalelement[i] = S.empty() ? -1 : S.peek();<br/>            S.push(i);<br/>        }<br/><br/>        Int Res = 1;<br/>        Int[][] Tuples = New Int[n][2];<br/>        For (Int I = 0; I &lt; N; I++) {<br/>            Tuples[i][0] = Nums.get(i);<br/>            Tuples[i][1] = I;<br/>        }<br/>        Arrays.sort(tuples, New Comparator&lt;int[]&gt;() {<br/>            Public Int Compare(int[] A, Int[] B) {<br/>                Return B[0] - A[0];<br/>            }<br/>        });<br/>        For (Int I = 0; I &lt; N; I++) {<br/>            Int Num = Tuples[i][0];<br/>            Int Idx = Tuples[i][1];<br/>            Int Operations = Math.min((idx - Prevgreaterorequalelement[idx]) * (Nextgreaterelement[idx] - Idx), K);<br/>            Res = (Int)((1l * Res * Pow(num, Operations)) % Mod);<br/>            K -= Operations;<br/>            If (K == 0) {<br/>                Return Res;<br/>            }<br/>        }<br/><br/>        Return Res;<br/>    }<br/><br/>    Public Int Pow(int X, Int N) {<br/>        Int Res = 1;<br/>        While (N &gt; 0) {<br/>            If (N % 2 == 1) {<br/>                Res = (Int)((1l * Res * X) % Mod);<br/>            }<br/>            X = (Int)((1l * X * X) % Mod);<br/>            N /= 2;<br/>        }<br/>        Return Res;<br/>    }<br/>}</td>
</tr>
<tr>
<td align="right">68</td>
<td align="right">5</td>
<td>Python</td>
<td>hard</td>
<td>CodeWhisperer</td>
<td>IDE Extension</td>
<td>You are given an array nums of n positive integers and an integer k.<br/><br/>Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:<br/><br/>Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.<br/>Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.<br/>Multiply your score by x.<br/>Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.<br/><br/>The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.<br/><br/>Return the maximum possible score after applying at most k operations.<br/><br/>Since the answer may be large, return it modulo 10^9 + 7.<br/><br/>Example 1:<br/><br/>Input: nums = [8,3,9,3,8], k = 2<br/>Output: 81<br/>Explanation: To get a score of 81, we can apply the following operations:<br/>- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.<br/>It can be proven that 81 is the highest score one can obtain.<br/><br/>Example 2:<br/><br/>Input: nums = [19,12,14,6,10,18], k = 3<br/>Output: 4788<br/>Explanation: To get a score of 4788, we can apply the following operations: <br/>- Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.<br/>- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.<br/>It can be proven that 4788 is the highest score one can obtain.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length == n &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^5<br/>1 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9) </td>
<td>class Solution:<br/>    def maximumScore(self, nums: List[int], k: int) -&gt; int:<br/>&quot;&quot;&quot;You are given an array nums of n positive integers and an integer k.<br/><br/>Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:<br/><br/>Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.<br/>Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.<br/>Multiply your score by x.<br/>Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.<br/><br/>The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.<br/><br/>Return the maximum possible score after applying at most k operations.<br/><br/>Since the answer may be large, return it modulo 10^9 + 7.<br/><br/>Example 1:<br/><br/>Input: nums = [8,3,9,3,8], k = 2<br/>Output: 81<br/>Explanation: To get a score of 81, we can apply the following operations:<br/>- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.<br/>It can be proven that 81 is the highest score one can obtain.<br/><br/>Example 2:<br/><br/>Input: nums = [19,12,14,6,10,18], k = 3<br/>Output: 4788<br/>Explanation: To get a score of 4788, we can apply the following operations: <br/>- Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.<br/>- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.<br/>It can be proven that 4788 is the highest score one can obtain.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length == n &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^5<br/>1 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9) &quot;&quot;&quot;</td>
<td>Class Solution:<br/>    Def Maximumscore(self, Nums: List[int], K: Int) -&gt; Int:<br/>        Def Prime(n):<br/>            If N == 1:<br/>                Return False<br/>            For I In Range(2, Int(n**0.5)+1):<br/>                If N % I == 0:<br/>                    Return False<br/>            Return True<br/>        Ans = 1<br/>        For I In Range(k, -1, -1):<br/>            If Prime(nums[i]):<br/>                Ans *= Nums[i]<br/>        For I In Range(k+1, Len(nums)):<br/>            If Prime(nums[i]):<br/>                Ans *= Nums[i]<br/>        Return Ans % (10**9 + 7)</td>
<td>Class Solution: <br/>    Mod = 1000000007<br/><br/>    Def Maximumscore(self, Nums: List[int], K: Int) -&gt; Int:<br/>        N = Len(nums)<br/><br/>        Upper = Max(nums) + 1<br/><br/>        Prime = [True]*upper<br/>        Prime[0] = Prime[1] = False<br/>        Primescore = [0]*upper<br/>        For I In Range(2, Upper):<br/>            If Prime[i]:<br/>                For J In Range(i, Upper, I):<br/>                    Primescore[j] += 1<br/>                    Prime[j] = False<br/><br/>        Nextgreaterelement = [N]*n<br/>        S = []<br/>        For I In Range(n - 1, -1, -1):<br/>            While S And Primescore[nums[i]] &gt;= Primescore[nums[s[-1]]]:<br/>                S.pop()<br/>            Nextgreaterelement[i] = S[-1] If S Else N<br/>            S.append(i)<br/><br/>        Prevgreaterorequalelement = [-1]*n<br/>        S = []<br/>        For I In Range(n):<br/>            While S And Primescore[nums[i]] &gt; Primescore[nums[s[-1]]]:<br/>                S.pop()<br/>            Prevgreaterorequalelement[i] = S[-1] If S Else -1<br/>            S.append(i)<br/><br/>        Res = 1<br/>        Tuples = [[Nums[i], I] For I In Range(n)]<br/>        Tuples.sort(reverse=true)<br/>        For Num, Idx In Tuples:<br/>            Operations = Min((idx - Prevgreaterorequalelement[idx]) * (Nextgreaterelement[idx] - Idx), K)<br/>            Res = (Res * Self.pow(num, Operations)) % Self.mod<br/>            K -= Operations<br/>            If K == 0:<br/>                Return Res<br/><br/>        Return Res<br/><br/>    Def Pow(self, X: Int, N: Int) -&gt; Int:<br/>        Res = 1<br/>        While N &gt; 0:<br/>            If N % 2 == 1:<br/>                Res = (Res * X) % Self.mod<br/>            X = (X * X) % Self.mod<br/>            N //= 2<br/>        Return Res</td>
</tr>
<tr>
<td align="right">69</td>
<td align="right">5</td>
<td>C++</td>
<td>hard</td>
<td>CodeWhisperer</td>
<td>IDE Extension</td>
<td>You are given an array nums of n positive integers and an integer k.<br/><br/>Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:<br/><br/>Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.<br/>Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.<br/>Multiply your score by x.<br/>Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.<br/><br/>The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.<br/><br/>Return the maximum possible score after applying at most k operations.<br/><br/>Since the answer may be large, return it modulo 10^9 + 7.<br/><br/>Example 1:<br/><br/>Input: nums = [8,3,9,3,8], k = 2<br/>Output: 81<br/>Explanation: To get a score of 81, we can apply the following operations:<br/>- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.<br/>It can be proven that 81 is the highest score one can obtain.<br/><br/>Example 2:<br/><br/>Input: nums = [19,12,14,6,10,18], k = 3<br/>Output: 4788<br/>Explanation: To get a score of 4788, we can apply the following operations: <br/>- Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.<br/>- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.<br/>It can be proven that 4788 is the highest score one can obtain.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length == n &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^5<br/>1 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9) </td>
<td>class Solution {<br/>public:<br/>    int maximumScore(vector&lt;int&gt;&amp; nums, int k) {<br/>/*You are given an array nums of n positive integers and an integer k.<br/><br/>Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:<br/><br/>Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.<br/>Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.<br/>Multiply your score by x.<br/>Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.<br/><br/>The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.<br/><br/>Return the maximum possible score after applying at most k operations.<br/><br/>Since the answer may be large, return it modulo 10^9 + 7.<br/><br/>Example 1:<br/><br/>Input: nums = [8,3,9,3,8], k = 2<br/>Output: 81<br/><br/>Example 2:<br/><br/>Input: nums = [19,12,14,6,10,18], k = 3<br/>Output: 4788<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length == n &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^5<br/>1 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9) */</td>
<td>Class Solution {<br/>Public:<br/>    Int Maximumscore(vector&lt;int&gt;&amp; Nums, Int K) {<br/>        Int N = Nums.size();<br/>        Int L = K, R = K;<br/>        Int Score = 1;<br/>        Int Ans = 0;<br/>        While(l &gt;= 0 || R &lt; N){<br/>            If(l &lt; 0){<br/>                Score *= Nums[r++];<br/>                Ans = Max(ans, Score);<br/>                Continue;<br/>            }<br/>            If(r == N){<br/>                Score *= Nums[l--];<br/>                Ans = Max(ans, Score);<br/>                Continue;<br/>            }<br/>            If(nums[l] &lt; Nums[r]){<br/>                Score *= Nums[l--];<br/>                Ans = Max(ans, Score);<br/>            }<br/>            Else{<br/>                Score *= Nums[r++];<br/>                Ans = Max(ans, Score);<br/>            }<br/>        }<br/>        Return Ans;<br/>    }<br/>};</td>
<td>Class Solution {<br/>Public:<br/>    Const Int Mod = 1000000007;<br/><br/>    Int Maximumscore(vector&lt;int&gt;&amp; Nums, Int K) {<br/>        Int N = Nums.size();<br/><br/>        Int Upper = *Max_element(nums.begin(), Nums.end()) + 1;<br/><br/>        Vector&lt;bool&gt; Prime(upper, True);<br/>        Prime[0] = Prime[1] = False;<br/>        Vector&lt;int&gt; Primescore(upper, 0);<br/>        For (Int I = 2; I &lt; Upper; I++) {<br/>            If (Prime[i]) {<br/>                For (Int J = I; J &lt; Upper; J += I) {<br/>                    Primescore[j]++;<br/>                    Prime[j] = False;<br/>                }<br/>            }<br/>        }<br/><br/>        Vector&lt;int&gt; Nextgreaterelement(n, N);<br/>        Stack&lt;int&gt; S;<br/>        For (Int I = N - 1; I &gt;= 0; I--) {<br/>            While (!S.empty() &amp;&amp; Primescore[nums[i]] &gt;= Primescore[nums[s.top()]]) {<br/>                S.pop();<br/>            }<br/>            Nextgreaterelement[i] = S.empty() ? N : S.top();<br/>            S.push(i);<br/>        }<br/><br/>        Vector&lt;int&gt; Prevgreaterorequalelement(n, -1);<br/>        S = Stack&lt;int&gt;();<br/>        For (Int I = 0; I &lt; N; I++) {<br/>            While (!S.empty() &amp;&amp; Primescore[nums[i]] &gt; Primescore[nums[s.top()]]) {<br/>                S.pop();<br/>            }<br/>            Prevgreaterorequalelement[i] = S.empty() ? -1 : S.top();<br/>            S.push(i);<br/>        }<br/><br/>        Int Res = 1;<br/>        Vector&lt;pair&lt;int, Int&gt;&gt; Tuples(n);<br/>        For (Int I = 0; I &lt; N; I++) {<br/>            Tuples[i].first = Nums[i];<br/>            Tuples[i].second = I;<br/>        }<br/>        Sort(tuples.rbegin(), Tuples.rend());<br/>        For (Const Auto&amp; [Num, I] : Tuples) {<br/>            Int Operations = Min((i - Prevgreaterorequalelement[i]) * (Nextgreaterelement[i] - I), K);<br/>            Res = (Int)((1l * Res * Pow(num, Operations)) % Mod);<br/>            K -= Operations;<br/>            If (K == 0) {<br/>                Return Res;<br/>            }<br/>        }<br/><br/>        Return Res;<br/>    }<br/><br/>    Int Pow(int X, Int N) {<br/>        Int Res = 1;<br/>        While (N &gt; 0) {<br/>            If (N % 2 == 1) {<br/>                Res = (Int)((1l * Res * X) % Mod);<br/>            }<br/>            X = (Int)((1l * X * X) % Mod);<br/>            N /= 2;<br/>        }<br/>        Return Res;<br/>    }<br/>};</td>
</tr>
<tr>
<td align="right">70</td>
<td align="right">6</td>
<td>Java</td>
<td>hard</td>
<td>CodeWhisperer</td>
<td>IDE Extension</td>
<td>You are given a 0-indexed 2D integer array items of length n and an integer k.<br/><br/>items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.<br/><br/>Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.<br/><br/>Your task is to find the maximum elegance from all subsequences of size k in items.<br/><br/>Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.<br/><br/>Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.<br/><br/>Example 1:<br/><br/>Input: items = [[3,2],[5,1],[10,1]], k = 2<br/>Output: 17<br/>Explanation: In this example, we have to select a subsequence of size 2.<br/>We can select items[0] = [3,2] and items[2] = [10,1].<br/>The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].<br/>Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. <br/><br/>Example 2:<br/><br/>Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3<br/>Output: 19<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. <br/>The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. <br/>Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.<br/><br/>Example 3:<br/><br/>Input: items = [[1,1],[2,1],[3,1]], k = 3<br/>Output: 7<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We should select all the items. <br/>The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. <br/>Hence, the maximum elegance is 6 + 1^2 = 7.  <br/> <br/>Constraints:<br/><br/>1 &lt;= items.length == n &lt;= 10^5<br/>items[i].length == 2<br/>items[i][0] == profit_i<br/>items[i][1] == category_i<br/>1 &lt;= profit_i &lt;= 10^9<br/>1 &lt;= category_i &lt;= n <br/>1 &lt;= k &lt;= n </td>
<td>public class Solution {<br/>    public int findMaximumElegance(int[][] items, int k) {<br/>/*<br/> * You are given a 0-indexed 2D integer array items of length n and an integer k.<br/><br/>items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.<br/><br/>Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.<br/><br/>Your task is to find the maximum elegance from all subsequences of size k in items.<br/><br/>Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.<br/><br/>Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.<br/><br/>Example 1:<br/><br/>Input: items = [[3,2],[5,1],[10,1]], k = 2<br/>Output: 17<br/>Explanation: In this example, we have to select a subsequence of size 2.<br/>We can select items[0] = [3,2] and items[2] = [10,1].<br/>The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].<br/>Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. <br/><br/>Example 2:<br/><br/>Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3<br/>Output: 19<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. <br/>The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. <br/>Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.<br/><br/>Example 3:<br/><br/>Input: items = [[1,1],[2,1],[3,1]], k = 3<br/>Output: 7<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We should select all the items. <br/>The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. <br/>Hence, the maximum elegance is 6 + 1^2 = 7.  <br/> <br/>Constraints:<br/><br/>1 &lt;= items.length == n &lt;= 10^5<br/>items[i].length == 2<br/>items[i][0] == profit_i<br/>items[i][1] == category_i<br/>1 &lt;= profit_i &lt;= 10^9<br/>1 &lt;= category_i &lt;= n <br/>1 &lt;= k &lt;= n<br/>*/</td>
<td>Public Class Solution {<br/>    Public Int Findmaximumelegance(int[][] Items, Int K) {<br/>        Int N = Items.length;<br/>        Int[] Category = New Int[n];<br/>        For (Int I = 0; I &lt; N; I++) {<br/>            Category[i] = Items[i][1];<br/>        }<br/>        Int[] Count = New Int[n + 1];<br/>        For (Int I = 0; I &lt; N; I++) {<br/>            Count[category[i]]++;<br/>        }<br/>        For (Int I = 1; I &lt;= N; I++) {<br/>            Count[i] += Count[i - 1];<br/>        }<br/>        Int[] Dp = New Int[n + 1];<br/>        For (Int I = 0; I &lt; N; I++) {<br/>            Int Index = Count[category[i]];<br/>            Dp[index] = Math.max(dp[index], Dp[index - 1] + Items[i][0]);<br/>        }<br/>        Return Dp[n];<br/>        <br/>    }<br/><br/>}</td>
<td>Class Solution {<br/>    Public Long Findmaximumelegance(int[][] A, Int K) {<br/>        Arrays.sort(a, (A, B) -&gt; B[0] - A[0]);<br/>        Long Res = 0, Cur = 0;<br/>        List&lt;integer&gt; Dup = New Arraylist&lt;&gt;();<br/>        Set&lt;integer&gt; Seen = New Hashset&lt;&gt;();<br/>        For (Int I = 0; I &lt; A.length; ++I) {<br/>            If (I &lt; K) {<br/>                If (Seen.contains(a[i][1])) {<br/>                    Dup.add(a[i][0]);<br/>                }<br/>                Cur += A[i][0];<br/>            } Else If (!Seen.contains(a[i][1])) {<br/>                If (Dup.isempty()) Break;<br/>                Cur += A[i][0] - Dup.remove(dup.size() - 1);<br/>            }<br/>            Seen.add(a[i][1]);<br/>            Res = Math.max(res, Cur + 1l * Seen.size() * Seen.size());<br/>        }<br/>        Return Res;<br/>    }<br/>}</td>
</tr>
<tr>
<td align="right">71</td>
<td align="right">6</td>
<td>Python</td>
<td>hard</td>
<td>CodeWhisperer</td>
<td>IDE Extension</td>
<td>You are given a 0-indexed 2D integer array items of length n and an integer k.<br/><br/>items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.<br/><br/>Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.<br/><br/>Your task is to find the maximum elegance from all subsequences of size k in items.<br/><br/>Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.<br/><br/>Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.<br/><br/>Example 1:<br/><br/>Input: items = [[3,2],[5,1],[10,1]], k = 2<br/>Output: 17<br/>Explanation: In this example, we have to select a subsequence of size 2.<br/>We can select items[0] = [3,2] and items[2] = [10,1].<br/>The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].<br/>Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. <br/><br/>Example 2:<br/><br/>Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3<br/>Output: 19<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. <br/>The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. <br/>Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.<br/><br/>Example 3:<br/><br/>Input: items = [[1,1],[2,1],[3,1]], k = 3<br/>Output: 7<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We should select all the items. <br/>The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. <br/>Hence, the maximum elegance is 6 + 1^2 = 7.  <br/> <br/>Constraints:<br/><br/>1 &lt;= items.length == n &lt;= 10^5<br/>items[i].length == 2<br/>items[i][0] == profit_i<br/>items[i][1] == category_i<br/>1 &lt;= profit_i &lt;= 10^9<br/>1 &lt;= category_i &lt;= n <br/>1 &lt;= k &lt;= n </td>
<td>class Solution:<br/>    def findMaximumElegance(self, items: List[List[int]], k: int) -&gt; int:<br/>&quot;&quot;&quot;You are given a 0-indexed 2D integer array items of length n and an integer k.<br/><br/>items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.<br/><br/>Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.<br/><br/>Your task is to find the maximum elegance from all subsequences of size k in items.<br/><br/>Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.<br/><br/>Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.<br/><br/>Example 1:<br/><br/>Input: items = [[3,2],[5,1],[10,1]], k = 2<br/>Output: 17<br/>Explanation: In this example, we have to select a subsequence of size 2.<br/>We can select items[0] = [3,2] and items[2] = [10,1].<br/>The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].<br/>Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. <br/><br/>Example 2:<br/><br/>Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3<br/>Output: 19<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. <br/>The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. <br/>Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.<br/><br/>Example 3:<br/><br/>Input: items = [[1,1],[2,1],[3,1]], k = 3<br/>Output: 7<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We should select all the items. <br/>The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. <br/>Hence, the maximum elegance is 6 + 1^2 = 7.  <br/> <br/>Constraints:<br/><br/>1 &lt;= items.length == n &lt;= 10^5<br/>items[i].length == 2<br/>items[i][0] == profit_i<br/>items[i][1] == category_i<br/>1 &lt;= profit_i &lt;= 10^9<br/>1 &lt;= category_i &lt;= n <br/>1 &lt;= k &lt;= n &quot;&quot;&quot;</td>
<td>Class Solution:<br/>    Def Findmaximumelegance(self, Items: List[list[int]], K: Int) -&gt; Int:<br/>        Items.sort(key = Lambda X: X[1])<br/>        Ans = 0<br/>        For I In Range(k):<br/>            Ans += Items[i][0]<br/>        Return Ans + (K * (K - 1) // 2) * Items[k - 1][1]</td>
<td>Class Solution:<br/>    Def Findmaximumelegance(self, Items: List[list[int]], K: Int) -&gt; Int:<br/>        Items = Sorted(items, Key=lambda V: -V[0])<br/>        Res = Cur = 0<br/>        A = []<br/>        Seen = Set()<br/>        For I, (P, C) In Enumerate(items):<br/>            If I &lt; K:<br/>                If C In Seen:<br/>                    A.append(p)<br/>                Cur += P<br/>            Elif C Not In Seen:<br/>                If Not A: Break<br/>                Cur += P - A.pop()<br/>            Seen.add(c)<br/>            Res = Max(res, Cur + Len(seen) * Len(seen))<br/>        Return Res</td>
</tr>
<tr>
<td align="right">72</td>
<td align="right">6</td>
<td>C++</td>
<td>hard</td>
<td>CodeWhisperer</td>
<td>IDE Extension</td>
<td>You are given a 0-indexed 2D integer array items of length n and an integer k.<br/><br/>items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.<br/><br/>Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.<br/><br/>Your task is to find the maximum elegance from all subsequences of size k in items.<br/><br/>Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.<br/><br/>Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.<br/><br/>Example 1:<br/><br/>Input: items = [[3,2],[5,1],[10,1]], k = 2<br/>Output: 17<br/>Explanation: In this example, we have to select a subsequence of size 2.<br/>We can select items[0] = [3,2] and items[2] = [10,1].<br/>The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].<br/>Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. <br/><br/>Example 2:<br/><br/>Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3<br/>Output: 19<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. <br/>The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. <br/>Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.<br/><br/>Example 3:<br/><br/>Input: items = [[1,1],[2,1],[3,1]], k = 3<br/>Output: 7<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We should select all the items. <br/>The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. <br/>Hence, the maximum elegance is 6 + 1^2 = 7.  <br/> <br/>Constraints:<br/><br/>1 &lt;= items.length == n &lt;= 10^5<br/>items[i].length == 2<br/>items[i][0] == profit_i<br/>items[i][1] == category_i<br/>1 &lt;= profit_i &lt;= 10^9<br/>1 &lt;= category_i &lt;= n <br/>1 &lt;= k &lt;= n </td>
<td>/*You are given a 0-indexed 2D integer array items of length n and an integer k.<br/><br/>items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.<br/><br/>Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.<br/><br/>Your task is to find the maximum elegance from all subsequences of size k in items.<br/><br/>Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.<br/><br/>Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.<br/><br/>Example 1:<br/><br/>Input: items = [[3,2],[5,1],[10,1]], k = 2<br/>Output: 17<br/>Explanation: In this example, we have to select a subsequence of size 2.<br/>We can select items[0] = [3,2] and items[2] = [10,1].<br/>The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].<br/>Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. <br/><br/>Example 2:<br/><br/>Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3<br/>Output: 19<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. <br/>The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. <br/>Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.<br/><br/>Example 3:<br/><br/>Input: items = [[1,1],[2,1],[3,1]], k = 3<br/>Output: 7<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We should select all the items. <br/>The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. <br/>Hence, the maximum elegance is 6 + 1^2 = 7.  <br/><br/>Constraints:<br/><br/>1 &lt;= items.length == n &lt;= 10^5<br/>items[i].length == 2<br/>items[i][0] == profit_i<br/>items[i][1] == category_i<br/>1 &lt;= profit_i &lt;= 10^9<br/>1 &lt;= category_i &lt;= n <br/>1 &lt;= k &lt;= n*/<br/>class Solution {<br/>public:<br/>    long long findMaximumElegance(vector&lt;vector&lt;int&gt;&gt;&amp; items, int k) {</td>
<td>Class Solution {<br/>Public:<br/>    Long Long Findmaximumelegance(vector&lt;vector&lt;int&gt;&gt;&amp; Items, Int K) {<br/>        Int N=items.size();<br/>        Vector&lt;long Long&gt;profit(n);<br/>        Vector&lt;long Long&gt;category(n);<br/>        For(int I=0;i&lt;n;i++){<br/>            Profit[i]=items[i][0];<br/>            Category[i]=items[i][1];<br/>        }<br/>        Sort(profit.begin(),profit.end());<br/>        Sort(category.begin(),category.end());<br/>        Long Long Ans=0;<br/>        Long Long Max_profit=0;<br/>        Long Long Max_category=0;<br/>        For(int I=0;i&lt;n;i++){<br/>            If(i&lt;k){<br/>                Max_profit+=profit[i];<br/>                Max_category+=category[i];<br/>                Ans=max(ans,max_profit+max_category*max_category);<br/>                Continue;<br/>            }<br/>            Max_profit-=profit[i-k];<br/>            Max_profit+=profit[i];<br/>            Max_category-=category[i-k];<br/>            Max_category+=category[i];<br/>            Ans=max(ans,max_profit+max_category*max_category);<br/>        }<br/>        Return Ans;<br/>    }<br/>};</td>
<td>Class Solution {<br/>Public:<br/>    Long Long Findmaximumelegance(vector&lt;vector&lt;int&gt;&gt;&amp; A, Int K) {<br/>        Sort(a.begin(), A.end(), [](Const Vector&lt;int&gt;&amp; A, Const Vector&lt;int&gt;&amp; B) {<br/>            Return A[0] &gt; B[0];<br/>        });<br/>        Long Long Res = 0, Cur = 0;<br/>        Vector&lt;int&gt; Dup;<br/>        Unordered_set&lt;int&gt; Seen;<br/>        For (Int I = 0; I &lt; A.size(); ++I) {<br/>            If (I &lt; K) {<br/>                If (Seen.count(a[i][1])) {<br/>                    Dup.push_back(a[i][0]);<br/>                }<br/>                Cur += A[i][0];<br/>            } Else If (Seen.find(a[i][1]) == Seen.end()) {<br/>                If (Dup.empty()) Break;<br/>                Cur += A[i][0] - Dup.back();<br/>                Dup.pop_back();<br/>            }<br/>            Seen.insert(a[i][1]);<br/>            Res = Fmax(res, Cur + 1l * Seen.size() * Seen.size());<br/>        }<br/>        Return Res;<br/>    }<br/>};</td>
</tr>
<tr>
<td align="right">73</td>
<td align="right">1</td>
<td>Java</td>
<td>easy</td>
<td>GitHub Copilot</td>
<td>IDE Extension</td>
<td>You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.<br/><br/>Return the maximum sum or -1 if no such pair exists.<br/><br/>Example 1:<br/><br/>Input: nums = [51,71,17,24,42]<br/>Output: 88<br/>Explanation: <br/>For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. <br/>For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.<br/>It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.<br/><br/>Example 2:<br/><br/>Input: nums = [1,2,3,4]<br/>Output: -1<br/>Explanation: No pair exists in nums with equal maximum digits.<br/><br/>Constraints:<br/><br/>2 &lt;= nums.length &lt;= 100<br/>1 &lt;= nums[i] &lt;= 10^4 </td>
<td>public class Solution {<br/>    public int maxSum(int[] nums) {<br/>        /*<br/>         * You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.<br/><br/>Return the maximum sum or -1 if no such pair exists.<br/><br/>Example 1:<br/><br/>Input: nums = [51,71,17,24,42]<br/>Output: 88<br/>Explanation: <br/>For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. <br/>For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.<br/>It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.<br/><br/>Example 2:<br/><br/>Input: nums = [1,2,3,4]<br/>Output: -1<br/>Explanation: No pair exists in nums with equal maximum digits.<br/><br/>Constraints:<br/><br/>2 &lt;= nums.length &lt;= 100<br/>1 &lt;= nums[i] &lt;= 10^4<br/>         */</td>
<td>Public Class Solution {<br/>    Public Int Maxsum(int[] Nums) {<br/>        Int Max = -1;<br/>        For(int I = 0; I &lt; Nums.length; I++){<br/>            For(int J = I+1; J &lt; Nums.length;j++){<br/>                If(max &lt; Nums[i] + Nums[j] &amp;&amp; Maxdigit(nums[i]) == Maxdigit(nums[j])){<br/>                    Max = Nums[i] + Nums[j];<br/>                }<br/>            }<br/>        }<br/>        Return Max;<br/>    }<br/>    Public Int Maxdigit(int Num){<br/>        Int Max = 0;<br/>        While(num &gt; 0){<br/>            Max = Math.max(max, Num % 10);<br/>            Num /= 10;<br/>        }<br/>        Return Max;<br/>    }<br/>}</td>
<td>Class Solution {<br/>    Public Int Maxsum(int[] Nums) {<br/>    Int Ans = -1;<br/>    Map&lt;integer,list&lt;integer&gt;&gt; Ump = New Hashmap&lt;&gt;();<br/>    For(int I = 0; I &lt; Nums.length; ++I){<br/>        Int T = Nums[i], Maxdigit = 0;<br/>        While(t != 0){ //Evaluate Max Digit In The Number<br/>            Maxdigit = Math.max(t%10, Maxdigit);<br/>            T = T/10;<br/>        }<br/>        If(!ump.containskey(maxdigit)) Ump.put(maxdigit, New Arraylist&lt;&gt;());<br/>        Ump.get(maxdigit).add(nums[i]); // Add The Number To The Map <br/>    }<br/>    For(map.entry&lt;integer, List&lt;integer&gt;&gt; Entry: Ump.entryset()){<br/>        Entry.getvalue().sort(comparator.reverseorder()); //To Find Max Two Number In Each Max Digit <br/>        If(entry.getvalue().size() &gt;= 2) Ans = Math.max(ans, Entry.getvalue().get(0) + Entry.getvalue().get(1)); //Sum Max Two Number And Take Max<br/>    }<br/>    Return Ans;<br/>    }<br/>}</td>
</tr>
<tr>
<td align="right">74</td>
<td align="right">1</td>
<td>Python</td>
<td>easy</td>
<td>GitHub Copilot</td>
<td>IDE Extension</td>
<td>You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.<br/><br/>Return the maximum sum or -1 if no such pair exists.<br/><br/>Example 1:<br/><br/>Input: nums = [51,71,17,24,42]<br/>Output: 88<br/>Explanation: <br/>For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. <br/>For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.<br/>It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.<br/><br/>Example 2:<br/><br/>Input: nums = [1,2,3,4]<br/>Output: -1<br/>Explanation: No pair exists in nums with equal maximum digits.<br/><br/>Constraints:<br/><br/>2 &lt;= nums.length &lt;= 100<br/>1 &lt;= nums[i] &lt;= 10^4 </td>
<td>class Solution:<br/>    def maxSum(self, nums: List[int]) -&gt; int:<br/>&quot;&quot;&quot;You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.<br/><br/>Return the maximum sum or -1 if no such pair exists.<br/><br/>Example 1:<br/><br/>Input: nums = [51,71,17,24,42]<br/>Output: 88<br/>Explanation: <br/>For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. <br/>For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.<br/>It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.<br/><br/>Example 2:<br/><br/>Input: nums = [1,2,3,4]<br/>Output: -1<br/>Explanation: No pair exists in nums with equal maximum digits.<br/><br/>Constraints:<br/><br/>2 &lt;= nums.length &lt;= 100<br/>1 &lt;= nums[i] &lt;= 10^4&quot;&quot;&quot;</td>
<td>Class Solution:<br/>    Def Maxsum(self, Nums: List[int]) -&gt; Int:<br/>        Maxsum = -1<br/>        Maxdigit = [0] * 10<br/>        For Num In Nums:<br/>            Maxdigit[int(str(num)[0])] = Max(maxdigit[int(str(num)[0])], Num)<br/>        For I In Range(10):<br/>            <br/>            For J In Range(i, 10):<br/>                If Maxdigit[i] And Maxdigit[j]:<br/>                    Maxsum = Max(maxsum, Maxdigit[i] + Maxdigit[j])<br/>        Return Maxsum</td>
<td>Class Solution:<br/>    Def Maxsum(self, Nums: List[int]) -&gt; Int:<br/>        Max_by_digit = Defaultdict(int)<br/>        Max_sum = -1<br/><br/>        For Num In Nums:<br/>            Digit = Max(str(num))<br/><br/>            If Digit In Max_by_digit:<br/>                Max_sum = Max(max_sum, Max_by_digit[digit] + Num)<br/><br/>            Max_by_digit[digit] = Max(max_by_digit[digit], Num)<br/><br/>        Return Max_sum</td>
</tr>
<tr>
<td align="right">75</td>
<td align="right">1</td>
<td>C++</td>
<td>easy</td>
<td>GitHub Copilot</td>
<td>IDE Extension</td>
<td>You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.<br/><br/>Return the maximum sum or -1 if no such pair exists.<br/><br/>Example 1:<br/><br/>Input: nums = [51,71,17,24,42]<br/>Output: 88<br/>Explanation: <br/>For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. <br/>For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.<br/>It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.<br/><br/>Example 2:<br/><br/>Input: nums = [1,2,3,4]<br/>Output: -1<br/>Explanation: No pair exists in nums with equal maximum digits.<br/><br/>Constraints:<br/><br/>2 &lt;= nums.length &lt;= 100<br/>1 &lt;= nums[i] &lt;= 10^4 </td>
<td>class Solution {<br/>public:<br/>    int maxSum(vector&lt;int&gt;&amp; nums) {<br/>/*You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.<br/><br/>Return the maximum sum or -1 if no such pair exists.<br/><br/>Example 1:<br/><br/>Input: nums = [51,71,17,24,42]<br/>Output: 88<br/><br/>Example 2:<br/><br/>Input: nums = [1,2,3,4]<br/>Output: -1<br/><br/>Constraints:<br/><br/>2 &lt;= nums.length &lt;= 100<br/>1 &lt;= nums[i] &lt;= 10^4*/</td>
<td>Class Solution {<br/>Public:<br/>    Int Maxsum(vector&lt;int&gt;&amp; Nums) {<br/>        Int N = Nums.size();<br/>        Int Maxsum = -1;<br/>        Unordered_map&lt;int, Int&gt; Mp;<br/>        For(int I = 0; I &lt; N; I++) {<br/>            Int Maxdigit = 0;<br/>            Int Temp = Nums[i];<br/>            While(temp) {<br/>                Maxdigit = Max(maxdigit, Temp % 10);<br/>                Temp /= 10;<br/>            }<br/>            If(mp.find(maxdigit) != Mp.end()) {<br/>                Maxsum = Max(maxsum, Mp[maxdigit] + Nums[i]);<br/>                Mp[maxdigit] = Max(mp[maxdigit], Nums[i]);<br/>            } Else {<br/>                Mp[maxdigit] = Nums[i];<br/>            }<br/>        }<br/>        Return Maxsum;<br/>    }<br/>};</td>
<td>Class Solution {<br/>    Public:<br/>        Int Maxsum(vector&lt;int&gt;&amp; Nums) {<br/>        Int Res = -1, Max_num[10] = {};<br/>        For (Auto Num : Nums) {<br/>            Int Max_d = 0;<br/>            For (Int V = Num; V; V /= 10)<br/>                Max_d = Max(max_d, V % 10);<br/>            If (Max_num[max_d])<br/>                Res = Max(res, Max_num[max_d] + Num);<br/>            Max_num[max_d] = Max(max_num[max_d], Num);<br/>        }<br/>        Return Res;<br/>    }<br/>};</td>
</tr>
<tr>
<td align="right">76</td>
<td align="right">2</td>
<td>Java</td>
<td>easy</td>
<td>GitHub Copilot</td>
<td>IDE Extension</td>
<td>Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.<br/><br/>You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.<br/><br/>Return the final string that will be present on your laptop screen.<br/><br/>Example 1:<br/><br/>Input: s = &quot;string&quot;<br/>Output: &quot;rtsng&quot;<br/>Explanation: <br/>After typing first character, the text on the screen is &quot;s&quot;.<br/>After the second character, the text is &quot;st&quot;. <br/>After the third character, the text is &quot;str&quot;.<br/>Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.<br/>After the fifth character, the text is &quot;rtsn&quot;. <br/>After the sixth character, the text is &quot;rtsng&quot;. <br/>Therefore, we return &quot;rtsng&quot;.<br/><br/>Example 2:<br/><br/>Input: s = &quot;poiinter&quot;<br/>Output: &quot;ponter&quot;<br/>Explanation: <br/>After the first character, the text on the screen is &quot;p&quot;.<br/>After the second character, the text is &quot;po&quot;. <br/>Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. <br/>Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.<br/>After the fifth character, the text is &quot;pon&quot;.<br/>After the sixth character, the text is &quot;pont&quot;. <br/>After the seventh character, the text is &quot;ponte&quot;. <br/>After the eighth character, the text is &quot;ponter&quot;. <br/>Therefore, we return &quot;ponter&quot;.<br/> <br/>Constraints:<br/><br/>1 &lt;= s.length &lt;= 100<br/>s consists of lowercase English letters.<br/>s[0] != &#39;i&#39;</td>
<td>public class Solution {<br/>    public String finalString(String s) {<br/>        /*<br/>         * Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.<br/><br/>You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.<br/><br/>Return the final string that will be present on your laptop screen.<br/><br/>Constraints:<br/><br/>1 &lt;= s.length &lt;= 100<br/>s consists of lowercase English letters.<br/>s[0] != &#39;i&#39;<br/><br/>*/</td>
<td>Public Class Solution {<br/>    Public String Finalstring(string S) {<br/>        Stringbuilder Sb = New Stringbuilder();<br/>        For (Int I = 0; I &lt; S.length(); I++) {<br/>            If (S.charat(i) == &#39;I&#39;) {<br/>                Sb.reverse();<br/>            } Else {<br/>                Sb.append(s.charat(i));<br/>            }<br/>        }<br/>        Return Sb.tostring();<br/>    }<br/>}</td>
<td>Class Solution {<br/>    Public String Finalstring(string S) {<br/>        Stringbuilder Nm=new Stringbuilder();<br/>        For(char C:s.tochararray())<br/>        {<br/>            If(c==&#39;i&#39;)<br/>            {<br/>                Nm.reverse();<br/>            }<br/>            Else<br/>            {<br/>                Nm.append(c);<br/>            }<br/>        }<br/>        Return Nm.tostring();<br/>    }<br/>}</td>
</tr>
<tr>
<td align="right">77</td>
<td align="right">2</td>
<td>Python</td>
<td>easy</td>
<td>GitHub Copilot</td>
<td>IDE Extension</td>
<td>Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.<br/><br/>You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.<br/><br/>Return the final string that will be present on your laptop screen.<br/><br/>Example 1:<br/><br/>Input: s = &quot;string&quot;<br/>Output: &quot;rtsng&quot;<br/>Explanation: <br/>After typing first character, the text on the screen is &quot;s&quot;.<br/>After the second character, the text is &quot;st&quot;. <br/>After the third character, the text is &quot;str&quot;.<br/>Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.<br/>After the fifth character, the text is &quot;rtsn&quot;. <br/>After the sixth character, the text is &quot;rtsng&quot;. <br/>Therefore, we return &quot;rtsng&quot;.<br/><br/>Example 2:<br/><br/>Input: s = &quot;poiinter&quot;<br/>Output: &quot;ponter&quot;<br/>Explanation: <br/>After the first character, the text on the screen is &quot;p&quot;.<br/>After the second character, the text is &quot;po&quot;. <br/>Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. <br/>Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.<br/>After the fifth character, the text is &quot;pon&quot;.<br/>After the sixth character, the text is &quot;pont&quot;. <br/>After the seventh character, the text is &quot;ponte&quot;. <br/>After the eighth character, the text is &quot;ponter&quot;. <br/>Therefore, we return &quot;ponter&quot;.<br/> <br/>Constraints:<br/><br/>1 &lt;= s.length &lt;= 100<br/>s consists of lowercase English letters.<br/>s[0] != &#39;i&#39;</td>
<td>class Solution:<br/>    def finalString(self, s: str) -&gt; str:<br/>&quot;&quot;&quot;You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.<br/><br/>Return the final string that will be present on your laptop screen.<br/><br/>Example 1:<br/><br/>Input: s = &quot;string&quot;<br/>Output: &quot;rtsng&quot;<br/>Explanation: <br/>After typing first character, the text on the screen is &quot;s&quot;.<br/>After the second character, the text is &quot;st&quot;. <br/>After the third character, the text is &quot;str&quot;.<br/>Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.<br/>After the fifth character, the text is &quot;rtsn&quot;. <br/>After the sixth character, the text is &quot;rtsng&quot;. <br/>Therefore, we return &quot;rtsng&quot;.<br/><br/>Example 2:<br/><br/>Input: s = &quot;poiinter&quot;<br/>Output: &quot;ponter&quot;<br/>Explanation: <br/>After the first character, the text on the screen is &quot;p&quot;.<br/>After the second character, the text is &quot;po&quot;. <br/>Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. <br/>Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.<br/>After the fifth character, the text is &quot;pon&quot;.<br/>After the sixth character, the text is &quot;pont&quot;. <br/>After the seventh character, the text is &quot;ponte&quot;. <br/>After the eighth character, the text is &quot;ponter&quot;. <br/>Therefore, we return &quot;ponter&quot;.<br/> <br/>Constraints:<br/><br/>1 &lt;= s.length &lt;= 100<br/>s consists of lowercase English letters.<br/>s[0] != &#39;i&#39;<br/>&quot;&quot;&quot;</td>
<td>Class Solution:<br/>    Def Finalstring(self, S: Str) -&gt; Str:<br/>        Stack = []<br/>        For I In Range(len(s)):<br/>            If S[i] == &#39;I&#39;:<br/>                Stack.reverse()<br/>            Else:<br/>                Stack.append(s[i])<br/>        Return &quot;&quot;.Join(stack)</td>
<td>Class Solution:<br/>    Def Finalstring(self, S: Str) -&gt; Str:<br/>        While &quot;I&quot; In S:<br/>            Index=s.index(&quot;i&quot;)<br/><br/>            #First Half And Second Half<br/>            First=s[:index][::-1]<br/>            Second=s[index+1:]<br/><br/>            S=&quot;&quot;.join([first,second])<br/>        Return S</td>
</tr>
<tr>
<td align="right">78</td>
<td align="right">2</td>
<td>C++</td>
<td>easy</td>
<td>GitHub Copilot</td>
<td>IDE Extension</td>
<td>Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.<br/><br/>You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.<br/><br/>Return the final string that will be present on your laptop screen.<br/><br/>Example 1:<br/><br/>Input: s = &quot;string&quot;<br/>Output: &quot;rtsng&quot;<br/>Explanation: <br/>After typing first character, the text on the screen is &quot;s&quot;.<br/>After the second character, the text is &quot;st&quot;. <br/>After the third character, the text is &quot;str&quot;.<br/>Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.<br/>After the fifth character, the text is &quot;rtsn&quot;. <br/>After the sixth character, the text is &quot;rtsng&quot;. <br/>Therefore, we return &quot;rtsng&quot;.<br/><br/>Example 2:<br/><br/>Input: s = &quot;poiinter&quot;<br/>Output: &quot;ponter&quot;<br/>Explanation: <br/>After the first character, the text on the screen is &quot;p&quot;.<br/>After the second character, the text is &quot;po&quot;. <br/>Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. <br/>Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.<br/>After the fifth character, the text is &quot;pon&quot;.<br/>After the sixth character, the text is &quot;pont&quot;. <br/>After the seventh character, the text is &quot;ponte&quot;. <br/>After the eighth character, the text is &quot;ponter&quot;. <br/>Therefore, we return &quot;ponter&quot;.<br/> <br/>Constraints:<br/><br/>1 &lt;= s.length &lt;= 100<br/>s consists of lowercase English letters.<br/>s[0] != &#39;i&#39;</td>
<td>class Solution {<br/>public:<br/>    string finalString(string s) {<br/>/*You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.<br/><br/>Return the final string that will be present on your laptop screen.<br/><br/>Example 1:<br/><br/>Input: s = &quot;string&quot;<br/>Output: &quot;rtsng&quot;<br/>Explanation: <br/>After typing first character, the text on the screen is &quot;s&quot;.<br/>After the second character, the text is &quot;st&quot;. <br/>After the third character, the text is &quot;str&quot;.<br/>Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.<br/>After the fifth character, the text is &quot;rtsn&quot;. <br/>After the sixth character, the text is &quot;rtsng&quot;. <br/>Therefore, we return &quot;rtsng&quot;.<br/><br/>Example 2:<br/><br/>Input: s = &quot;poiinter&quot;<br/>Output: &quot;ponter&quot;<br/>Explanation: <br/>After the first character, the text on the screen is &quot;p&quot;.<br/>After the second character, the text is &quot;po&quot;. <br/>Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. <br/>Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.<br/>After the fifth character, the text is &quot;pon&quot;.<br/>After the sixth character, the text is &quot;pont&quot;. <br/>After the seventh character, the text is &quot;ponte&quot;. <br/>After the eighth character, the text is &quot;ponter&quot;. <br/>Therefore, we return &quot;ponter&quot;.<br/> <br/>Constraints:<br/><br/>1 &lt;= s.length &lt;= 100<br/>s consists of lowercase English letters.<br/>s[0] != &#39;i&#39;*/</td>
<td>Class Solution {<br/>Public:<br/>    String Finalstring(string S) {<br/>        String Ans = &quot;&quot;;<br/>        Int N = S.length();<br/>        Int I = 0;<br/>        While(i &lt; N) {<br/>            If(s[i] == &#39;I&#39;) {<br/>                Reverse(ans.begin(), Ans.end());<br/>            } Else {<br/>                Ans += S[i];<br/>            }<br/>            I++;<br/>        }<br/>        Return Ans;<br/>    }<br/>};</td>
<td>Class Solution {<br/>Public:<br/>    String Finalstring(const String &amp;S) {<br/>        String A, B;<br/>        For (Char Ch : S)<br/>            If (Ch == &#39;I&#39;)<br/>                Swap(a, B);<br/>            Else<br/>                A += Ch;<br/>        Return String(rbegin(b), Rend(b)) + A;<br/>    }<br/>};</td>
</tr>
<tr>
<td align="right">79</td>
<td align="right">3</td>
<td>Java</td>
<td>medium</td>
<td>GitHub Copilot</td>
<td>IDE Extension</td>
<td>You are given a 0-indexed integer array nums and an integer x.<br/><br/>Find the minimum absolute difference between two elements in the array that are at least x indices apart.<br/><br/>In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.<br/><br/>Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.<br/><br/>Example 1:<br/><br/>Input: nums = [4,3,2,4], x = 2<br/>Output: 0<br/>Explanation: We can select nums[0] = 4 and nums[3] = 4. <br/>They are at least 2 indices apart, and their absolute difference is the minimum, 0. <br/>It can be shown that 0 is the optimal answer.<br/><br/>Example 2:<br/><br/>Input: nums = [5,3,2,10,15], x = 1<br/>Output: 1<br/>Explanation: We can select nums[1] = 3 and nums[2] = 2.<br/>They are at least 1 index apart, and their absolute difference is the minimum, 1.<br/>It can be shown that 1 is the optimal answer.<br/><br/>Example 3:<br/><br/>Input: nums = [1,2,3,4], x = 3<br/>Output: 3<br/>Explanation: We can select nums[0] = 1 and nums[3] = 4.<br/>They are at least 3 indices apart, and their absolute difference is the minimum, 3.<br/>It can be shown that 3 is the optimal answer.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^9<br/>0 &lt;= x &lt; nums.length </td>
<td>class Solution {<br/>    public int minAbsoluteDifference(List&lt;Integer&gt; nums, int x) {<br/>/*You are given a 0-indexed integer array nums and an integer x.<br/><br/>Find the minimum absolute difference between two elements in the array that are at least x indices apart.<br/><br/>In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.<br/><br/>Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^9<br/>0 &lt;= x &lt; nums.length*/</td>
<td>Class Solution {<br/>    Public Int Minabsolutedifference(list&lt;integer&gt; Nums, Int X) {<br/>        Int Min = Integer.max_value;<br/>        Int N = Nums.size();<br/>        For(int I = 0; I &lt; N; I++){<br/>            For(int J = I + X; J &lt; N; J++){<br/>                Min = Math.min(min, Math.abs(nums.get(i) - Nums.get(j)));<br/>            }<br/>        }<br/>        Return Min;<br/>    }<br/>}</td>
<td>Class Solution {<br/>    Int Minabsolutedifference(list&lt;integer&gt; Nums, Int X) {<br/>        Int Ans = Integer.max_value;<br/>        Treeset&lt;integer&gt; S = New Treeset&lt;&gt;();<br/>        For(int I = X; I &lt; Nums.size(); ++I){<br/>            S.add(nums.get(i-x));<br/>            Integer High = S.ceiling(nums.get(i)), Low = S.floor(nums.get(i));<br/>            If(high != Null) Ans = Math.min(ans, Math.abs(nums.get(i) - High));<br/>            If(low != Null) Ans = Math.min(ans, Math.abs(nums.get(i) - Low));<br/>        }<br/>        Return Ans;<br/>    }<br/>}</td>
</tr>
<tr>
<td align="right">80</td>
<td align="right">3</td>
<td>Python</td>
<td>medium</td>
<td>GitHub Copilot</td>
<td>IDE Extension</td>
<td>You are given a 0-indexed integer array nums and an integer x.<br/><br/>Find the minimum absolute difference between two elements in the array that are at least x indices apart.<br/><br/>In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.<br/><br/>Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.<br/><br/>Example 1:<br/><br/>Input: nums = [4,3,2,4], x = 2<br/>Output: 0<br/>Explanation: We can select nums[0] = 4 and nums[3] = 4. <br/>They are at least 2 indices apart, and their absolute difference is the minimum, 0. <br/>It can be shown that 0 is the optimal answer.<br/><br/>Example 2:<br/><br/>Input: nums = [5,3,2,10,15], x = 1<br/>Output: 1<br/>Explanation: We can select nums[1] = 3 and nums[2] = 2.<br/>They are at least 1 index apart, and their absolute difference is the minimum, 1.<br/>It can be shown that 1 is the optimal answer.<br/><br/>Example 3:<br/><br/>Input: nums = [1,2,3,4], x = 3<br/>Output: 3<br/>Explanation: We can select nums[0] = 1 and nums[3] = 4.<br/>They are at least 3 indices apart, and their absolute difference is the minimum, 3.<br/>It can be shown that 3 is the optimal answer.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^9<br/>0 &lt;= x &lt; nums.length </td>
<td>class Solution:<br/>    def minAbsoluteDifference(self, nums: List[int], x: int) -&gt; int:<br/>&quot;&quot;&quot;You are given a 0-indexed integer array nums and an integer x.<br/><br/>Find the minimum absolute difference between two elements in the array that are at least x indices apart.<br/><br/>In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.<br/><br/>Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.<br/><br/>Example 1:<br/><br/>Input: nums = [4,3,2,4], x = 2<br/>Output: 0<br/>Explanation: We can select nums[0] = 4 and nums[3] = 4. <br/>They are at least 2 indices apart, and their absolute difference is the minimum, 0. <br/>It can be shown that 0 is the optimal answer.<br/><br/>Example 2:<br/><br/>Input: nums = [5,3,2,10,15], x = 1<br/>Output: 1<br/>Explanation: We can select nums[1] = 3 and nums[2] = 2.<br/>They are at least 1 index apart, and their absolute difference is the minimum, 1.<br/>It can be shown that 1 is the optimal answer.<br/><br/>Example 3:<br/><br/>Input: nums = [1,2,3,4], x = 3<br/>Output: 3<br/>Explanation: We can select nums[0] = 1 and nums[3] = 4.<br/>They are at least 3 indices apart, and their absolute difference is the minimum, 3.<br/>It can be shown that 3 is the optimal answer.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^9<br/>0 &lt;= x &lt; nums.length<br/>&quot;&quot;&quot;</td>
<td>Class Solution:<br/>    Def Minabsolutedifference(self, Nums: List[int], X: Int) -&gt; Int:<br/>        Nums.sort()<br/>        N = Len(nums)<br/>        Res = Float(&#39;inf&#39;)<br/>        For I In Range(n):<br/>            J = Bisect_left(nums, Nums[i] - X, I + 1)<br/>            If J &lt; N:<br/>                Res = Min(res, Abs(nums[i] - Nums[j] + X))<br/>            If J &gt; I + 1:<br/>                Res = Min(res, Abs(nums[i] - Nums[j - 1] + X))<br/>        Return Res</td>
<td>Class Solution:<br/>  Def Minabsolutedifference(self, Nums: List[int], X: Int) -&gt; Int:<br/>    If X == 0:<br/>      Return 0<br/><br/>    Arr, Best_dist = Sortedlist([]), Float(&#39;inf&#39;)<br/>    For I In Range(x, Len(nums)):<br/>      Arr.add(nums[i - X])<br/>      V = Nums[i]<br/><br/>      Pos = Arr.bisect_left(v)<br/>      If Pos &lt; Len(arr):<br/>        Best_dist = Min(best_dist, Abs(arr[pos] - V))<br/>      If Pos &gt; 0:<br/>        Best_dist = Min(best_dist, Abs(arr[pos - 1] - V))<br/>    <br/>    Return Best_dist</td>
</tr>
<tr>
<td align="right">81</td>
<td align="right">3</td>
<td>C++</td>
<td>medium</td>
<td>GitHub Copilot</td>
<td>IDE Extension</td>
<td>You are given a 0-indexed integer array nums and an integer x.<br/><br/>Find the minimum absolute difference between two elements in the array that are at least x indices apart.<br/><br/>In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.<br/><br/>Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.<br/><br/>Example 1:<br/><br/>Input: nums = [4,3,2,4], x = 2<br/>Output: 0<br/>Explanation: We can select nums[0] = 4 and nums[3] = 4. <br/>They are at least 2 indices apart, and their absolute difference is the minimum, 0. <br/>It can be shown that 0 is the optimal answer.<br/><br/>Example 2:<br/><br/>Input: nums = [5,3,2,10,15], x = 1<br/>Output: 1<br/>Explanation: We can select nums[1] = 3 and nums[2] = 2.<br/>They are at least 1 index apart, and their absolute difference is the minimum, 1.<br/>It can be shown that 1 is the optimal answer.<br/><br/>Example 3:<br/><br/>Input: nums = [1,2,3,4], x = 3<br/>Output: 3<br/>Explanation: We can select nums[0] = 1 and nums[3] = 4.<br/>They are at least 3 indices apart, and their absolute difference is the minimum, 3.<br/>It can be shown that 3 is the optimal answer.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^9<br/>0 &lt;= x &lt; nums.length </td>
<td>class Solution {<br/>public:<br/>    int minAbsoluteDifference(vector&lt;int&gt;&amp; nums, int x) {<br/>/*You are given a 0-indexed integer array nums and an integer x.<br/><br/>Find the minimum absolute difference between two elements in the array that are at least x indices apart.<br/><br/>In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.<br/><br/>Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.<br/><br/>Example 1:<br/><br/>Input: nums = [4,3,2,4], x = 2<br/>Output: 0<br/>Explanation: We can select nums[0] = 4 and nums[3] = 4. <br/>They are at least 2 indices apart, and their absolute difference is the minimum, 0. <br/>It can be shown that 0 is the optimal answer.<br/><br/>Example 2:<br/><br/>Input: nums = [5,3,2,10,15], x = 1<br/>Output: 1<br/>Explanation: We can select nums[1] = 3 and nums[2] = 2.<br/>They are at least 1 index apart, and their absolute difference is the minimum, 1.<br/>It can be shown that 1 is the optimal answer.<br/><br/>Example 3:<br/><br/>Input: nums = [1,2,3,4], x = 3<br/>Output: 3<br/>Explanation: We can select nums[0] = 1 and nums[3] = 4.<br/>They are at least 3 indices apart, and their absolute difference is the minimum, 3.<br/>It can be shown that 3 is the optimal answer.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^9<br/>0 &lt;= x &lt; nums.length*/</td>
<td>Class Solution {<br/>Public:<br/>    Int Minabsolutedifference(vector&lt;int&gt;&amp; Nums, Int X) {<br/>        Int N = Nums.size();<br/>        Int Ans = Int_max;<br/>        For(int I = 0; I &lt; N; I++){<br/>            For(int J = I + X; J &lt; N; J++){<br/>                Ans = Min(ans, Abs(nums[i] - Nums[j]));<br/>            }<br/>        }<br/>        Return Ans;<br/>    }<br/>};</td>
<td>Class Solution {<br/>Public:<br/>    Int Minabsolutedifference(vector&lt;int&gt;&amp; Nums, Int X) {<br/>        Int Ans = Int_max;<br/>        Set&lt;int&gt; S;<br/>        For(int I = X; I &lt; Nums.size(); ++I){<br/>            S.insert(nums[i-x]);<br/>            Auto It = S.upper_bound(nums[i]);<br/>            If(it != S.end()) Ans = Min(ans, Abs(nums[i] - *It));<br/>            If(it != S.begin()) Ans = Min(ans, Abs(nums[i] - *Prev(it)));<br/>        }<br/>        Return Ans;<br/>    }<br/>};</td>
</tr>
<tr>
<td align="right">82</td>
<td align="right">4</td>
<td>Java</td>
<td>medium</td>
<td>GitHub Copilot</td>
<td>IDE Extension</td>
<td>You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.<br/><br/>Return the head of the linked list after doubling it.<br/><br/>Example 1:<br/><br/>Input: head = [1,8,9]<br/>Output: [3,7,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.<br/><br/>Example 2:<br/><br/>Input: head = [9,9,9]<br/>Output: [1,9,9,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. <br/><br/>Constraints:<br/><br/>The number of nodes in the list is in the range [1, 10^4]<br/>0 &lt;= Node.val &lt;= 9<br/>The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself. </td>
<td>class Solution {<br/>    public ListNode doubleIt(ListNode head) {<br/>/*<br/> *You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.<br/><br/>Return the head of the linked list after doubling it.<br/><br/>Constraints:<br/><br/>The number of nodes in the list is in the range [1, 10^4]<br/>0 &lt;= Node.val &lt;= 9<br/>The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.<br/>*/</td>
<td>Class Solution {<br/>    Public Listnode Doubleit(listnode Head) {<br/>        Listnode Curr = Head;<br/>        Listnode Prev = Null;<br/>        While(curr != Null) {<br/>            Listnode Next = Curr.next;<br/>            Curr.next = Prev;<br/>            Prev = Curr;<br/>            Curr = Next;<br/>        }<br/>        <br/>        Listnode Newhead = Prev;<br/>        Listnode Newcurr = Newhead;<br/>        Listnode Carry = Null;<br/>        While(newcurr != Null) {<br/>            Int Sum = Newcurr.val * 2;<br/>            If(carry != Null) {<br/>                Sum += Carry.val;<br/>                Carry = Null;<br/>            }<br/>            If(sum &gt; 9) {<br/>                Carry = New Listnode(sum / 10);<br/>                Sum = Sum % 10;<br/>            }<br/>            Newcurr.val = Sum;<br/>            Newcurr = Newcurr.next;<br/>        }<br/>        If(carry != Null) {<br/>            Newcurr = Newhead;<br/>            While(newcurr.next != Null) {<br/>                Newcurr = Newcurr.next;<br/>            }<br/>            Newcurr.next = Carry;<br/>        }<br/>        Return Reverse(newhead);<br/>    }<br/>    <br/>    Public Listnode Reverse(listnode Head) {<br/>        Listnode Curr = Head;<br/>        Listnode Prev = Null;<br/>        While(curr != Null) {<br/>            Listnode Next = Curr.next;<br/>            Curr.next = Prev;<br/>            Prev = Curr;<br/>            Curr = Next;<br/>        }<br/>        <br/>        Return Prev;<br/>    }<br/>}</td>
<td>Class Solution {<br/>    Public Listnode Doubleit(listnode Head) {<br/>        If (Head.val &gt; 4)<br/>            Head = New Listnode(0, Head);<br/>        For(listnode Node = Head; Node != Null; Node = Node.next) {<br/>            Node.val = (Node.val * 2) % 10;<br/>            If (Node.next != Null &amp;&amp; Node.next.val &gt; 4)<br/>                Node.val++;<br/>        }<br/>        Return Head;<br/>    }<br/>}</td>
</tr>
<tr>
<td align="right">83</td>
<td align="right">4</td>
<td>Python</td>
<td>medium</td>
<td>GitHub Copilot</td>
<td>IDE Extension</td>
<td>You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.<br/><br/>Return the head of the linked list after doubling it.<br/><br/>Example 1:<br/><br/>Input: head = [1,8,9]<br/>Output: [3,7,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.<br/><br/>Example 2:<br/><br/>Input: head = [9,9,9]<br/>Output: [1,9,9,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. <br/><br/>Constraints:<br/><br/>The number of nodes in the list is in the range [1, 10^4]<br/>0 &lt;= Node.val &lt;= 9<br/>The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself. </td>
<td>class Solution:<br/>    def doubleIt(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:<br/>&quot;&quot;&quot;You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.<br/><br/>Return the head of the linked list after doubling it.<br/><br/>Example 1:<br/><br/>Input: head = [1,8,9]<br/>Output: [3,7,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.<br/><br/>Example 2:<br/><br/>Input: head = [9,9,9]<br/>Output: [1,9,9,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. <br/><br/>Constraints:<br/><br/>The number of nodes in the list is in the range [1, 10^4]<br/>0 &lt;= Node.val &lt;= 9<br/>The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.&quot;&quot;&quot;</td>
<td>Class Solution:<br/>    Def Doubleit(self, Head: Optional[listnode]) -&gt; Optional[listnode]:<br/>        If Head Is None:<br/>            Return None<br/>        If Head.next Is None:<br/>            Head.val = Head.val * 2<br/>            Return Head<br/>        Node = Head<br/>        While Node:<br/>            Node.val = Node.val * 2<br/>            Node = Node.next<br/>        Node = Head<br/>        While Node:<br/>            If Node.val &gt; 9:<br/>                Node.val = Node.val % 10<br/>                If Node.next Is None:<br/>                    Node.next = Listnode(1)<br/>                Else:<br/>                    Node.next.val += 1<br/>            Node = Node.next<br/>        Return Head</td>
<td>Class Solution:<br/>    Def Doubleit(self, Head: Optional[listnode]) -&gt; Optional[listnode]:<br/>        If Head.val &gt; 4:<br/>            Head = Listnode(0, Head)<br/>        Node = Head<br/>        While Node:<br/>            Node.val = (Node.val * 2) % 10<br/>            If Node.next And Node.next.val &gt; 4:<br/>                Node.val += 1<br/>            Node = Node.next<br/>        Return Head</td>
</tr>
<tr>
<td align="right">84</td>
<td align="right">4</td>
<td>C++</td>
<td>medium</td>
<td>GitHub Copilot</td>
<td>IDE Extension</td>
<td>You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.<br/><br/>Return the head of the linked list after doubling it.<br/><br/>Example 1:<br/><br/>Input: head = [1,8,9]<br/>Output: [3,7,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.<br/><br/>Example 2:<br/><br/>Input: head = [9,9,9]<br/>Output: [1,9,9,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. <br/><br/>Constraints:<br/><br/>The number of nodes in the list is in the range [1, 10^4]<br/>0 &lt;= Node.val &lt;= 9<br/>The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself. </td>
<td>class Solution {<br/>public:<br/>    ListNode* doubleIt(ListNode* head) {<br/>/*You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.<br/><br/>Return the head of the linked list after doubling it.<br/><br/>Constraints:<br/><br/>The number of nodes in the list is in the range [1, 10^4]<br/>0 &lt;= Node.val &lt;= 9<br/>The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.*/</td>
<td>Class Solution {<br/>Public:<br/>    Listnode* Doubleit(listnode* Head) {<br/>        Listnode* Temp = Head;<br/>        Listnode* Prev = Null;<br/>        While(temp != Null) {<br/>            Temp-&gt;val *= 2;<br/>            If(temp-&gt;val &gt; 9) {<br/>                If(prev == Null) {<br/>                    Listnode* Newhead = New Listnode(1);<br/>                    Newhead-&gt;next = Head;<br/>                    Head = Newhead;<br/>                    Temp-&gt;val -= 10;<br/>                } Else {<br/>                    Prev-&gt;val += 1;<br/>                    Temp-&gt;val -= 10;<br/>                }<br/>            }<br/>            Prev = Temp;<br/>            Temp = Temp-&gt;next;<br/>        }<br/>        Return Head;<br/>    }<br/>};</td>
<td>Class Solution {<br/>Public:<br/>    Listnode* Doubleit(listnode* Head) {<br/>        If (Head-&gt;val &gt; 4)<br/>            Head = New Listnode(0, Head);<br/>        For(listnode* Node = Head; Node; Node = Node-&gt;next) {<br/>            Node-&gt;val = (Node-&gt;val * 2) % 10;<br/>            If (Node-&gt;next &amp;&amp; Node-&gt;next-&gt;val &gt; 4)<br/>                Node-&gt;val++;<br/>        }<br/>        Return Head;<br/>    }<br/>};</td>
</tr>
<tr>
<td align="right">85</td>
<td align="right">5</td>
<td>Java</td>
<td>hard</td>
<td>GitHub Copilot</td>
<td>IDE Extension</td>
<td>You are given an array nums of n positive integers and an integer k.<br/><br/>Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:<br/><br/>Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.<br/>Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.<br/>Multiply your score by x.<br/>Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.<br/><br/>The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.<br/><br/>Return the maximum possible score after applying at most k operations.<br/><br/>Since the answer may be large, return it modulo 10^9 + 7.<br/><br/>Example 1:<br/><br/>Input: nums = [8,3,9,3,8], k = 2<br/>Output: 81<br/>Explanation: To get a score of 81, we can apply the following operations:<br/>- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.<br/>It can be proven that 81 is the highest score one can obtain.<br/><br/>Example 2:<br/><br/>Input: nums = [19,12,14,6,10,18], k = 3<br/>Output: 4788<br/>Explanation: To get a score of 4788, we can apply the following operations: <br/>- Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.<br/>- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.<br/>It can be proven that 4788 is the highest score one can obtain.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length == n &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^5<br/>1 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9) </td>
<td>public class Solution {<br/>    public int maximumScore(List&lt;Integer&gt; nums, int k) {<br/>/*<br/> * You are given an array nums of n positive integers and an integer k.<br/><br/>Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:<br/><br/>Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.<br/>Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.<br/>Multiply your score by x.<br/>Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.<br/><br/>The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.<br/><br/>Return the maximum possible score after applying at most k operations.<br/><br/>Since the answer may be large, return it modulo 10^9 + 7.<br/><br/>Example 1:<br/><br/>Input: nums = [8,3,9,3,8], k = 2<br/>Output: 81<br/>Explanation: To get a score of 81, we can apply the following operations:<br/>- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.<br/>It can be proven that 81 is the highest score one can obtain.<br/><br/>Example 2:<br/><br/>Input: nums = [19,12,14,6,10,18], k = 3<br/>Output: 4788<br/>Explanation: To get a score of 4788, we can apply the following operations: <br/>- Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.<br/>- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.<br/>It can be proven that 4788 is the highest score one can obtain.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length == n &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^5<br/>1 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9).<br/>*/</td>
<td>Public Class Solution {<br/>    Public Int Maximumscore(list&lt;integer&gt; Nums, Int K) {<br/>        Int N = Nums.size();<br/>        Int[] Left = New Int[n];<br/>        Int[] Right = New Int[n];<br/>        Stack&lt;integer&gt; Stack = New Stack&lt;&gt;();<br/>        For (Int I = 0; I &lt; N; I++) {<br/>            While (!Stack.isempty() &amp;&amp; Nums.get(stack.peek()) &gt;= Nums.get(i)) {<br/>                Stack.pop();<br/>            }<br/>            Left[i] = Stack.isempty() ? -1 : Stack.peek();<br/>            Stack.push(i);<br/>        }<br/>        Stack.clear();<br/>        For (Int I = N - 1; I &gt;= 0; I--) {<br/>            While (!Stack.isempty() &amp;&amp; Nums.get(stack.peek()) &gt;= Nums.get(i)) {<br/>                Stack.pop();<br/>            }<br/>            Right[i] = Stack.isempty() ? N : Stack.peek();<br/>            Stack.push(i);<br/>        }<br/>        Int Ans = 0;<br/>        For (Int I = 0; I &lt; N; I++) {<br/>            If (Left[i] &lt; K &amp;&amp; Right[i] &gt; K) {<br/>                Ans = Math.max(ans, Nums.get(i) * (Right[i] - Left[i] - 1));<br/>            }<br/>        }<br/>        Return Ans;<br/>    }<br/>}</td>
<td>Class Solution {<br/>    Static Final Int Mod = 1000000007;<br/><br/>    Public Int Maximumscore(list&lt;integer&gt; Nums, Int K) {<br/>        Int N = Nums.size();<br/><br/>        Int Upper = Collections.max(nums) + 1;<br/><br/>        Boolean[] Prime = New Boolean[upper];<br/>        Int[] Primescore = New Int[upper];<br/>        Arrays.fill(prime, True);<br/>        Prime[0] = Prime[1] = False;<br/>        For (Int I = 2; I &lt; Upper; I++) {<br/>            If (Prime[i]) {<br/>                For (Int J = I; J &lt; Upper; J += I) {<br/>                    Primescore[j]++;<br/>                    Prime[j] = False;<br/>                }<br/>            }<br/>        }<br/><br/>        Int[] Nextgreaterelement = New Int[n];<br/>        Arrays.fill(nextgreaterelement, N);<br/>        Stack&lt;integer&gt; S = New Stack&lt;&gt;();<br/>        For (Int I = N - 1; I &gt;= 0; I--) {<br/>            While (!S.empty() &amp;&amp; Primescore[nums.get(i)] &gt;= Primescore[nums.get(s.peek())]) {<br/>                S.pop();<br/>            }<br/>            Nextgreaterelement[i] = S.empty() ? N : S.peek();<br/>            S.push(i);<br/>        }<br/><br/>        Int[] Prevgreaterorequalelement = New Int[n];<br/>        Arrays.fill(prevgreaterorequalelement, -1);<br/>        S = New Stack&lt;&gt;();<br/>        For (Int I = 0; I &lt; N; I++) {<br/>            While (!S.empty() &amp;&amp; Primescore[nums.get(i)] &gt; Primescore[nums.get(s.peek())]) {<br/>                S.pop();<br/>            }<br/>            Prevgreaterorequalelement[i] = S.empty() ? -1 : S.peek();<br/>            S.push(i);<br/>        }<br/><br/>        Int Res = 1;<br/>        Int[][] Tuples = New Int[n][2];<br/>        For (Int I = 0; I &lt; N; I++) {<br/>            Tuples[i][0] = Nums.get(i);<br/>            Tuples[i][1] = I;<br/>        }<br/>        Arrays.sort(tuples, New Comparator&lt;int[]&gt;() {<br/>            Public Int Compare(int[] A, Int[] B) {<br/>                Return B[0] - A[0];<br/>            }<br/>        });<br/>        For (Int I = 0; I &lt; N; I++) {<br/>            Int Num = Tuples[i][0];<br/>            Int Idx = Tuples[i][1];<br/>            Int Operations = Math.min((idx - Prevgreaterorequalelement[idx]) * (Nextgreaterelement[idx] - Idx), K);<br/>            Res = (Int)((1l * Res * Pow(num, Operations)) % Mod);<br/>            K -= Operations;<br/>            If (K == 0) {<br/>                Return Res;<br/>            }<br/>        }<br/><br/>        Return Res;<br/>    }<br/><br/>    Public Int Pow(int X, Int N) {<br/>        Int Res = 1;<br/>        While (N &gt; 0) {<br/>            If (N % 2 == 1) {<br/>                Res = (Int)((1l * Res * X) % Mod);<br/>            }<br/>            X = (Int)((1l * X * X) % Mod);<br/>            N /= 2;<br/>        }<br/>        Return Res;<br/>    }<br/>}</td>
</tr>
<tr>
<td align="right">86</td>
<td align="right">5</td>
<td>Python</td>
<td>hard</td>
<td>GitHub Copilot</td>
<td>IDE Extension</td>
<td>You are given an array nums of n positive integers and an integer k.<br/><br/>Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:<br/><br/>Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.<br/>Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.<br/>Multiply your score by x.<br/>Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.<br/><br/>The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.<br/><br/>Return the maximum possible score after applying at most k operations.<br/><br/>Since the answer may be large, return it modulo 10^9 + 7.<br/><br/>Example 1:<br/><br/>Input: nums = [8,3,9,3,8], k = 2<br/>Output: 81<br/>Explanation: To get a score of 81, we can apply the following operations:<br/>- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.<br/>It can be proven that 81 is the highest score one can obtain.<br/><br/>Example 2:<br/><br/>Input: nums = [19,12,14,6,10,18], k = 3<br/>Output: 4788<br/>Explanation: To get a score of 4788, we can apply the following operations: <br/>- Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.<br/>- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.<br/>It can be proven that 4788 is the highest score one can obtain.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length == n &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^5<br/>1 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9) </td>
<td>class Solution:<br/>    def maximumScore(self, nums: List[int], k: int) -&gt; int:<br/>&quot;&quot;&quot;You are given an array nums of n positive integers and an integer k.<br/><br/>Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:<br/><br/>Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.<br/>Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.<br/>Multiply your score by x.<br/>Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.<br/><br/>The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.<br/><br/>Return the maximum possible score after applying at most k operations.<br/><br/>Since the answer may be large, return it modulo 10^9 + 7.<br/><br/>Example 1:<br/><br/>Input: nums = [8,3,9,3,8], k = 2<br/>Output: 81<br/>Explanation: To get a score of 81, we can apply the following operations:<br/>- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.<br/>It can be proven that 81 is the highest score one can obtain.<br/><br/>Example 2:<br/><br/>Input: nums = [19,12,14,6,10,18], k = 3<br/>Output: 4788<br/>Explanation: To get a score of 4788, we can apply the following operations: <br/>- Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.<br/>- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.<br/>It can be proven that 4788 is the highest score one can obtain.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length == n &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^5<br/>1 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9).&quot;&quot;&quot;</td>
<td>Class Solution:<br/>    Def Maximumscore(self, Nums: List[int], K: Int) -&gt; Int:<br/>        N = Len(nums)<br/>        Left, Right = K, K<br/>        Res = Nums[k]<br/>        Min_val = Nums[k]<br/>        While Left &gt; 0 Or Right &lt; N - 1:<br/>            If Left == 0:<br/>                Right += 1<br/>            Elif Right == N - 1:<br/>                Left -= 1<br/>            Elif Nums[left - 1] &lt; Nums[right + 1]:<br/>                Right += 1<br/>            Else:<br/>                Left -= 1<br/>            Min_val = Min(min_val, Nums[left], Nums[right])<br/>            Res = Max(res, Min_val * (Right - Left + 1))<br/>        Return Res</td>
<td>Class Solution: <br/>    Mod = 1000000007<br/><br/>    Def Maximumscore(self, Nums: List[int], K: Int) -&gt; Int:<br/>        N = Len(nums)<br/><br/>        Upper = Max(nums) + 1<br/><br/>        Prime = [True]*upper<br/>        Prime[0] = Prime[1] = False<br/>        Primescore = [0]*upper<br/>        For I In Range(2, Upper):<br/>            If Prime[i]:<br/>                For J In Range(i, Upper, I):<br/>                    Primescore[j] += 1<br/>                    Prime[j] = False<br/><br/>        Nextgreaterelement = [N]*n<br/>        S = []<br/>        For I In Range(n - 1, -1, -1):<br/>            While S And Primescore[nums[i]] &gt;= Primescore[nums[s[-1]]]:<br/>                S.pop()<br/>            Nextgreaterelement[i] = S[-1] If S Else N<br/>            S.append(i)<br/><br/>        Prevgreaterorequalelement = [-1]*n<br/>        S = []<br/>        For I In Range(n):<br/>            While S And Primescore[nums[i]] &gt; Primescore[nums[s[-1]]]:<br/>                S.pop()<br/>            Prevgreaterorequalelement[i] = S[-1] If S Else -1<br/>            S.append(i)<br/><br/>        Res = 1<br/>        Tuples = [[Nums[i], I] For I In Range(n)]<br/>        Tuples.sort(reverse=true)<br/>        For Num, Idx In Tuples:<br/>            Operations = Min((idx - Prevgreaterorequalelement[idx]) * (Nextgreaterelement[idx] - Idx), K)<br/>            Res = (Res * Self.pow(num, Operations)) % Self.mod<br/>            K -= Operations<br/>            If K == 0:<br/>                Return Res<br/><br/>        Return Res<br/><br/>    Def Pow(self, X: Int, N: Int) -&gt; Int:<br/>        Res = 1<br/>        While N &gt; 0:<br/>            If N % 2 == 1:<br/>                Res = (Res * X) % Self.mod<br/>            X = (X * X) % Self.mod<br/>            N //= 2<br/>        Return Res</td>
</tr>
<tr>
<td align="right">87</td>
<td align="right">5</td>
<td>C++</td>
<td>hard</td>
<td>GitHub Copilot</td>
<td>IDE Extension</td>
<td>You are given an array nums of n positive integers and an integer k.<br/><br/>Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:<br/><br/>Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.<br/>Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.<br/>Multiply your score by x.<br/>Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.<br/><br/>The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.<br/><br/>Return the maximum possible score after applying at most k operations.<br/><br/>Since the answer may be large, return it modulo 10^9 + 7.<br/><br/>Example 1:<br/><br/>Input: nums = [8,3,9,3,8], k = 2<br/>Output: 81<br/>Explanation: To get a score of 81, we can apply the following operations:<br/>- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.<br/>It can be proven that 81 is the highest score one can obtain.<br/><br/>Example 2:<br/><br/>Input: nums = [19,12,14,6,10,18], k = 3<br/>Output: 4788<br/>Explanation: To get a score of 4788, we can apply the following operations: <br/>- Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.<br/>- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.<br/>It can be proven that 4788 is the highest score one can obtain.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length == n &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^5<br/>1 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9) </td>
<td>class Solution {<br/>public:<br/>    int maximumScore(vector&lt;int&gt;&amp; nums, int k) {<br/>/*You are given an array nums of n positive integers and an integer k.<br/><br/>Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:<br/><br/>Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.<br/>Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.<br/>Multiply your score by x.<br/>Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.<br/><br/>The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.<br/><br/>Return the maximum possible score after applying at most k operations.<br/><br/>Since the answer may be large, return it modulo 10^9 + 7.<br/><br/>Example 1:<br/><br/>Input: nums = [8,3,9,3,8], k = 2<br/>Output: 81<br/>Explanation: To get a score of 81, we can apply the following operations:<br/>- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.<br/>It can be proven that 81 is the highest score one can obtain.<br/><br/>Example 2:<br/><br/>Input: nums = [19,12,14,6,10,18], k = 3<br/>Output: 4788<br/>Explanation: To get a score of 4788, we can apply the following operations: <br/>- Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.<br/>- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.<br/>It can be proven that 4788 is the highest score one can obtain.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length == n &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^5<br/>1 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9).*/</td>
<td>Class Solution {<br/>Public:<br/>    Int Maximumscore(vector&lt;int&gt;&amp; Nums, Int K) {<br/>        Int N = Nums.size();<br/>        Vector&lt;int&gt; Left(n, -1), Right(n, N);<br/>        Stack&lt;int&gt; St;<br/>        For(int I = 0; I &lt; N; I++) {<br/>            While(!st.empty() &amp;&amp; Nums[st.top()] &gt;= Nums[i]) {<br/>                St.pop();<br/>            }<br/>            If(!st.empty()) {<br/>                Left[i] = St.top();<br/>            }<br/>            St.push(i);<br/>        }<br/>        While(!st.empty()) {<br/>            St.pop();<br/>        }<br/>        For(int I = N - 1; I &gt;= 0; I--) {<br/>            While(!st.empty() &amp;&amp; Nums[st.top()] &gt;= Nums[i]) {<br/>                St.pop();<br/>            }<br/>            If(!st.empty()) {<br/>                Right[i] = St.top();<br/>            }<br/>            St.push(i);<br/>        }<br/>        Vector&lt;int&gt; Primes(100001, 0);<br/>        For(int I = 2; I &lt;= 100000; I++) {<br/>            If(primes[i] == 0) {<br/>                For(int J = I; J &lt;= 100000; J += I) {<br/>                    Primes[j]++;<br/>                }<br/>            }<br/>        }<br/>        Vector&lt;int&gt; Dp(n, 0);<br/>        For(int I = 0; I &lt; N; I++) {<br/>            Dp[i] = Nums[i] * (Primes[nums[i]] + 1);<br/>        }<br/>        For(int I = 1; I &lt; N; I++) {<br/>            Dp[i] = Max(dp[i], Dp[i - 1]);<br/>        }<br/>        Int Ans = 0;<br/>        For(int I = 0; I &lt; N; I++) {<br/>            Int L = Left[i] + 1, R = Right[i] - 1;<br/>            If(l &lt;= K &amp;&amp; K &lt;= R) {<br/>                Ans = Max(ans, Nums[i] * Dp[r]);<br/>            }<br/>            If(l &lt;= K - 1 &amp;&amp; K - 1 &lt;= R) {<br/>                Ans = Max(ans, Nums[i] * Dp[r]);<br/>            }<br/>            If(l &lt;= K &amp;&amp; K &lt;= R + 1) {<br/>                Ans = Max(ans, Nums[i] * Dp[r]);<br/>            }<br/>            If(l &lt;= K - 1 &amp;&amp; K - 1 &lt;= R + 1) {<br/>                Ans = Max(ans, Nums[i] * Dp[r]);<br/>            }<br/>        }<br/>        Return Ans;<br/>    }<br/>};</td>
<td>Class Solution {<br/>Public:<br/>    Const Int Mod = 1000000007;<br/><br/>    Int Maximumscore(vector&lt;int&gt;&amp; Nums, Int K) {<br/>        Int N = Nums.size();<br/><br/>        Int Upper = *Max_element(nums.begin(), Nums.end()) + 1;<br/><br/>        Vector&lt;bool&gt; Prime(upper, True);<br/>        Prime[0] = Prime[1] = False;<br/>        Vector&lt;int&gt; Primescore(upper, 0);<br/>        For (Int I = 2; I &lt; Upper; I++) {<br/>            If (Prime[i]) {<br/>                For (Int J = I; J &lt; Upper; J += I) {<br/>                    Primescore[j]++;<br/>                    Prime[j] = False;<br/>                }<br/>            }<br/>        }<br/><br/>        Vector&lt;int&gt; Nextgreaterelement(n, N);<br/>        Stack&lt;int&gt; S;<br/>        For (Int I = N - 1; I &gt;= 0; I--) {<br/>            While (!S.empty() &amp;&amp; Primescore[nums[i]] &gt;= Primescore[nums[s.top()]]) {<br/>                S.pop();<br/>            }<br/>            Nextgreaterelement[i] = S.empty() ? N : S.top();<br/>            S.push(i);<br/>        }<br/><br/>        Vector&lt;int&gt; Prevgreaterorequalelement(n, -1);<br/>        S = Stack&lt;int&gt;();<br/>        For (Int I = 0; I &lt; N; I++) {<br/>            While (!S.empty() &amp;&amp; Primescore[nums[i]] &gt; Primescore[nums[s.top()]]) {<br/>                S.pop();<br/>            }<br/>            Prevgreaterorequalelement[i] = S.empty() ? -1 : S.top();<br/>            S.push(i);<br/>        }<br/><br/>        Int Res = 1;<br/>        Vector&lt;pair&lt;int, Int&gt;&gt; Tuples(n);<br/>        For (Int I = 0; I &lt; N; I++) {<br/>            Tuples[i].first = Nums[i];<br/>            Tuples[i].second = I;<br/>        }<br/>        Sort(tuples.rbegin(), Tuples.rend());<br/>        For (Const Auto&amp; [Num, I] : Tuples) {<br/>            Int Operations = Min((i - Prevgreaterorequalelement[i]) * (Nextgreaterelement[i] - I), K);<br/>            Res = (Int)((1l * Res * Pow(num, Operations)) % Mod);<br/>            K -= Operations;<br/>            If (K == 0) {<br/>                Return Res;<br/>            }<br/>        }<br/><br/>        Return Res;<br/>    }<br/><br/>    Int Pow(int X, Int N) {<br/>        Int Res = 1;<br/>        While (N &gt; 0) {<br/>            If (N % 2 == 1) {<br/>                Res = (Int)((1l * Res * X) % Mod);<br/>            }<br/>            X = (Int)((1l * X * X) % Mod);<br/>            N /= 2;<br/>        }<br/>        Return Res;<br/>    }<br/>};</td>
</tr>
<tr>
<td align="right">88</td>
<td align="right">6</td>
<td>Java</td>
<td>hard</td>
<td>GitHub Copilot</td>
<td>IDE Extension</td>
<td>You are given a 0-indexed 2D integer array items of length n and an integer k.<br/><br/>items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.<br/><br/>Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.<br/><br/>Your task is to find the maximum elegance from all subsequences of size k in items.<br/><br/>Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.<br/><br/>Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.<br/><br/>Example 1:<br/><br/>Input: items = [[3,2],[5,1],[10,1]], k = 2<br/>Output: 17<br/>Explanation: In this example, we have to select a subsequence of size 2.<br/>We can select items[0] = [3,2] and items[2] = [10,1].<br/>The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].<br/>Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. <br/><br/>Example 2:<br/><br/>Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3<br/>Output: 19<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. <br/>The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. <br/>Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.<br/><br/>Example 3:<br/><br/>Input: items = [[1,1],[2,1],[3,1]], k = 3<br/>Output: 7<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We should select all the items. <br/>The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. <br/>Hence, the maximum elegance is 6 + 1^2 = 7.  <br/> <br/>Constraints:<br/><br/>1 &lt;= items.length == n &lt;= 10^5<br/>items[i].length == 2<br/>items[i][0] == profit_i<br/>items[i][1] == category_i<br/>1 &lt;= profit_i &lt;= 10^9<br/>1 &lt;= category_i &lt;= n <br/>1 &lt;= k &lt;= n </td>
<td>public class Solution {<br/>    public int findMaximumElegance(int[][] items, int k) {<br/>/*<br/> * You are given a 0-indexed 2D integer array items of length n and an integer k.<br/><br/>items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.<br/><br/>Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.<br/><br/>Your task is to find the maximum elegance from all subsequences of size k in items.<br/><br/>Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.<br/><br/>Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.<br/><br/>Example 1:<br/><br/>Input: items = [[3,2],[5,1],[10,1]], k = 2<br/>Output: 17<br/>Explanation: In this example, we have to select a subsequence of size 2.<br/>We can select items[0] = [3,2] and items[2] = [10,1].<br/>The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].<br/>Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. <br/><br/>Example 2:<br/><br/>Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3<br/>Output: 19<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. <br/>The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. <br/>Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.<br/><br/>Example 3:<br/><br/>Input: items = [[1,1],[2,1],[3,1]], k = 3<br/>Output: 7<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We should select all the items. <br/>The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. <br/>Hence, the maximum elegance is 6 + 1^2 = 7.  <br/> <br/>Constraints:<br/><br/>1 &lt;= items.length == n &lt;= 10^5<br/>items[i].length == 2<br/>items[i][0] == profit_i<br/>items[i][1] == category_i<br/>1 &lt;= profit_i &lt;= 10^9<br/>1 &lt;= category_i &lt;= n <br/>1 &lt;= k &lt;= n<br/>*/</td>
<td>Public Class Solution {<br/>    Public Int Findmaximumelegance(int[][] Items, Int K) {<br/>        Int N = Items.length;<br/>        Int[] Dp = New Int[n];<br/>        Arrays.sort(items, (A, B) -&gt; A[0] - B[0]);<br/>        Int Max = 0;<br/>        For (Int I = 0; I &lt; N; I++) {<br/>            Int Profit = Items[i][0];<br/>            Int Category = Items[i][1];<br/>            Dp[i] = Profit + Category * Category;<br/>            For (Int J = 0; J &lt; I; J++) {<br/>                If (Items[j][1] != Category) {<br/>                    Dp[i] = Math.max(dp[i], Dp[j] + Profit + Category * Category);<br/>                }<br/>            }<br/>            If (I &gt;= K - 1) {<br/>                Max = Math.max(max, Dp[i]);<br/>            }<br/>        }<br/>        Return Max;<br/>    }<br/>}</td>
<td>Class Solution {<br/>    Public Long Findmaximumelegance(int[][] A, Int K) {<br/>        Arrays.sort(a, (A, B) -&gt; B[0] - A[0]);<br/>        Long Res = 0, Cur = 0;<br/>        List&lt;integer&gt; Dup = New Arraylist&lt;&gt;();<br/>        Set&lt;integer&gt; Seen = New Hashset&lt;&gt;();<br/>        For (Int I = 0; I &lt; A.length; ++I) {<br/>            If (I &lt; K) {<br/>                If (Seen.contains(a[i][1])) {<br/>                    Dup.add(a[i][0]);<br/>                }<br/>                Cur += A[i][0];<br/>            } Else If (!Seen.contains(a[i][1])) {<br/>                If (Dup.isempty()) Break;<br/>                Cur += A[i][0] - Dup.remove(dup.size() - 1);<br/>            }<br/>            Seen.add(a[i][1]);<br/>            Res = Math.max(res, Cur + 1l * Seen.size() * Seen.size());<br/>        }<br/>        Return Res;<br/>    }<br/>}</td>
</tr>
<tr>
<td align="right">89</td>
<td align="right">6</td>
<td>Python</td>
<td>hard</td>
<td>GitHub Copilot</td>
<td>IDE Extension</td>
<td>You are given a 0-indexed 2D integer array items of length n and an integer k.<br/><br/>items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.<br/><br/>Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.<br/><br/>Your task is to find the maximum elegance from all subsequences of size k in items.<br/><br/>Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.<br/><br/>Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.<br/><br/>Example 1:<br/><br/>Input: items = [[3,2],[5,1],[10,1]], k = 2<br/>Output: 17<br/>Explanation: In this example, we have to select a subsequence of size 2.<br/>We can select items[0] = [3,2] and items[2] = [10,1].<br/>The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].<br/>Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. <br/><br/>Example 2:<br/><br/>Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3<br/>Output: 19<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. <br/>The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. <br/>Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.<br/><br/>Example 3:<br/><br/>Input: items = [[1,1],[2,1],[3,1]], k = 3<br/>Output: 7<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We should select all the items. <br/>The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. <br/>Hence, the maximum elegance is 6 + 1^2 = 7.  <br/> <br/>Constraints:<br/><br/>1 &lt;= items.length == n &lt;= 10^5<br/>items[i].length == 2<br/>items[i][0] == profit_i<br/>items[i][1] == category_i<br/>1 &lt;= profit_i &lt;= 10^9<br/>1 &lt;= category_i &lt;= n <br/>1 &lt;= k &lt;= n </td>
<td>class Solution:<br/>    def findMaximumElegance(self, items: List[List[int]], k: int) -&gt; int:<br/>&quot;&quot;&quot;You are given a 0-indexed 2D integer array items of length n and an integer k.<br/><br/>items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.<br/><br/>Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.<br/><br/>Your task is to find the maximum elegance from all subsequences of size k in items.<br/><br/>Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.<br/><br/>Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.<br/><br/>Example 1:<br/><br/>Input: items = [[3,2],[5,1],[10,1]], k = 2<br/>Output: 17<br/>Explanation: In this example, we have to select a subsequence of size 2.<br/>We can select items[0] = [3,2] and items[2] = [10,1].<br/>The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].<br/>Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. <br/><br/>Example 2:<br/><br/>Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3<br/>Output: 19<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. <br/>The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. <br/>Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.<br/><br/>Example 3:<br/><br/>Input: items = [[1,1],[2,1],[3,1]], k = 3<br/>Output: 7<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We should select all the items. <br/>The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. <br/>Hence, the maximum elegance is 6 + 1^2 = 7.  <br/> <br/>Constraints:<br/><br/>1 &lt;= items.length == n &lt;= 10^5<br/>items[i].length == 2<br/>items[i][0] == profit_i<br/>items[i][1] == category_i<br/>1 &lt;= profit_i &lt;= 10^9<br/>1 &lt;= category_i &lt;= n <br/>1 &lt;= k &lt;= n&quot;&quot;&quot;</td>
<td>Class Solution:<br/>    Def Findmaximumelegance(self, Items: List[list[int]], K: Int) -&gt; Int:<br/>        Items.sort(key = Lambda X: X[0], Reverse = True)<br/>        Category = {}<br/>        For I In Range(len(items)):<br/>            If Items[i][1] Not In Category:<br/>                Category[items[i][1]] = 1<br/>            Else:<br/>                Category[items[i][1]] += 1<br/>        Category = Sorted(category.items(), Key = Lambda X: X[1], Reverse = True)<br/>        Ans = 0<br/>        For I In Range(k):<br/>            Ans += Items[i][0]<br/>        Ans += Len(category) ** 2<br/>        Return Ans</td>
<td>Class Solution:<br/>    Def Findmaximumelegance(self, Items: List[list[int]], K: Int) -&gt; Int:<br/>        Items = Sorted(items, Key=lambda V: -V[0])<br/>        Res = Cur = 0<br/>        A = []<br/>        Seen = Set()<br/>        For I, (P, C) In Enumerate(items):<br/>            If I &lt; K:<br/>                If C In Seen:<br/>                    A.append(p)<br/>                Cur += P<br/>            Elif C Not In Seen:<br/>                If Not A: Break<br/>                Cur += P - A.pop()<br/>            Seen.add(c)<br/>            Res = Max(res, Cur + Len(seen) * Len(seen))<br/>        Return Res</td>
</tr>
<tr>
<td align="right">90</td>
<td align="right">6</td>
<td>C++</td>
<td>hard</td>
<td>GitHub Copilot</td>
<td>IDE Extension</td>
<td>You are given a 0-indexed 2D integer array items of length n and an integer k.<br/><br/>items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.<br/><br/>Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.<br/><br/>Your task is to find the maximum elegance from all subsequences of size k in items.<br/><br/>Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.<br/><br/>Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.<br/><br/>Example 1:<br/><br/>Input: items = [[3,2],[5,1],[10,1]], k = 2<br/>Output: 17<br/>Explanation: In this example, we have to select a subsequence of size 2.<br/>We can select items[0] = [3,2] and items[2] = [10,1].<br/>The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].<br/>Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. <br/><br/>Example 2:<br/><br/>Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3<br/>Output: 19<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. <br/>The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. <br/>Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.<br/><br/>Example 3:<br/><br/>Input: items = [[1,1],[2,1],[3,1]], k = 3<br/>Output: 7<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We should select all the items. <br/>The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. <br/>Hence, the maximum elegance is 6 + 1^2 = 7.  <br/> <br/>Constraints:<br/><br/>1 &lt;= items.length == n &lt;= 10^5<br/>items[i].length == 2<br/>items[i][0] == profit_i<br/>items[i][1] == category_i<br/>1 &lt;= profit_i &lt;= 10^9<br/>1 &lt;= category_i &lt;= n <br/>1 &lt;= k &lt;= n </td>
<td>class Solution {<br/>public:<br/>    long long findMaximumElegance(vector&lt;vector&lt;int&gt;&gt;&amp; items, int k) {<br/>/*You are given a 0-indexed 2D integer array items of length n and an integer k.<br/><br/>items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.<br/><br/>Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.<br/><br/>Your task is to find the maximum elegance from all subsequences of size k in items.<br/><br/>Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.<br/><br/>Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.<br/><br/>Example 1:<br/><br/>Input: items = [[3,2],[5,1],[10,1]], k = 2<br/>Output: 17<br/>Explanation: In this example, we have to select a subsequence of size 2.<br/>We can select items[0] = [3,2] and items[2] = [10,1].<br/>The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].<br/>Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. <br/><br/>Example 2:<br/><br/>Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3<br/>Output: 19<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. <br/>The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. <br/>Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.<br/><br/>Example 3:<br/><br/>Input: items = [[1,1],[2,1],[3,1]], k = 3<br/>Output: 7<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We should select all the items. <br/>The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. <br/>Hence, the maximum elegance is 6 + 1^2 = 7.  <br/> <br/>Constraints:<br/><br/>1 &lt;= items.length == n &lt;= 10^5<br/>items[i].length == 2<br/>items[i][0] == profit_i<br/>items[i][1] == category_i<br/>1 &lt;= profit_i &lt;= 10^9<br/>1 &lt;= category_i &lt;= n <br/>1 &lt;= k &lt;= n*/</td>
<td>Class Solution {<br/>Public:<br/>    Long Long Findmaximumelegance(vector&lt;vector&lt;int&gt;&gt;&amp; Items, Int K) {<br/>        Int N = Items.size();<br/>        Vector&lt;pair&lt;int,int&gt;&gt; V;<br/>        For(int I=0;i&lt;n;i++){<br/>            V.push_back({items[i][0],items[i][1]});<br/>        }<br/>        Sort(v.begin(),v.end(),greater&lt;pair&lt;int,int&gt;&gt;());<br/>        Int I=0;<br/>        Long Long Ans = 0;<br/>        Unordered_map&lt;int,int&gt; Mp;<br/>        While(i&lt;n &amp;&amp; K&gt;0){<br/>            If(mp[v[i].second]==0){<br/>                Ans += V[i].first;<br/>                Mp[v[i].second]++;<br/>                K--;<br/>            }<br/>            I++;<br/>        }<br/>        Return Ans + (K*k);<br/>    }<br/>};</td>
<td>Class Solution {<br/>Public:<br/>    Long Long Findmaximumelegance(vector&lt;vector&lt;int&gt;&gt;&amp; A, Int K) {<br/>        Sort(a.begin(), A.end(), [](Const Vector&lt;int&gt;&amp; A, Const Vector&lt;int&gt;&amp; B) {<br/>            Return A[0] &gt; B[0];<br/>        });<br/>        Long Long Res = 0, Cur = 0;<br/>        Vector&lt;int&gt; Dup;<br/>        Unordered_set&lt;int&gt; Seen;<br/>        For (Int I = 0; I &lt; A.size(); ++I) {<br/>            If (I &lt; K) {<br/>                If (Seen.count(a[i][1])) {<br/>                    Dup.push_back(a[i][0]);<br/>                }<br/>                Cur += A[i][0];<br/>            } Else If (Seen.find(a[i][1]) == Seen.end()) {<br/>                If (Dup.empty()) Break;<br/>                Cur += A[i][0] - Dup.back();<br/>                Dup.pop_back();<br/>            }<br/>            Seen.insert(a[i][1]);<br/>            Res = Fmax(res, Cur + 1l * Seen.size() * Seen.size());<br/>        }<br/>        Return Res;<br/>    }<br/>};</td>
</tr>
<tr>
<td align="right">91</td>
<td align="right">1</td>
<td>Java</td>
<td>easy</td>
<td>InstructCodeT5+</td>
<td>HuggingFace Model</td>
<td>You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.<br/><br/>Return the maximum sum or -1 if no such pair exists.<br/><br/>Example 1:<br/><br/>Input: nums = [51,71,17,24,42]<br/>Output: 88<br/>Explanation: <br/>For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. <br/>For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.<br/>It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.<br/><br/>Example 2:<br/><br/>Input: nums = [1,2,3,4]<br/>Output: -1<br/>Explanation: No pair exists in nums with equal maximum digits.<br/><br/>Constraints:<br/><br/>2 &lt;= nums.length &lt;= 100<br/>1 &lt;= nums[i] &lt;= 10^4 </td>
<td>prompt = &quot;&quot;&quot;<br/>You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.<br/><br/>Return the maximum sum or -1 if no such pair exists.<br/><br/>Example 1:<br/><br/>Input: nums = [51,71,17,24,42]<br/>Output: 88<br/>Explanation: <br/>For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. <br/>For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.<br/>It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.<br/><br/>Example 2:<br/><br/>Input: nums = [1,2,3,4]<br/>Output: -1<br/>Explanation: No pair exists in nums with equal maximum digits.<br/><br/>Constraints:<br/><br/>2 &lt;= nums.length &lt;= 100<br/>1 &lt;= nums[i] &lt;= 10^4<br/><br/>class Solution {<br/>    public int maxSum(int[] nums) {<br/>&quot;&quot;&quot;</td>
<td>Class Solution {    <br/>    Public Int Maxsum(int[] Nums) {<br/>        Int Max = Integer.min_value;<br/>        Int Sum = 0;<br/>        For (Int I = 0; I &lt; Nums.length; I++) {<br/>            Sum += Nums[i];<br/>            If (Nums[i] &gt; Max) {<br/>                Max = Nums[i];<br/>            }<br/>            If (Max &gt; 0 &amp;&amp; Nums[i] % Max == 0) {<br/>                Sum -= Nums[i];<br/>            }<br/>        }<br/>        Return Sum;<br/>    }<br/>}</td>
<td>Class Solution {<br/>    Public Int Maxsum(int[] Nums) {<br/>    Int Ans = -1;<br/>    Map&lt;integer,list&lt;integer&gt;&gt; Ump = New Hashmap&lt;&gt;();<br/>    For(int I = 0; I &lt; Nums.length; ++I){<br/>        Int T = Nums[i], Maxdigit = 0;<br/>        While(t != 0){ //Evaluate Max Digit In The Number<br/>            Maxdigit = Math.max(t%10, Maxdigit);<br/>            T = T/10;<br/>        }<br/>        If(!ump.containskey(maxdigit)) Ump.put(maxdigit, New Arraylist&lt;&gt;());<br/>        Ump.get(maxdigit).add(nums[i]); // Add The Number To The Map <br/>    }<br/>    For(map.entry&lt;integer, List&lt;integer&gt;&gt; Entry: Ump.entryset()){<br/>        Entry.getvalue().sort(comparator.reverseorder()); //To Find Max Two Number In Each Max Digit <br/>        If(entry.getvalue().size() &gt;= 2) Ans = Math.max(ans, Entry.getvalue().get(0) + Entry.getvalue().get(1)); //Sum Max Two Number And Take Max<br/>    }<br/>    Return Ans;<br/>    }<br/>}</td>
</tr>
<tr>
<td align="right">92</td>
<td align="right">1</td>
<td>Python</td>
<td>easy</td>
<td>InstructCodeT5+</td>
<td>HuggingFace Model</td>
<td>You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.<br/><br/>Return the maximum sum or -1 if no such pair exists.<br/><br/>Example 1:<br/><br/>Input: nums = [51,71,17,24,42]<br/>Output: 88<br/>Explanation: <br/>For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. <br/>For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.<br/>It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.<br/><br/>Example 2:<br/><br/>Input: nums = [1,2,3,4]<br/>Output: -1<br/>Explanation: No pair exists in nums with equal maximum digits.<br/><br/>Constraints:<br/><br/>2 &lt;= nums.length &lt;= 100<br/>1 &lt;= nums[i] &lt;= 10^4 </td>
<td>prompt = &quot;&quot;&quot;<br/>You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.<br/><br/>Return the maximum sum or -1 if no such pair exists.<br/><br/>Example 1:<br/><br/>Input: nums = [51,71,17,24,42]<br/>Output: 88<br/>Explanation: <br/>For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. <br/>For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.<br/>It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.<br/><br/>Example 2:<br/><br/>Input: nums = [1,2,3,4]<br/>Output: -1<br/>Explanation: No pair exists in nums with equal maximum digits.<br/><br/>Constraints:<br/><br/>2 &lt;= nums.length &lt;= 100<br/>1 &lt;= nums[i] &lt;= 10^4<br/><br/>class Solution:<br/>    def maxSum (self, nums: List[int]) -&gt; int:<br/>&quot;&quot;&quot;</td>
<td>Class Solution:    <br/>    Def Maxsum (Self, Nums: List[int]) -&gt; Int:<br/>        <br/>        Nums.sort()<br/>        <br/>        Max_sum = 0<br/>        <br/>        For I In Range(len(nums)-1):<br/>            If Nums[i] == Nums[i+1]:<br/>                Max_sum = Max(max_sum, Nums[i]*(len(nums)-i-1))<br/>                <br/>        Return Max_sum</td>
<td>Class Solution:<br/>    Def Maxsum(self, Nums: List[int]) -&gt; Int:<br/>        Max_by_digit = Defaultdict(int)<br/>        Max_sum = -1<br/><br/>        For Num In Nums:<br/>            Digit = Max(str(num))<br/><br/>            If Digit In Max_by_digit:<br/>                Max_sum = Max(max_sum, Max_by_digit[digit] + Num)<br/><br/>            Max_by_digit[digit] = Max(max_by_digit[digit], Num)<br/><br/>        Return Max_sum</td>
</tr>
<tr>
<td align="right">93</td>
<td align="right">1</td>
<td>C++</td>
<td>easy</td>
<td>InstructCodeT5+</td>
<td>HuggingFace Model</td>
<td>You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.<br/><br/>Return the maximum sum or -1 if no such pair exists.<br/><br/>Example 1:<br/><br/>Input: nums = [51,71,17,24,42]<br/>Output: 88<br/>Explanation: <br/>For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. <br/>For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.<br/>It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.<br/><br/>Example 2:<br/><br/>Input: nums = [1,2,3,4]<br/>Output: -1<br/>Explanation: No pair exists in nums with equal maximum digits.<br/><br/>Constraints:<br/><br/>2 &lt;= nums.length &lt;= 100<br/>1 &lt;= nums[i] &lt;= 10^4 </td>
<td>prompt = &quot;&quot;&quot;<br/>You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.<br/><br/>Return the maximum sum or -1 if no such pair exists.<br/><br/>Example 1:<br/><br/>Input: nums = [51,71,17,24,42]<br/>Output: 88<br/>Explanation: <br/>For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. <br/>For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.<br/>It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.<br/><br/>Example 2:<br/><br/>Input: nums = [1,2,3,4]<br/>Output: -1<br/>Explanation: No pair exists in nums with equal maximum digits.<br/><br/>Constraints:<br/><br/>2 &lt;= nums.length &lt;= 100<br/>1 &lt;= nums[i] &lt;= 10^4<br/><br/>class Solution {<br/>public:<br/>    int maxSum(vector&lt;int&gt;&amp; nums) {<br/>&quot;&quot;&quot;</td>
<td>Class Solution {<br/>Public:    Int Maxsum(vector&lt;int&gt;&amp; Nums) {<br/>        Int N = Nums.size();<br/>        Int Max_sum = -1;<br/>        Unordered_map&lt;int, Int&gt; Mp;<br/>        For (Int I = 0; I &lt; N; I++) {<br/>            For (Int J = I + 1; J &lt; N; J++) {<br/>                Int Sum = Nums[i] + Nums[j];<br/>                Int Max_digit = 0;<br/>                For (Int K = 0; K &lt; 10; K++) {<br/>                    If (Sum % 10 == K) {<br/>                        Max_digit = Max(max_digit, K);<br/>                    }<br/>                    Sum /= 10;<br/>                }<br/>                If (Mp.find(max_digit)!= Mp.end()) {<br/>                    Max_sum = Max(max_sum, Sum + Mp[max_digit]);<br/>                }<br/>                Mp[max_digit] = Sum;<br/>            }<br/>        }<br/>        Return Max_sum;<br/>    }<br/>};</td>
<td>Class Solution {<br/>    Public:<br/>        Int Maxsum(vector&lt;int&gt;&amp; Nums) {<br/>        Int Res = -1, Max_num[10] = {};<br/>        For (Auto Num : Nums) {<br/>            Int Max_d = 0;<br/>            For (Int V = Num; V; V /= 10)<br/>                Max_d = Max(max_d, V % 10);<br/>            If (Max_num[max_d])<br/>                Res = Max(res, Max_num[max_d] + Num);<br/>            Max_num[max_d] = Max(max_num[max_d], Num);<br/>        }<br/>        Return Res;<br/>    }<br/>};</td>
</tr>
<tr>
<td align="right">94</td>
<td align="right">2</td>
<td>Java</td>
<td>easy</td>
<td>InstructCodeT5+</td>
<td>HuggingFace Model</td>
<td>Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.<br/><br/>You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.<br/><br/>Return the final string that will be present on your laptop screen.<br/><br/>Example 1:<br/><br/>Input: s = &quot;string&quot;<br/>Output: &quot;rtsng&quot;<br/>Explanation: <br/>After typing first character, the text on the screen is &quot;s&quot;.<br/>After the second character, the text is &quot;st&quot;. <br/>After the third character, the text is &quot;str&quot;.<br/>Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.<br/>After the fifth character, the text is &quot;rtsn&quot;. <br/>After the sixth character, the text is &quot;rtsng&quot;. <br/>Therefore, we return &quot;rtsng&quot;.<br/><br/>Example 2:<br/><br/>Input: s = &quot;poiinter&quot;<br/>Output: &quot;ponter&quot;<br/>Explanation: <br/>After the first character, the text on the screen is &quot;p&quot;.<br/>After the second character, the text is &quot;po&quot;. <br/>Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. <br/>Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.<br/>After the fifth character, the text is &quot;pon&quot;.<br/>After the sixth character, the text is &quot;pont&quot;. <br/>After the seventh character, the text is &quot;ponte&quot;. <br/>After the eighth character, the text is &quot;ponter&quot;. <br/>Therefore, we return &quot;ponter&quot;.<br/> <br/>Constraints:<br/><br/>1 &lt;= s.length &lt;= 100<br/>s consists of lowercase English letters.<br/>s[0] != &#39;i&#39;</td>
<td>prompt = &quot;&quot;&quot;<br/>Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.<br/><br/>You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.<br/><br/>Return the final string that will be present on your laptop screen.<br/><br/>Example 1:<br/><br/>Input: s = &quot;string&quot;<br/>Output: &quot;rtsng&quot;<br/>Explanation: <br/>After typing first character, the text on the screen is &quot;s&quot;.<br/>After the second character, the text is &quot;st&quot;. <br/>After the third character, the text is &quot;str&quot;.<br/>Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.<br/>After the fifth character, the text is &quot;rtsn&quot;. <br/>After the sixth character, the text is &quot;rtsng&quot;. <br/>Therefore, we return &quot;rtsng&quot;.<br/><br/>Example 2:<br/><br/>Input: s = &quot;poiinter&quot;<br/>Output: &quot;ponter&quot;<br/>Explanation: <br/>After the first character, the text on the screen is &quot;p&quot;.<br/>After the second character, the text is &quot;po&quot;. <br/>Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. <br/>Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.<br/>After the fifth character, the text is &quot;pon&quot;.<br/>After the sixth character, the text is &quot;pont&quot;. <br/>After the seventh character, the text is &quot;ponte&quot;. <br/>After the eighth character, the text is &quot;ponter&quot;. <br/>Therefore, we return &quot;ponter&quot;.<br/> <br/>Constraints:<br/><br/>1 &lt;= s.length &lt;= 100<br/>s consists of lowercase English letters.<br/>s[0] != &#39;i&#39;<br/><br/>public class Solution {<br/>    public String finalString(String s) {<br/>&quot;&quot;&quot;</td>
<td>Public Class Solution {    <br/>    Public String Finalstring(string S) {<br/>        Stringbuilder Sb = New Stringbuilder();<br/>        For (Int I = 0; I &lt; S.length(); I++) {<br/>            Char C = S.charat(i);<br/>            If (C == &#39;I&#39;) {<br/>                Sb.append(c);<br/>            } Else {<br/>                Sb.append(c);<br/>                Sb.append(c);<br/>            }<br/>        }<br/>        Return Sb.tostring();<br/>    }<br/>}</td>
<td>Class Solution {<br/>    Public String Finalstring(string S) {<br/>        Stringbuilder Nm=new Stringbuilder();<br/>        For(char C:s.tochararray())<br/>        {<br/>            If(c==&#39;i&#39;)<br/>            {<br/>                Nm.reverse();<br/>            }<br/>            Else<br/>            {<br/>                Nm.append(c);<br/>            }<br/>        }<br/>        Return Nm.tostring();<br/>    }<br/>}</td>
</tr>
<tr>
<td align="right">95</td>
<td align="right">2</td>
<td>Python</td>
<td>easy</td>
<td>InstructCodeT5+</td>
<td>HuggingFace Model</td>
<td>Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.<br/><br/>You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.<br/><br/>Return the final string that will be present on your laptop screen.<br/><br/>Example 1:<br/><br/>Input: s = &quot;string&quot;<br/>Output: &quot;rtsng&quot;<br/>Explanation: <br/>After typing first character, the text on the screen is &quot;s&quot;.<br/>After the second character, the text is &quot;st&quot;. <br/>After the third character, the text is &quot;str&quot;.<br/>Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.<br/>After the fifth character, the text is &quot;rtsn&quot;. <br/>After the sixth character, the text is &quot;rtsng&quot;. <br/>Therefore, we return &quot;rtsng&quot;.<br/><br/>Example 2:<br/><br/>Input: s = &quot;poiinter&quot;<br/>Output: &quot;ponter&quot;<br/>Explanation: <br/>After the first character, the text on the screen is &quot;p&quot;.<br/>After the second character, the text is &quot;po&quot;. <br/>Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. <br/>Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.<br/>After the fifth character, the text is &quot;pon&quot;.<br/>After the sixth character, the text is &quot;pont&quot;. <br/>After the seventh character, the text is &quot;ponte&quot;. <br/>After the eighth character, the text is &quot;ponter&quot;. <br/>Therefore, we return &quot;ponter&quot;.<br/> <br/>Constraints:<br/><br/>1 &lt;= s.length &lt;= 100<br/>s consists of lowercase English letters.<br/>s[0] != &#39;i&#39;</td>
<td>prompt = &quot;&quot;&quot;<br/>class Solution:<br/>    def finalString(self, s: str) -&gt; str:<br/><br/>Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.<br/><br/>You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.<br/><br/>Return the final string that will be present on your laptop screen.<br/><br/>Example 1:<br/><br/>Input: s = &quot;string&quot;<br/>Output: &quot;rtsng&quot;<br/><br/>Example 2:<br/><br/>Input: s = &quot;poiinter&quot;<br/>Output: &quot;ponter&quot;<br/> <br/>Constraints:<br/><br/>1 &lt;= s.length &lt;= 100<br/>s consists of lowercase English letters.<br/>s[0] != &#39;i&#39;<br/>&quot;&quot;&quot;</td>
<td>Class Solution:<br/>    Def Finalstring(self, S: Str) -&gt; Str:<br/>        Res = &quot;&quot;<br/>        For I In S:<br/>            If I!= &#39;I&#39;:<br/>                Res += I<br/>            Else:<br/>                Res = Res[::-1]<br/>        Return Res</td>
<td>Class Solution:<br/>    Def Finalstring(self, S: Str) -&gt; Str:<br/>        While &quot;I&quot; In S:<br/>            Index=s.index(&quot;i&quot;)<br/><br/>            #First Half And Second Half<br/>            First=s[:index][::-1]<br/>            Second=s[index+1:]<br/><br/>            S=&quot;&quot;.join([first,second])<br/>        Return S</td>
</tr>
<tr>
<td align="right">96</td>
<td align="right">2</td>
<td>C++</td>
<td>easy</td>
<td>InstructCodeT5+</td>
<td>HuggingFace Model</td>
<td>Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.<br/><br/>You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.<br/><br/>Return the final string that will be present on your laptop screen.<br/><br/>Example 1:<br/><br/>Input: s = &quot;string&quot;<br/>Output: &quot;rtsng&quot;<br/>Explanation: <br/>After typing first character, the text on the screen is &quot;s&quot;.<br/>After the second character, the text is &quot;st&quot;. <br/>After the third character, the text is &quot;str&quot;.<br/>Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.<br/>After the fifth character, the text is &quot;rtsn&quot;. <br/>After the sixth character, the text is &quot;rtsng&quot;. <br/>Therefore, we return &quot;rtsng&quot;.<br/><br/>Example 2:<br/><br/>Input: s = &quot;poiinter&quot;<br/>Output: &quot;ponter&quot;<br/>Explanation: <br/>After the first character, the text on the screen is &quot;p&quot;.<br/>After the second character, the text is &quot;po&quot;. <br/>Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. <br/>Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.<br/>After the fifth character, the text is &quot;pon&quot;.<br/>After the sixth character, the text is &quot;pont&quot;. <br/>After the seventh character, the text is &quot;ponte&quot;. <br/>After the eighth character, the text is &quot;ponter&quot;. <br/>Therefore, we return &quot;ponter&quot;.<br/> <br/>Constraints:<br/><br/>1 &lt;= s.length &lt;= 100<br/>s consists of lowercase English letters.<br/>s[0] != &#39;i&#39;</td>
<td>prompt = &quot;&quot;&quot;<br/>class Solution {<br/>public:<br/>    string finalString(string s) {<br/>/*Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.<br/><br/>You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.<br/><br/>Return the final string that will be present on your laptop screen.<br/><br/>Example 1:<br/><br/>Input: s = &quot;string&quot;<br/>Output: &quot;rtsng&quot;<br/>Explanation: <br/>After typing first character, the text on the screen is &quot;s&quot;.<br/>After the second character, the text is &quot;st&quot;. <br/>After the third character, the text is &quot;str&quot;.<br/>Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.<br/>After the fifth character, the text is &quot;rtsn&quot;. <br/>After the sixth character, the text is &quot;rtsng&quot;. <br/>Therefore, we return &quot;rtsng&quot;.<br/><br/>Example 2:<br/><br/>Input: s = &quot;poiinter&quot;<br/>Output: &quot;ponter&quot;<br/>Explanation: <br/>After the first character, the text on the screen is &quot;p&quot;.<br/>After the second character, the text is &quot;po&quot;. <br/>Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. <br/>Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.<br/>After the fifth character, the text is &quot;pon&quot;.<br/>After the sixth character, the text is &quot;pont&quot;. <br/>After the seventh character, the text is &quot;ponte&quot;. <br/>After the eighth character, the text is &quot;ponter&quot;. <br/>Therefore, we return &quot;ponter&quot;.<br/> <br/>Constraints:<br/><br/>1 &lt;= s.length &lt;= 100<br/>s consists of lowercase English letters.<br/>s[0] != &#39;i&#39;*/<br/>&quot;&quot;&quot;</td>
<td>Class Solution {<br/>Public:    <br/>    String Finalstring(string S) {<br/>        String Res = &quot;&quot;;<br/>        For (Int I = 0; I &lt; S.length(); I++) {<br/>            Res += S[s.length() - I - 1];<br/>        }<br/>        Return Res;<br/>    }<br/>};</td>
<td>Class Solution {<br/>Public:<br/>    String Finalstring(const String &amp;S) {<br/>        String A, B;<br/>        For (Char Ch : S)<br/>            If (Ch == &#39;I&#39;)<br/>                Swap(a, B);<br/>            Else<br/>                A += Ch;<br/>        Return String(rbegin(b), Rend(b)) + A;<br/>    }<br/>};</td>
</tr>
<tr>
<td align="right">97</td>
<td align="right">3</td>
<td>Java</td>
<td>medium</td>
<td>InstructCodeT5+</td>
<td>HuggingFace Model</td>
<td>You are given a 0-indexed integer array nums and an integer x.<br/><br/>Find the minimum absolute difference between two elements in the array that are at least x indices apart.<br/><br/>In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.<br/><br/>Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.<br/><br/>Example 1:<br/><br/>Input: nums = [4,3,2,4], x = 2<br/>Output: 0<br/>Explanation: We can select nums[0] = 4 and nums[3] = 4. <br/>They are at least 2 indices apart, and their absolute difference is the minimum, 0. <br/>It can be shown that 0 is the optimal answer.<br/><br/>Example 2:<br/><br/>Input: nums = [5,3,2,10,15], x = 1<br/>Output: 1<br/>Explanation: We can select nums[1] = 3 and nums[2] = 2.<br/>They are at least 1 index apart, and their absolute difference is the minimum, 1.<br/>It can be shown that 1 is the optimal answer.<br/><br/>Example 3:<br/><br/>Input: nums = [1,2,3,4], x = 3<br/>Output: 3<br/>Explanation: We can select nums[0] = 1 and nums[3] = 4.<br/>They are at least 3 indices apart, and their absolute difference is the minimum, 3.<br/>It can be shown that 3 is the optimal answer.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^9<br/>0 &lt;= x &lt; nums.length </td>
<td>prompt = &quot;&quot;&quot;<br/><br/>class Solution {<br/>    public int minAbsoluteDifference(List&lt;Integer&gt; nums, int x) {<br/><br/>/*You are given a 0-indexed integer List&lt;&gt; nums and an integer x.<br/><br/>Find the minimum absolute difference between two elements in the List that are at least x indices apart.<br/><br/>In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums.get(i) - nums.get(i)) is minimized.<br/>Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.size() &lt;= 10^5<br/>1 &lt;= nums.get(i) &lt;= 10^9<br/>0 &lt;= x &lt; nums.size()<br/>*/<br/>&quot;&quot;&quot;</td>
<td>Class Solution {<br/>    Int Minabsolutedifference(list&lt;integer&gt; Nums, Int X) {<br/>        Int Min = Integer.max_value;<br/>        Int Max = Integer.min_value;<br/>        For (Int I = 0; I &lt; Nums.size(); I++) {<br/>            If (Nums.get(i) &lt; Min) {<br/>                Min = Nums.get(i);<br/>            }<br/>            If (Nums.get(i) &gt; Max) {<br/>                Max = Nums.get(i);<br/>            }<br/>        }<br/>        Int Diff = Integer.max_value;<br/>        For (Int I = 0; I &lt; Nums.size(); I++) {<br/>            If (Math.abs(nums.get(i) - Min) &gt;= X) {<br/>                Diff = Math.min(diff, Math.abs(nums.get(i) - Min));<br/>            }<br/>            If (Math.abs(nums.get(i) - Max) &gt;= X) {<br/>                Diff = Math.min(diff, Math.abs(nums.get(i) - Max));<br/>            }<br/>        }<br/>        Return Diff;<br/>    }<br/>}</td>
<td>Class Solution {<br/>    Int Minabsolutedifference(list&lt;integer&gt; Nums, Int X) {<br/>        Int Ans = Integer.max_value;<br/>        Treeset&lt;integer&gt; S = New Treeset&lt;&gt;();<br/>        For(int I = X; I &lt; Nums.size(); ++I){<br/>            S.add(nums.get(i-x));<br/>            Integer High = S.ceiling(nums.get(i)), Low = S.floor(nums.get(i));<br/>            If(high != Null) Ans = Math.min(ans, Math.abs(nums.get(i) - High));<br/>            If(low != Null) Ans = Math.min(ans, Math.abs(nums.get(i) - Low));<br/>        }<br/>        Return Ans;<br/>    }<br/>}</td>
</tr>
<tr>
<td align="right">98</td>
<td align="right">3</td>
<td>Python</td>
<td>medium</td>
<td>InstructCodeT5+</td>
<td>HuggingFace Model</td>
<td>You are given a 0-indexed integer array nums and an integer x.<br/><br/>Find the minimum absolute difference between two elements in the array that are at least x indices apart.<br/><br/>In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.<br/><br/>Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.<br/><br/>Example 1:<br/><br/>Input: nums = [4,3,2,4], x = 2<br/>Output: 0<br/>Explanation: We can select nums[0] = 4 and nums[3] = 4. <br/>They are at least 2 indices apart, and their absolute difference is the minimum, 0. <br/>It can be shown that 0 is the optimal answer.<br/><br/>Example 2:<br/><br/>Input: nums = [5,3,2,10,15], x = 1<br/>Output: 1<br/>Explanation: We can select nums[1] = 3 and nums[2] = 2.<br/>They are at least 1 index apart, and their absolute difference is the minimum, 1.<br/>It can be shown that 1 is the optimal answer.<br/><br/>Example 3:<br/><br/>Input: nums = [1,2,3,4], x = 3<br/>Output: 3<br/>Explanation: We can select nums[0] = 1 and nums[3] = 4.<br/>They are at least 3 indices apart, and their absolute difference is the minimum, 3.<br/>It can be shown that 3 is the optimal answer.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^9<br/>0 &lt;= x &lt; nums.length </td>
<td>prompt = &quot;&quot;&quot;<br/>class Solution:<br/>    def minAbsoluteDifference(self, nums: List[int], x: int) -&gt; int:<br/>You are given a 0-indexed integer array nums and an integer x.<br/><br/>Find the minimum absolute difference between two elements in the array that are at least x indices apart.<br/><br/>In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.<br/><br/>Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.<br/><br/>Example 1:<br/><br/>Input: nums = [4,3,2,4], x = 2<br/>Output: 0<br/>Explanation: We can select nums[0] = 4 and nums[3] = 4. <br/>They are at least 2 indices apart, and their absolute difference is the minimum, 0. <br/>It can be shown that 0 is the optimal answer.<br/><br/>Example 2:<br/><br/>Input: nums = [5,3,2,10,15], x = 1<br/>Output: 1<br/>Explanation: We can select nums[1] = 3 and nums[2] = 2.<br/>They are at least 1 index apart, and their absolute difference is the minimum, 1.<br/>It can be shown that 1 is the optimal answer.<br/><br/>Example 3:<br/><br/>Input: nums = [1,2,3,4], x = 3<br/>Output: 3<br/>Explanation: We can select nums[0] = 1 and nums[3] = 4.<br/>They are at least 3 indices apart, and their absolute difference is the minimum, 3.<br/>It can be shown that 3 is the optimal answer.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^9<br/>0 &lt;= x &lt; nums.length <br/>&quot;&quot;&quot;</td>
<td>Class Solution:<br/>    Def Minabsolutedifference(self, Nums: List[int], X: Int) -&gt; Int:<br/>        Nums.sort()<br/>        Res = Float(&#39;inf&#39;)<br/>        For I In Range(len(nums)-1):<br/>            Res = Min(res, Abs(nums[i]-nums[i+1]))<br/>        Return Res</td>
<td>Class Solution:<br/>  Def Minabsolutedifference(self, Nums: List[int], X: Int) -&gt; Int:<br/>    If X == 0:<br/>      Return 0<br/><br/>    Arr, Best_dist = Sortedlist([]), Float(&#39;inf&#39;)<br/>    For I In Range(x, Len(nums)):<br/>      Arr.add(nums[i - X])<br/>      V = Nums[i]<br/><br/>      Pos = Arr.bisect_left(v)<br/>      If Pos &lt; Len(arr):<br/>        Best_dist = Min(best_dist, Abs(arr[pos] - V))<br/>      If Pos &gt; 0:<br/>        Best_dist = Min(best_dist, Abs(arr[pos - 1] - V))<br/>    <br/>    Return Best_dist</td>
</tr>
<tr>
<td align="right">99</td>
<td align="right">3</td>
<td>C++</td>
<td>medium</td>
<td>InstructCodeT5+</td>
<td>HuggingFace Model</td>
<td>You are given a 0-indexed integer array nums and an integer x.<br/><br/>Find the minimum absolute difference between two elements in the array that are at least x indices apart.<br/><br/>In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.<br/><br/>Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.<br/><br/>Example 1:<br/><br/>Input: nums = [4,3,2,4], x = 2<br/>Output: 0<br/>Explanation: We can select nums[0] = 4 and nums[3] = 4. <br/>They are at least 2 indices apart, and their absolute difference is the minimum, 0. <br/>It can be shown that 0 is the optimal answer.<br/><br/>Example 2:<br/><br/>Input: nums = [5,3,2,10,15], x = 1<br/>Output: 1<br/>Explanation: We can select nums[1] = 3 and nums[2] = 2.<br/>They are at least 1 index apart, and their absolute difference is the minimum, 1.<br/>It can be shown that 1 is the optimal answer.<br/><br/>Example 3:<br/><br/>Input: nums = [1,2,3,4], x = 3<br/>Output: 3<br/>Explanation: We can select nums[0] = 1 and nums[3] = 4.<br/>They are at least 3 indices apart, and their absolute difference is the minimum, 3.<br/>It can be shown that 3 is the optimal answer.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^9<br/>0 &lt;= x &lt; nums.length </td>
<td>prompt = &quot;&quot;&quot;<br/>/*You are given a 0-indexed integer List&lt;&gt; nums and an integer x.<br/><br/>Find the minimum absolute difference between two elements in the List that are at least x indices apart.<br/><br/>In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums.get(i) - nums.get(i)) is minimized.<br/><br/>Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.size() &lt;= 10^5<br/>1 &lt;= nums.get(i) &lt;= 10^9<br/>0 &lt;= x &lt; nums.size()<br/>*/<br/><br/>class Solution {<br/>public:<br/>    int minAbsoluteDifference(vector&lt;int&gt;&amp; nums, int x) {<br/>&quot;&quot;&quot;</td>
<td>Class Solution {<br/>Public:    <br/>    Int Minabsolutedifference(vector&lt;int&gt;&amp; Nums, Int X) {<br/>        Int Min = Int_max;<br/>        Int N = Nums.size();<br/>        For (Int I = 0; I &lt; N; I++) {<br/>            For (Int J = I + 1; J &lt; N; J++) {<br/>                If (Abs(nums[i] - Nums[j]) &gt;= X)<br/>                    Continue;<br/>                Min = Min &lt; Abs(nums[i] - Nums[j])? Abs(nums[i] - Nums[j]) : Min;<br/>            }<br/>        }<br/>        Return Min;<br/>    }<br/>};</td>
<td>Class Solution {<br/>Public:<br/>    Int Minabsolutedifference(vector&lt;int&gt;&amp; Nums, Int X) {<br/>        Int Ans = Int_max;<br/>        Set&lt;int&gt; S;<br/>        For(int I = X; I &lt; Nums.size(); ++I){<br/>            S.insert(nums[i-x]);<br/>            Auto It = S.upper_bound(nums[i]);<br/>            If(it != S.end()) Ans = Min(ans, Abs(nums[i] - *It));<br/>            If(it != S.begin()) Ans = Min(ans, Abs(nums[i] - *Prev(it)));<br/>        }<br/>        Return Ans;<br/>    }<br/>};</td>
</tr>
<tr>
<td align="right">100</td>
<td align="right">4</td>
<td>Java</td>
<td>medium</td>
<td>InstructCodeT5+</td>
<td>HuggingFace Model</td>
<td>You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.<br/><br/>Return the head of the linked list after doubling it.<br/><br/>Example 1:<br/><br/>Input: head = [1,8,9]<br/>Output: [3,7,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.<br/><br/>Example 2:<br/><br/>Input: head = [9,9,9]<br/>Output: [1,9,9,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. <br/><br/>Constraints:<br/><br/>The number of nodes in the list is in the range [1, 10^4]<br/>0 &lt;= Node.val &lt;= 9<br/>The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself. </td>
<td>prompt = &quot;&quot;&quot;<br/>class Solution {<br/>    public ListNode doubleIt(ListNode head) {<br/>/*You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.<br/><br/>Return the head of the linked list after doubling it.<br/><br/>Example 1:<br/><br/>Input: head = [1,8,9]<br/>Output: [3,7,8]<br/><br/>Example 2:<br/><br/>Input: head = [9,9,9]<br/>Output: [1,9,9,8]<br/><br/>Constraints:<br/><br/>The number of nodes in the list is in the range [1, 10^4]<br/>0 &lt;= Node.val &lt;= 9<br/>The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.*/<br/>&quot;&quot;&quot;</td>
<td>Class Solution {<br/>    Public Listnode Doubleit(listnode Head) {<br/>        Listnode Curr = Head;<br/>        Int Currval = 0;<br/>        While (Curr!= Null) {<br/>            Currval += Curr.val;<br/>            Curr.val = Currval;<br/>            Curr = Curr.next;<br/>        }<br/>        Curr = Head;<br/>        While (Curr!= Null) {<br/>            Curr.val = Curr.val * 2;<br/>            Curr = Curr.next;<br/>        }<br/>        Return Head;<br/>    }<br/>}</td>
<td>Class Solution {<br/>    Public Listnode Doubleit(listnode Head) {<br/>        If (Head.val &gt; 4)<br/>            Head = New Listnode(0, Head);<br/>        For(listnode Node = Head; Node != Null; Node = Node.next) {<br/>            Node.val = (Node.val * 2) % 10;<br/>            If (Node.next != Null &amp;&amp; Node.next.val &gt; 4)<br/>                Node.val++;<br/>        }<br/>        Return Head;<br/>    }<br/>}</td>
</tr>
<tr>
<td align="right">101</td>
<td align="right">4</td>
<td>Python</td>
<td>medium</td>
<td>InstructCodeT5+</td>
<td>HuggingFace Model</td>
<td>You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.<br/><br/>Return the head of the linked list after doubling it.<br/><br/>Example 1:<br/><br/>Input: head = [1,8,9]<br/>Output: [3,7,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.<br/><br/>Example 2:<br/><br/>Input: head = [9,9,9]<br/>Output: [1,9,9,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. <br/><br/>Constraints:<br/><br/>The number of nodes in the list is in the range [1, 10^4]<br/>0 &lt;= Node.val &lt;= 9<br/>The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself. </td>
<td>prompt = &quot;&quot;&quot;<br/>class Solution:<br/>    def doubleIt(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:<br/>You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.<br/><br/>Return the head of the linked list after doubling it.<br/><br/>Example 1:<br/><br/>Input: head = [1,8,9]<br/>Output: [3,7,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.<br/><br/>Example 2:<br/><br/>Input: head = [9,9,9]<br/>Output: [1,9,9,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. <br/><br/>Constraints:<br/><br/>The number of nodes in the list is in the range [1, 10^4]<br/>0 &lt;= Node.val &lt;= 9<br/>The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.<br/>&quot;&quot;&quot;</td>
<td>Class Solution:<br/>    Def Doubleit(self, Head: Optional[listnode]) -&gt; Optional[listnode]:<br/>        If Not Head:<br/>            Return Head<br/>        <br/>        Curr = Head<br/>        While Curr:<br/>            Curr.val *= 2<br/>            Curr = Curr.next<br/>        Return Head</td>
<td>Class Solution:<br/>    Def Doubleit(self, Head: Optional[listnode]) -&gt; Optional[listnode]:<br/>        If Head.val &gt; 4:<br/>            Head = Listnode(0, Head)<br/>        Node = Head<br/>        While Node:<br/>            Node.val = (Node.val * 2) % 10<br/>            If Node.next And Node.next.val &gt; 4:<br/>                Node.val += 1<br/>            Node = Node.next<br/>        Return Head</td>
</tr>
<tr>
<td align="right">102</td>
<td align="right">4</td>
<td>C++</td>
<td>medium</td>
<td>InstructCodeT5+</td>
<td>HuggingFace Model</td>
<td>You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.<br/><br/>Return the head of the linked list after doubling it.<br/><br/>Example 1:<br/><br/>Input: head = [1,8,9]<br/>Output: [3,7,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.<br/><br/>Example 2:<br/><br/>Input: head = [9,9,9]<br/>Output: [1,9,9,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. <br/><br/>Constraints:<br/><br/>The number of nodes in the list is in the range [1, 10^4]<br/>0 &lt;= Node.val &lt;= 9<br/>The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself. </td>
<td>prompt = &quot;&quot;&quot;<br/>/*You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.<br/><br/>Return the head of the linked list after doubling it.<br/><br/>Example 1:<br/><br/>Input: head = [1,8,9]<br/>Output: [3,7,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.<br/><br/>Example 2:<br/><br/>Input: head = [9,9,9]<br/>Output: [1,9,9,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. <br/><br/>Constraints:<br/><br/>The number of nodes in the list is in the range [1, 10^4]<br/>0 &lt;= Node.val &lt;= 9<br/>The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself. <br/>*/<br/><br/>class Solution {<br/>public:<br/>    ListNode* doubleIt(ListNode* head) {<br/>&quot;&quot;&quot;</td>
<td>Class Solution {<br/>Public:    <br/>    Listnode* Doubleit(listnode* Head) {<br/>        If(head == Null) Return Null;<br/>        Listnode* Cur = Head;<br/>        Listnode* Pre = Null;<br/>        Listnode* Next = Null;<br/>        While(cur!= Null) {<br/>            Next = Cur-&gt;next;<br/>            Cur-&gt;next = Pre;<br/>            Pre = Cur;<br/>            Cur = Next;<br/>        }<br/>        Cur = Pre;<br/>        While(cur!= Null) {<br/>            Cur-&gt;val *= 2;<br/>            Cur = Cur-&gt;next;<br/>        }<br/>        Return Pre;<br/>    }<br/>};</td>
<td>Class Solution {<br/>Public:<br/>    Listnode* Doubleit(listnode* Head) {<br/>        If (Head-&gt;val &gt; 4)<br/>            Head = New Listnode(0, Head);<br/>        For(listnode* Node = Head; Node; Node = Node-&gt;next) {<br/>            Node-&gt;val = (Node-&gt;val * 2) % 10;<br/>            If (Node-&gt;next &amp;&amp; Node-&gt;next-&gt;val &gt; 4)<br/>                Node-&gt;val++;<br/>        }<br/>        Return Head;<br/>    }<br/>};</td>
</tr>
<tr>
<td align="right">103</td>
<td align="right">5</td>
<td>Java</td>
<td>hard</td>
<td>InstructCodeT5+</td>
<td>HuggingFace Model</td>
<td>You are given an array nums of n positive integers and an integer k.<br/><br/>Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:<br/><br/>Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.<br/>Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.<br/>Multiply your score by x.<br/>Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.<br/><br/>The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.<br/><br/>Return the maximum possible score after applying at most k operations.<br/><br/>Since the answer may be large, return it modulo 10^9 + 7.<br/><br/>Example 1:<br/><br/>Input: nums = [8,3,9,3,8], k = 2<br/>Output: 81<br/>Explanation: To get a score of 81, we can apply the following operations:<br/>- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.<br/>It can be proven that 81 is the highest score one can obtain.<br/><br/>Example 2:<br/><br/>Input: nums = [19,12,14,6,10,18], k = 3<br/>Output: 4788<br/>Explanation: To get a score of 4788, we can apply the following operations: <br/>- Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.<br/>- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.<br/>It can be proven that 4788 is the highest score one can obtain.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length == n &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^5<br/>1 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9) </td>
<td>prompt = &quot;&quot;&quot;<br/>You are given an array nums of n positive integers and an integer k.<br/><br/>Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:<br/><br/>Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.<br/>Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.<br/>Multiply your score by x.<br/>Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.<br/><br/>The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.<br/><br/>Return the maximum possible score after applying at most k operations.<br/><br/>Since the answer may be large, return it modulo 10^9 + 7.<br/><br/>Example 1:<br/><br/>Input: nums = [8,3,9,3,8], k = 2<br/>Output: 81<br/><br/>Example 2:<br/><br/>Input: nums = [19,12,14,6,10,18], k = 3<br/>Output: 4788<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length == n &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^5<br/>1 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9)<br/><br/>class Solution {<br/>    public int maximumScore(List&lt;Integer&gt; nums, int k) {<br/>&quot;&quot;&quot;</td>
<td>Class Solution {    Public Int Maximumscore(list&lt;integer&gt; Nums, Int K) {<br/>        Int N = Nums.size();<br/>        Int[] Primes = New Int[n];<br/>        Int[] Scores = New Int[n];<br/>        Arrays.fill(primes, -1);<br/>        Arrays.fill(scores, 1);<br/>        <br/>        For (Int I = 0; I &lt; N; I++) {<br/>            Primes[i] = Getprime(nums.get(i));<br/>        }<br/>        <br/>        Int Maxscore = 0;<br/>        For (Int I = 0; I &lt; N; I++) {<br/>            For (Int J = I + 1; J &lt; N; J++) {<br/>                Int L = Math.max(i, Primes[i] - 1);<br/>                Int R = Math.min(j, Primes[j] - 1);<br/>                Int Score = (R - L + 1) * Scores[j];<br/>                If (Score &gt; Maxscore) {<br/>                    Maxscore = Score;<br/>                }<br/>            }<br/>        }<br/>        <br/>        Return (Int) (Maxscore % (1e9 + 7));<br/>    }<br/>    <br/>    Private Int Getprime(int Num) {<br/>        Int Res = Num;<br/>        For (Int I = 2; I * I &lt;= Num; I++) {<br/>            If (Num % I == 0) {<br/>                Res = I;<br/>                Break;<br/>            }<br/>        }<br/>        Return Res;<br/>    }<br/>}</td>
<td>Class Solution {<br/>    Static Final Int Mod = 1000000007;<br/><br/>    Public Int Maximumscore(list&lt;integer&gt; Nums, Int K) {<br/>        Int N = Nums.size();<br/><br/>        Int Upper = Collections.max(nums) + 1;<br/><br/>        Boolean[] Prime = New Boolean[upper];<br/>        Int[] Primescore = New Int[upper];<br/>        Arrays.fill(prime, True);<br/>        Prime[0] = Prime[1] = False;<br/>        For (Int I = 2; I &lt; Upper; I++) {<br/>            If (Prime[i]) {<br/>                For (Int J = I; J &lt; Upper; J += I) {<br/>                    Primescore[j]++;<br/>                    Prime[j] = False;<br/>                }<br/>            }<br/>        }<br/><br/>        Int[] Nextgreaterelement = New Int[n];<br/>        Arrays.fill(nextgreaterelement, N);<br/>        Stack&lt;integer&gt; S = New Stack&lt;&gt;();<br/>        For (Int I = N - 1; I &gt;= 0; I--) {<br/>            While (!S.empty() &amp;&amp; Primescore[nums.get(i)] &gt;= Primescore[nums.get(s.peek())]) {<br/>                S.pop();<br/>            }<br/>            Nextgreaterelement[i] = S.empty() ? N : S.peek();<br/>            S.push(i);<br/>        }<br/><br/>        Int[] Prevgreaterorequalelement = New Int[n];<br/>        Arrays.fill(prevgreaterorequalelement, -1);<br/>        S = New Stack&lt;&gt;();<br/>        For (Int I = 0; I &lt; N; I++) {<br/>            While (!S.empty() &amp;&amp; Primescore[nums.get(i)] &gt; Primescore[nums.get(s.peek())]) {<br/>                S.pop();<br/>            }<br/>            Prevgreaterorequalelement[i] = S.empty() ? -1 : S.peek();<br/>            S.push(i);<br/>        }<br/><br/>        Int Res = 1;<br/>        Int[][] Tuples = New Int[n][2];<br/>        For (Int I = 0; I &lt; N; I++) {<br/>            Tuples[i][0] = Nums.get(i);<br/>            Tuples[i][1] = I;<br/>        }<br/>        Arrays.sort(tuples, New Comparator&lt;int[]&gt;() {<br/>            Public Int Compare(int[] A, Int[] B) {<br/>                Return B[0] - A[0];<br/>            }<br/>        });<br/>        For (Int I = 0; I &lt; N; I++) {<br/>            Int Num = Tuples[i][0];<br/>            Int Idx = Tuples[i][1];<br/>            Int Operations = Math.min((idx - Prevgreaterorequalelement[idx]) * (Nextgreaterelement[idx] - Idx), K);<br/>            Res = (Int)((1l * Res * Pow(num, Operations)) % Mod);<br/>            K -= Operations;<br/>            If (K == 0) {<br/>                Return Res;<br/>            }<br/>        }<br/><br/>        Return Res;<br/>    }<br/><br/>    Public Int Pow(int X, Int N) {<br/>        Int Res = 1;<br/>        While (N &gt; 0) {<br/>            If (N % 2 == 1) {<br/>                Res = (Int)((1l * Res * X) % Mod);<br/>            }<br/>            X = (Int)((1l * X * X) % Mod);<br/>            N /= 2;<br/>        }<br/>        Return Res;<br/>    }<br/>}</td>
</tr>
<tr>
<td align="right">104</td>
<td align="right">5</td>
<td>Python</td>
<td>hard</td>
<td>InstructCodeT5+</td>
<td>HuggingFace Model</td>
<td>You are given an array nums of n positive integers and an integer k.<br/><br/>Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:<br/><br/>Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.<br/>Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.<br/>Multiply your score by x.<br/>Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.<br/><br/>The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.<br/><br/>Return the maximum possible score after applying at most k operations.<br/><br/>Since the answer may be large, return it modulo 10^9 + 7.<br/><br/>Example 1:<br/><br/>Input: nums = [8,3,9,3,8], k = 2<br/>Output: 81<br/>Explanation: To get a score of 81, we can apply the following operations:<br/>- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.<br/>It can be proven that 81 is the highest score one can obtain.<br/><br/>Example 2:<br/><br/>Input: nums = [19,12,14,6,10,18], k = 3<br/>Output: 4788<br/>Explanation: To get a score of 4788, we can apply the following operations: <br/>- Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.<br/>- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.<br/>It can be proven that 4788 is the highest score one can obtain.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length == n &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^5<br/>1 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9) </td>
<td>prompt = &quot;&quot;&quot;<br/>You are given an array nums of n positive integers and an integer k.<br/><br/>Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:<br/><br/>Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.<br/>Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.<br/>Multiply your score by x.<br/>Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.<br/><br/>The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.<br/><br/>Return the maximum possible score after applying at most k operations.<br/><br/>Since the answer may be large, return it modulo 10^9 + 7.<br/><br/>Example 1:<br/><br/>Input: nums = [8,3,9,3,8], k = 2<br/>Output: 81<br/>Explanation: To get a score of 81, we can apply the following operations:<br/>- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.<br/>It can be proven that 81 is the highest score one can obtain.<br/><br/>Example 2:<br/><br/>Input: nums = [19,12,14,6,10,18], k = 3<br/>Output: 4788<br/>Explanation: To get a score of 4788, we can apply the following operations: <br/>- Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.<br/>- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.<br/>It can be proven that 4788 is the highest score one can obtain.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length == n &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^5<br/>1 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9)<br/><br/>class Solution:<br/>    def maximumScore(self, nums: List[int], k: int) -&gt; int:<br/>&quot;&quot;&quot;</td>
<td>Class Solution:    <br/>    Def Maximumscore(self, Nums: List[int], K: Int) -&gt; Int:<br/>        <br/>        N = Len(nums)<br/>        <br/>        @Lru_cache(none)<br/>        Def Dp(l, R, K):<br/>            If K == 0:<br/>                Return 0<br/>            If L &gt; R:<br/>                Return 0<br/>            If L == R:<br/>                Return Nums[l]<br/>            <br/>            Res = 0<br/>            For I In Range(l, R + 1):<br/>                If I == L:<br/>                    Res = Max(res, Dp(l + 1, R, K - 1))<br/>                Elif I == R:<br/>                    Res = Max(res, Dp(l, R - 1, K - 1))<br/>                Else:<br/>                    Res = Max(res, Dp(l + 1, R, K - 1) + Nums[i] * Nums[i])<br/>                    Res = Max(res, Dp(l, R - 1, K - 1) + Nums[i] * Nums[i])<br/>            Return Res % (10**9 + 7)<br/>        <br/>        Return Dp(0, N - 1, K)</td>
<td>Class Solution: <br/>    Mod = 1000000007<br/><br/>    Def Maximumscore(self, Nums: List[int], K: Int) -&gt; Int:<br/>        N = Len(nums)<br/><br/>        Upper = Max(nums) + 1<br/><br/>        Prime = [True]*upper<br/>        Prime[0] = Prime[1] = False<br/>        Primescore = [0]*upper<br/>        For I In Range(2, Upper):<br/>            If Prime[i]:<br/>                For J In Range(i, Upper, I):<br/>                    Primescore[j] += 1<br/>                    Prime[j] = False<br/><br/>        Nextgreaterelement = [N]*n<br/>        S = []<br/>        For I In Range(n - 1, -1, -1):<br/>            While S And Primescore[nums[i]] &gt;= Primescore[nums[s[-1]]]:<br/>                S.pop()<br/>            Nextgreaterelement[i] = S[-1] If S Else N<br/>            S.append(i)<br/><br/>        Prevgreaterorequalelement = [-1]*n<br/>        S = []<br/>        For I In Range(n):<br/>            While S And Primescore[nums[i]] &gt; Primescore[nums[s[-1]]]:<br/>                S.pop()<br/>            Prevgreaterorequalelement[i] = S[-1] If S Else -1<br/>            S.append(i)<br/><br/>        Res = 1<br/>        Tuples = [[Nums[i], I] For I In Range(n)]<br/>        Tuples.sort(reverse=true)<br/>        For Num, Idx In Tuples:<br/>            Operations = Min((idx - Prevgreaterorequalelement[idx]) * (Nextgreaterelement[idx] - Idx), K)<br/>            Res = (Res * Self.pow(num, Operations)) % Self.mod<br/>            K -= Operations<br/>            If K == 0:<br/>                Return Res<br/><br/>        Return Res<br/><br/>    Def Pow(self, X: Int, N: Int) -&gt; Int:<br/>        Res = 1<br/>        While N &gt; 0:<br/>            If N % 2 == 1:<br/>                Res = (Res * X) % Self.mod<br/>            X = (X * X) % Self.mod<br/>            N //= 2<br/>        Return Res</td>
</tr>
<tr>
<td align="right">105</td>
<td align="right">5</td>
<td>C++</td>
<td>hard</td>
<td>InstructCodeT5+</td>
<td>HuggingFace Model</td>
<td>You are given an array nums of n positive integers and an integer k.<br/><br/>Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:<br/><br/>Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.<br/>Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.<br/>Multiply your score by x.<br/>Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.<br/><br/>The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.<br/><br/>Return the maximum possible score after applying at most k operations.<br/><br/>Since the answer may be large, return it modulo 10^9 + 7.<br/><br/>Example 1:<br/><br/>Input: nums = [8,3,9,3,8], k = 2<br/>Output: 81<br/>Explanation: To get a score of 81, we can apply the following operations:<br/>- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.<br/>It can be proven that 81 is the highest score one can obtain.<br/><br/>Example 2:<br/><br/>Input: nums = [19,12,14,6,10,18], k = 3<br/>Output: 4788<br/>Explanation: To get a score of 4788, we can apply the following operations: <br/>- Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.<br/>- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.<br/>It can be proven that 4788 is the highest score one can obtain.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length == n &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^5<br/>1 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9) </td>
<td>prompt = &quot;&quot;&quot;<br/>class Solution {<br/>public:<br/>    int maximumScore(vector&lt;int&gt;&amp; nums, int k) {<br/><br/>/*You are given an array nums of n positive integers and an integer k.<br/><br/>Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:<br/><br/>Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.<br/>Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.<br/>Multiply your score by x.<br/>Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.<br/><br/>The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.<br/><br/>Return the maximum possible score after applying at most k operations.<br/><br/>Since the answer may be large, return it modulo 10^9 + 7.<br/><br/>Example 1:<br/><br/>Input: nums = [8,3,9,3,8], k = 2<br/>Output: 81<br/><br/>Example 2:<br/><br/>Input: nums = [19,12,14,6,10,18], k = 3<br/>Output: 4788<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length == n &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^5<br/>1 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9) <br/>*/<br/>&quot;&quot;&quot;</td>
<td>Class Solution {<br/>Public:    <br/>    Int Getprimescore(int Num) {<br/>        Int Count = 0;<br/>        For (Int I = 2; I * I &lt;= Num; I++) {<br/>            While (Num % I == 0) {<br/>                Num /= I;<br/>                Count++;<br/>            }<br/>        }<br/>        Return Count;<br/>    }<br/><br/>    Int Getmaxprimescore(vector&lt;int&gt;&amp; Nums, Int L, Int R) {<br/>        Int Maxprimescore = 0;<br/>        For (Int I = L; I &lt;= R; I++) {<br/>            Maxprimescore = Max(maxprimescore, Getprimescore(nums[i]));<br/>        }<br/>        Return Maxprimescore;<br/>    }<br/><br/>    Int Getmaxscore(vector&lt;int&gt;&amp; Nums, Int L, Int R) {<br/>        Int Maxscore = 0;<br/>        For (Int I = L; I &lt;= R; I++) {<br/>            Maxscore = Max(maxscore, Nums[i]);<br/>        }<br/>        Return Maxscore;<br/>    }<br/><br/>    Int Maximumscore(vector&lt;int&gt;&amp; Nums, Int K) {<br/>        Int Score = 1;<br/>        Int Maxscore = 0;<br/><br/>        Int L = 0;<br/>        Int R = Nums.size() - 1;<br/>        <br/>        For (Int I = 0; I &lt; K; I++) {<br/>            Int Temp = Getmaxscore(nums, L, R);<br/>            Maxscore = Max(maxscore, Temp);<br/>            Int Tempprimescore = Getmaxprimescore(nums, L, R);<br/>            Int Tempscore = Temp * Tempprimescore;<br/>            L = L + 1;<br/>            R = R - 1;<br/>        }<br/>        <br/>        Return Maxscore;<br/>    }<br/>};</td>
<td>Class Solution {<br/>Public:<br/>    Const Int Mod = 1000000007;<br/><br/>    Int Maximumscore(vector&lt;int&gt;&amp; Nums, Int K) {<br/>        Int N = Nums.size();<br/><br/>        Int Upper = *Max_element(nums.begin(), Nums.end()) + 1;<br/><br/>        Vector&lt;bool&gt; Prime(upper, True);<br/>        Prime[0] = Prime[1] = False;<br/>        Vector&lt;int&gt; Primescore(upper, 0);<br/>        For (Int I = 2; I &lt; Upper; I++) {<br/>            If (Prime[i]) {<br/>                For (Int J = I; J &lt; Upper; J += I) {<br/>                    Primescore[j]++;<br/>                    Prime[j] = False;<br/>                }<br/>            }<br/>        }<br/><br/>        Vector&lt;int&gt; Nextgreaterelement(n, N);<br/>        Stack&lt;int&gt; S;<br/>        For (Int I = N - 1; I &gt;= 0; I--) {<br/>            While (!S.empty() &amp;&amp; Primescore[nums[i]] &gt;= Primescore[nums[s.top()]]) {<br/>                S.pop();<br/>            }<br/>            Nextgreaterelement[i] = S.empty() ? N : S.top();<br/>            S.push(i);<br/>        }<br/><br/>        Vector&lt;int&gt; Prevgreaterorequalelement(n, -1);<br/>        S = Stack&lt;int&gt;();<br/>        For (Int I = 0; I &lt; N; I++) {<br/>            While (!S.empty() &amp;&amp; Primescore[nums[i]] &gt; Primescore[nums[s.top()]]) {<br/>                S.pop();<br/>            }<br/>            Prevgreaterorequalelement[i] = S.empty() ? -1 : S.top();<br/>            S.push(i);<br/>        }<br/><br/>        Int Res = 1;<br/>        Vector&lt;pair&lt;int, Int&gt;&gt; Tuples(n);<br/>        For (Int I = 0; I &lt; N; I++) {<br/>            Tuples[i].first = Nums[i];<br/>            Tuples[i].second = I;<br/>        }<br/>        Sort(tuples.rbegin(), Tuples.rend());<br/>        For (Const Auto&amp; [Num, I] : Tuples) {<br/>            Int Operations = Min((i - Prevgreaterorequalelement[i]) * (Nextgreaterelement[i] - I), K);<br/>            Res = (Int)((1l * Res * Pow(num, Operations)) % Mod);<br/>            K -= Operations;<br/>            If (K == 0) {<br/>                Return Res;<br/>            }<br/>        }<br/><br/>        Return Res;<br/>    }<br/><br/>    Int Pow(int X, Int N) {<br/>        Int Res = 1;<br/>        While (N &gt; 0) {<br/>            If (N % 2 == 1) {<br/>                Res = (Int)((1l * Res * X) % Mod);<br/>            }<br/>            X = (Int)((1l * X * X) % Mod);<br/>            N /= 2;<br/>        }<br/>        Return Res;<br/>    }<br/>};</td>
</tr>
<tr>
<td align="right">106</td>
<td align="right">6</td>
<td>Java</td>
<td>hard</td>
<td>InstructCodeT5+</td>
<td>HuggingFace Model</td>
<td>You are given a 0-indexed 2D integer array items of length n and an integer k.<br/><br/>items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.<br/><br/>Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.<br/><br/>Your task is to find the maximum elegance from all subsequences of size k in items.<br/><br/>Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.<br/><br/>Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.<br/><br/>Example 1:<br/><br/>Input: items = [[3,2],[5,1],[10,1]], k = 2<br/>Output: 17<br/>Explanation: In this example, we have to select a subsequence of size 2.<br/>We can select items[0] = [3,2] and items[2] = [10,1].<br/>The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].<br/>Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. <br/><br/>Example 2:<br/><br/>Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3<br/>Output: 19<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. <br/>The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. <br/>Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.<br/><br/>Example 3:<br/><br/>Input: items = [[1,1],[2,1],[3,1]], k = 3<br/>Output: 7<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We should select all the items. <br/>The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. <br/>Hence, the maximum elegance is 6 + 1^2 = 7.  <br/> <br/>Constraints:<br/><br/>1 &lt;= items.length == n &lt;= 10^5<br/>items[i].length == 2<br/>items[i][0] == profit_i<br/>items[i][1] == category_i<br/>1 &lt;= profit_i &lt;= 10^9<br/>1 &lt;= category_i &lt;= n <br/>1 &lt;= k &lt;= n </td>
<td>prompt = &quot;&quot;&quot;<br/>/*You are given a 0-indexed 2D integer array items of length n and an integer k.<br/><br/>items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.<br/><br/>Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.<br/><br/>Your task is to find the maximum elegance from all subsequences of size k in items.<br/><br/>Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.<br/><br/>Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.<br/><br/>Example 1:<br/><br/>Input: items = [[3,2],[5,1],[10,1]], k = 2<br/>Output: 17<br/>Explanation: In this example, we have to select a subsequence of size 2.<br/>We can select items[0] = [3,2] and items[2] = [10,1].<br/>The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].<br/>Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. <br/><br/>Example 2:<br/><br/>Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3<br/>Output: 19<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. <br/>The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. <br/>Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.<br/><br/>Example 3:<br/><br/>Input: items = [[1,1],[2,1],[3,1]], k = 3<br/>Output: 7<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We should select all the items. <br/>The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. <br/>Hence, the maximum elegance is 6 + 1^2 = 7.  <br/> <br/>Constraints:<br/><br/>1 &lt;= items.length == n &lt;= 10^5<br/>items[i].length == 2<br/>items[i][0] == profit_i<br/>items[i][1] == category_i<br/>1 &lt;= profit_i &lt;= 10^9<br/>1 &lt;= category_i &lt;= n <br/>1 &lt;= k &lt;= n*/<br/><br/>class Solution {<br/>    public long findMaximumElegance(int[][] items, int k) {<br/>&quot;&quot;&quot;</td>
<td>Class Solution {    <br/>    Public Long Findmaximumelegance(int[][] Items, Int K) {<br/>        Int N = Items.length;<br/>        Int[][] Dp = New Int[n + 1][k + 1];<br/>        For (Int I = 0; I &lt;= N; I++) {<br/>            For (Int J = 0; J &lt;= K; J++) {<br/>                If (I == 0) {<br/>                    Dp[i][j] = 0;<br/>                } Else If (J == 0) {<br/>                    Dp[i][j] = 0;<br/>                } Else If (J == 1) {<br/>                    Dp[i][j] = Items[i - 1][0];<br/>                } Else {<br/>                    Dp[i][j] = Math.max(dp[i - 1][j], Items[i - 1][0] + Dp[i - 1][j - 1]);<br/>                }<br/>            }<br/>        }<br/>        Return Dp[n][k];<br/>    }<br/>}</td>
<td>Class Solution {<br/>    Public Long Findmaximumelegance(int[][] A, Int K) {<br/>        Arrays.sort(a, (A, B) -&gt; B[0] - A[0]);<br/>        Long Res = 0, Cur = 0;<br/>        List&lt;integer&gt; Dup = New Arraylist&lt;&gt;();<br/>        Set&lt;integer&gt; Seen = New Hashset&lt;&gt;();<br/>        For (Int I = 0; I &lt; A.length; ++I) {<br/>            If (I &lt; K) {<br/>                If (Seen.contains(a[i][1])) {<br/>                    Dup.add(a[i][0]);<br/>                }<br/>                Cur += A[i][0];<br/>            } Else If (!Seen.contains(a[i][1])) {<br/>                If (Dup.isempty()) Break;<br/>                Cur += A[i][0] - Dup.remove(dup.size() - 1);<br/>            }<br/>            Seen.add(a[i][1]);<br/>            Res = Math.max(res, Cur + 1l * Seen.size() * Seen.size());<br/>        }<br/>        Return Res;<br/>    }<br/>}</td>
</tr>
<tr>
<td align="right">107</td>
<td align="right">6</td>
<td>Python</td>
<td>hard</td>
<td>InstructCodeT5+</td>
<td>HuggingFace Model</td>
<td>You are given a 0-indexed 2D integer array items of length n and an integer k.<br/><br/>items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.<br/><br/>Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.<br/><br/>Your task is to find the maximum elegance from all subsequences of size k in items.<br/><br/>Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.<br/><br/>Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.<br/><br/>Example 1:<br/><br/>Input: items = [[3,2],[5,1],[10,1]], k = 2<br/>Output: 17<br/>Explanation: In this example, we have to select a subsequence of size 2.<br/>We can select items[0] = [3,2] and items[2] = [10,1].<br/>The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].<br/>Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. <br/><br/>Example 2:<br/><br/>Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3<br/>Output: 19<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. <br/>The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. <br/>Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.<br/><br/>Example 3:<br/><br/>Input: items = [[1,1],[2,1],[3,1]], k = 3<br/>Output: 7<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We should select all the items. <br/>The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. <br/>Hence, the maximum elegance is 6 + 1^2 = 7.  <br/> <br/>Constraints:<br/><br/>1 &lt;= items.length == n &lt;= 10^5<br/>items[i].length == 2<br/>items[i][0] == profit_i<br/>items[i][1] == category_i<br/>1 &lt;= profit_i &lt;= 10^9<br/>1 &lt;= category_i &lt;= n <br/>1 &lt;= k &lt;= n </td>
<td>prompt = &quot;&quot;&quot;<br/>You are given a 0-indexed 2D integer array items of length n and an integer k.<br/><br/>items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.<br/><br/>Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.<br/><br/>Your task is to find the maximum elegance from all subsequences of size k in items.<br/><br/>Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.<br/><br/>Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.<br/><br/>Example 1:<br/><br/>Input: items = [[3,2],[5,1],[10,1]], k = 2<br/>Output: 17<br/>Explanation: In this example, we have to select a subsequence of size 2.<br/>We can select items[0] = [3,2] and items[2] = [10,1].<br/>The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].<br/>Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. <br/><br/>Example 2:<br/><br/>Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3<br/>Output: 19<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. <br/>The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. <br/>Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.<br/><br/>Example 3:<br/><br/>Input: items = [[1,1],[2,1],[3,1]], k = 3<br/>Output: 7<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We should select all the items. <br/>The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. <br/>Hence, the maximum elegance is 6 + 1^2 = 7.  <br/> <br/>Constraints:<br/><br/>1 &lt;= items.length == n &lt;= 10^5<br/>items[i].length == 2<br/>items[i][0] == profit_i<br/>items[i][1] == category_i<br/>1 &lt;= profit_i &lt;= 10^9<br/>1 &lt;= category_i &lt;= n <br/>1 &lt;= k &lt;= n<br/><br/>class Solution:<br/>    def findMaximumElegance(self, items: List[List[int]], k: int) -&gt; int:<br/>&quot;&quot;&quot;</td>
<td>Class Solution:    <br/>    Def Findmaximumelegance(self, Items: List[list[int]], K: Int) -&gt; Int:<br/>        <br/>        @Lru_cache(none)<br/>        Def Dp(i, K):<br/>            If K == 0:<br/>                Return 0<br/>            If I == Len(items):<br/>                Return Float(&#39;-inf&#39;)<br/>            Return Max(dp(i + 1, K), Items[i][0] + Dp(i + 1, K - 1))<br/>        <br/>        Return Dp(0, K)</td>
<td>Class Solution:<br/>    Def Findmaximumelegance(self, Items: List[list[int]], K: Int) -&gt; Int:<br/>        Items = Sorted(items, Key=lambda V: -V[0])<br/>        Res = Cur = 0<br/>        A = []<br/>        Seen = Set()<br/>        For I, (P, C) In Enumerate(items):<br/>            If I &lt; K:<br/>                If C In Seen:<br/>                    A.append(p)<br/>                Cur += P<br/>            Elif C Not In Seen:<br/>                If Not A: Break<br/>                Cur += P - A.pop()<br/>            Seen.add(c)<br/>            Res = Max(res, Cur + Len(seen) * Len(seen))<br/>        Return Res</td>
</tr>
<tr>
<td align="right">108</td>
<td align="right">6</td>
<td>C++</td>
<td>hard</td>
<td>InstructCodeT5+</td>
<td>HuggingFace Model</td>
<td>You are given a 0-indexed 2D integer array items of length n and an integer k.<br/><br/>items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.<br/><br/>Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.<br/><br/>Your task is to find the maximum elegance from all subsequences of size k in items.<br/><br/>Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.<br/><br/>Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.<br/><br/>Example 1:<br/><br/>Input: items = [[3,2],[5,1],[10,1]], k = 2<br/>Output: 17<br/>Explanation: In this example, we have to select a subsequence of size 2.<br/>We can select items[0] = [3,2] and items[2] = [10,1].<br/>The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].<br/>Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. <br/><br/>Example 2:<br/><br/>Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3<br/>Output: 19<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. <br/>The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. <br/>Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.<br/><br/>Example 3:<br/><br/>Input: items = [[1,1],[2,1],[3,1]], k = 3<br/>Output: 7<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We should select all the items. <br/>The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. <br/>Hence, the maximum elegance is 6 + 1^2 = 7.  <br/> <br/>Constraints:<br/><br/>1 &lt;= items.length == n &lt;= 10^5<br/>items[i].length == 2<br/>items[i][0] == profit_i<br/>items[i][1] == category_i<br/>1 &lt;= profit_i &lt;= 10^9<br/>1 &lt;= category_i &lt;= n <br/>1 &lt;= k &lt;= n </td>
<td>prompt = &quot;&quot;&quot;<br/>You are given a 0-indexed 2D integer array items of length n and an integer k.<br/><br/>items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.<br/><br/>Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.<br/><br/>Your task is to find the maximum elegance from all subsequences of size k in items.<br/><br/>Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.<br/><br/>Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.<br/><br/>Constraints:<br/><br/>1 &lt;= items.length == n &lt;= 10^5<br/>items[i].length == 2<br/>items[i][0] == profit_i<br/>items[i][1] == category_i<br/>1 &lt;= profit_i &lt;= 10^9<br/>1 &lt;= category_i &lt;= n <br/>1 &lt;= k &lt;= n <br/><br/>class Solution {<br/>public:<br/>    long long findMaximumElegance(vector&lt;vector&lt;int&gt;&gt;&amp; items, int k) {<br/>&quot;&quot;&quot;</td>
<td>Class Solution {<br/>Public:    Long Long Findmaximumelegance(vector&lt;vector&lt;int&gt;&gt;&amp; Items, Int K) {<br/>        Int N = Items.size();<br/>        Vector&lt;vector&lt;int&gt;&gt; Dp(n, Vector&lt;int&gt;(2, 0));<br/>        Dp[0][0] = Items[0][0];<br/>        Dp[0][1] = 1;<br/>        For (Int I = 1; I &lt; N; I++) {<br/>            Dp[i][0] = Max(dp[i - 1][0], Items[i][0]);<br/>            Dp[i][1] = Dp[i - 1][1] + 1;<br/>        }<br/>        Long Long Res = 0;<br/>        For (Int I = 0; I &lt; N - K + 1; I++) {<br/>            Res = Max(res, Static_cast&lt;long Long&gt;(dp[i][0] + Dp[i + K - 1][0] + Dp[i][1] * Dp[i + K - 1][1]));<br/>        }<br/>        Return Res;<br/>    }<br/>};</td>
<td>Class Solution {<br/>Public:<br/>    Long Long Findmaximumelegance(vector&lt;vector&lt;int&gt;&gt;&amp; A, Int K) {<br/>        Sort(a.begin(), A.end(), [](Const Vector&lt;int&gt;&amp; A, Const Vector&lt;int&gt;&amp; B) {<br/>            Return A[0] &gt; B[0];<br/>        });<br/>        Long Long Res = 0, Cur = 0;<br/>        Vector&lt;int&gt; Dup;<br/>        Unordered_set&lt;int&gt; Seen;<br/>        For (Int I = 0; I &lt; A.size(); ++I) {<br/>            If (I &lt; K) {<br/>                If (Seen.count(a[i][1])) {<br/>                    Dup.push_back(a[i][0]);<br/>                }<br/>                Cur += A[i][0];<br/>            } Else If (Seen.find(a[i][1]) == Seen.end()) {<br/>                If (Dup.empty()) Break;<br/>                Cur += A[i][0] - Dup.back();<br/>                Dup.pop_back();<br/>            }<br/>            Seen.insert(a[i][1]);<br/>            Res = Fmax(res, Cur + 1l * Seen.size() * Seen.size());<br/>        }<br/>        Return Res;<br/>    }<br/>};</td>
</tr>
<tr>
<td align="right">109</td>
<td align="right">1</td>
<td>Java</td>
<td>easy</td>
<td>StarCoder</td>
<td>IDE Extension</td>
<td>You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.<br/><br/>Return the maximum sum or -1 if no such pair exists.<br/><br/>Example 1:<br/><br/>Input: nums = [51,71,17,24,42]<br/>Output: 88<br/>Explanation: <br/>For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. <br/>For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.<br/>It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.<br/><br/>Example 2:<br/><br/>Input: nums = [1,2,3,4]<br/>Output: -1<br/>Explanation: No pair exists in nums with equal maximum digits.<br/><br/>Constraints:<br/><br/>2 &lt;= nums.length &lt;= 100<br/>1 &lt;= nums[i] &lt;= 10^4 </td>
<td>public class Solution{<br/>    public int maxSum(int[] nums){<br/>        /*<br/>         * You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.<br/><br/>Return the maximum sum or -1 if no such pair exists.<br/><br/>Example 1:<br/><br/>Input: nums = [51,71,17,24,42]<br/>Output: 88<br/>Explanation: <br/>For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. <br/>For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.<br/>It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.<br/><br/>Example 2:<br/><br/>Input: nums = [1,2,3,4]<br/>Output: -1<br/>Explanation: No pair exists in nums with equal maximum digits.<br/><br/>Constraints:<br/><br/>2 &lt;= nums.length &lt;= 100<br/>1 &lt;= nums[i] &lt;= 10^4<br/>*/</td>
<td>Public Class Solution{<br/>    Public Int Maxsum(int[] Nums){<br/>        Int Maxsum = Integer.min_value;<br/>        For (Int I = 0; I &lt; Nums.length; I++) {<br/>            For (Int J = I + 1; J &lt; Nums.length; J++) {<br/>                If (Nums[i] % 10 == Nums[j] % 10) {<br/>                    Maxsum = Math.max(maxsum, Nums[i] + Nums[j]);<br/>                }<br/>            }<br/>        }<br/>        Return Maxsum == Integer.min_value? -1 : Maxsum; <br/>    }<br/>    <br/>}</td>
<td>Class Solution {<br/>    Public Int Maxsum(int[] Nums) {<br/>    Int Ans = -1;<br/>    Map&lt;integer,list&lt;integer&gt;&gt; Ump = New Hashmap&lt;&gt;();<br/>    For(int I = 0; I &lt; Nums.length; ++I){<br/>        Int T = Nums[i], Maxdigit = 0;<br/>        While(t != 0){ //Evaluate Max Digit In The Number<br/>            Maxdigit = Math.max(t%10, Maxdigit);<br/>            T = T/10;<br/>        }<br/>        If(!ump.containskey(maxdigit)) Ump.put(maxdigit, New Arraylist&lt;&gt;());<br/>        Ump.get(maxdigit).add(nums[i]); // Add The Number To The Map <br/>    }<br/>    For(map.entry&lt;integer, List&lt;integer&gt;&gt; Entry: Ump.entryset()){<br/>        Entry.getvalue().sort(comparator.reverseorder()); //To Find Max Two Number In Each Max Digit <br/>        If(entry.getvalue().size() &gt;= 2) Ans = Math.max(ans, Entry.getvalue().get(0) + Entry.getvalue().get(1)); //Sum Max Two Number And Take Max<br/>    }<br/>    Return Ans;<br/>    }<br/>}</td>
</tr>
<tr>
<td align="right">110</td>
<td align="right">1</td>
<td>Python</td>
<td>easy</td>
<td>StarCoder</td>
<td>IDE Extension</td>
<td>You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.<br/><br/>Return the maximum sum or -1 if no such pair exists.<br/><br/>Example 1:<br/><br/>Input: nums = [51,71,17,24,42]<br/>Output: 88<br/>Explanation: <br/>For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. <br/>For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.<br/>It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.<br/><br/>Example 2:<br/><br/>Input: nums = [1,2,3,4]<br/>Output: -1<br/>Explanation: No pair exists in nums with equal maximum digits.<br/><br/>Constraints:<br/><br/>2 &lt;= nums.length &lt;= 100<br/>1 &lt;= nums[i] &lt;= 10^4 </td>
<td>&quot;&quot;&quot;You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.<br/><br/>Return the maximum sum or -1 if no such pair exists.<br/><br/>Example 1:<br/><br/>Input: nums = [51,71,17,24,42]<br/>Output: 88<br/>Explanation: <br/>For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. <br/>For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.<br/>It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.<br/><br/>Example 2:<br/><br/>Input: nums = [1,2,3,4]<br/>Output: -1<br/>Explanation: No pair exists in nums with equal maximum digits.<br/> <br/>Constraints:<br/><br/>2 &lt;= nums.length &lt;= 100<br/>1 &lt;= nums[i] &lt;= 10^4&quot;&quot;&quot;<br/><br/>class Solution:<br/>    def maxSum(self, nums: List[int]) -&gt; int:</td>
<td>Class Solution:<br/>    Def Maxsum(self, Nums: List[int]) -&gt; Int:<br/>        If Len(nums) == 1:<br/>            Return Nums[0]<br/>        If Len(nums) == 2:<br/>            Return Max(nums)<br/>        Max_sum = 0<br/>        For I In Range(len(nums)):<br/>            For J In Range(i+1, Len(nums)):<br/>                If Nums[i] % 10 == Nums[j] % 10:<br/>                    Max_sum = Max(max_sum, Nums[i] + Nums[j])<br/>        Return Max_sum If Max_sum &gt; 0 Else -1</td>
<td>Class Solution:<br/>    Def Maxsum(self, Nums: List[int]) -&gt; Int:<br/>        Max_by_digit = Defaultdict(int)<br/>        Max_sum = -1<br/><br/>        For Num In Nums:<br/>            Digit = Max(str(num))<br/><br/>            If Digit In Max_by_digit:<br/>                Max_sum = Max(max_sum, Max_by_digit[digit] + Num)<br/><br/>            Max_by_digit[digit] = Max(max_by_digit[digit], Num)<br/><br/>        Return Max_sum</td>
</tr>
<tr>
<td align="right">111</td>
<td align="right">1</td>
<td>C++</td>
<td>easy</td>
<td>StarCoder</td>
<td>IDE Extension</td>
<td>You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.<br/><br/>Return the maximum sum or -1 if no such pair exists.<br/><br/>Example 1:<br/><br/>Input: nums = [51,71,17,24,42]<br/>Output: 88<br/>Explanation: <br/>For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. <br/>For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.<br/>It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.<br/><br/>Example 2:<br/><br/>Input: nums = [1,2,3,4]<br/>Output: -1<br/>Explanation: No pair exists in nums with equal maximum digits.<br/><br/>Constraints:<br/><br/>2 &lt;= nums.length &lt;= 100<br/>1 &lt;= nums[i] &lt;= 10^4 </td>
<td>class Solution {<br/>public:<br/>    int maxSum(vector&lt;int&gt;&amp; nums) {<br/>/*You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.<br/><br/>Return the maximum sum or -1 if no such pair exists.<br/><br/>Example 1:<br/><br/>Input: nums = [51,71,17,24,42]<br/>Output: 88<br/>Explanation: <br/>For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. <br/>For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.<br/>It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.<br/><br/>Example 2:<br/><br/>Input: nums = [1,2,3,4]<br/>Output: -1<br/>Explanation: No pair exists in nums with equal maximum digits.<br/><br/>Constraints:<br/><br/>2 &lt;= nums.length &lt;= 100<br/>1 &lt;= nums[i] &lt;= 10^4*/</td>
<td>Class Solution {<br/>Public:<br/>    Int Maxsum(vector&lt;int&gt;&amp; Nums) {<br/>    Int N=nums.size();<br/>    Int Maxi=0;<br/>    Int Maxj=0;<br/>    Int Maxsum=0;<br/>    For(int I=0;i&lt;n;i++){<br/>        For(int J=i+1;j&lt;n;j++){<br/>            If(nums[i]&gt;maxi){<br/>                Maxi=nums[i];<br/>            }<br/>            If(nums[j]&gt;maxj){<br/>                Maxj=nums[j];<br/>            }<br/>            If(maxi==maxj){<br/>                Maxsum=max(maxsum,maxi+maxj);<br/>            }<br/>        }<br/>    }<br/>    If(maxsum==0){<br/>        Return -1;<br/>    }<br/>    Return Maxsum;<br/>    }<br/>};</td>
<td>Class Solution {<br/>    Public:<br/>        Int Maxsum(vector&lt;int&gt;&amp; Nums) {<br/>        Int Res = -1, Max_num[10] = {};<br/>        For (Auto Num : Nums) {<br/>            Int Max_d = 0;<br/>            For (Int V = Num; V; V /= 10)<br/>                Max_d = Max(max_d, V % 10);<br/>            If (Max_num[max_d])<br/>                Res = Max(res, Max_num[max_d] + Num);<br/>            Max_num[max_d] = Max(max_num[max_d], Num);<br/>        }<br/>        Return Res;<br/>    }<br/>};</td>
</tr>
<tr>
<td align="right">112</td>
<td align="right">2</td>
<td>Java</td>
<td>easy</td>
<td>StarCoder</td>
<td>IDE Extension</td>
<td>Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.<br/><br/>You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.<br/><br/>Return the final string that will be present on your laptop screen.<br/><br/>Example 1:<br/><br/>Input: s = &quot;string&quot;<br/>Output: &quot;rtsng&quot;<br/>Explanation: <br/>After typing first character, the text on the screen is &quot;s&quot;.<br/>After the second character, the text is &quot;st&quot;. <br/>After the third character, the text is &quot;str&quot;.<br/>Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.<br/>After the fifth character, the text is &quot;rtsn&quot;. <br/>After the sixth character, the text is &quot;rtsng&quot;. <br/>Therefore, we return &quot;rtsng&quot;.<br/><br/>Example 2:<br/><br/>Input: s = &quot;poiinter&quot;<br/>Output: &quot;ponter&quot;<br/>Explanation: <br/>After the first character, the text on the screen is &quot;p&quot;.<br/>After the second character, the text is &quot;po&quot;. <br/>Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. <br/>Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.<br/>After the fifth character, the text is &quot;pon&quot;.<br/>After the sixth character, the text is &quot;pont&quot;. <br/>After the seventh character, the text is &quot;ponte&quot;. <br/>After the eighth character, the text is &quot;ponter&quot;. <br/>Therefore, we return &quot;ponter&quot;.<br/> <br/>Constraints:<br/><br/>1 &lt;= s.length &lt;= 100<br/>s consists of lowercase English letters.<br/>s[0] != &#39;i&#39;</td>
<td>public class Solution {<br/>    public String finalString(String s) {<br/>        /*<br/>         * Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.<br/><br/>You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.<br/><br/>Return the final string that will be present on your laptop screen.<br/><br/>Example 1:<br/><br/>Input: s = &quot;string&quot;<br/>Output: &quot;rtsng&quot;<br/>Explanation: <br/>After typing first character, the text on the screen is &quot;s&quot;.<br/>After the second character, the text is &quot;st&quot;. <br/>After the third character, the text is &quot;str&quot;.<br/>Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.<br/>After the fifth character, the text is &quot;rtsn&quot;. <br/>After the sixth character, the text is &quot;rtsng&quot;. <br/>Therefore, we return &quot;rtsng&quot;.<br/><br/>Example 2:<br/><br/>Input: s = &quot;poiinter&quot;<br/>Output: &quot;ponter&quot;<br/>Explanation: <br/>After the first character, the text on the screen is &quot;p&quot;.<br/>After the second character, the text is &quot;po&quot;. <br/>Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. <br/>Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.<br/>After the fifth character, the text is &quot;pon&quot;.<br/>After the sixth character, the text is &quot;pont&quot;. <br/>After the seventh character, the text is &quot;ponte&quot;. <br/>After the eighth character, the text is &quot;ponter&quot;. <br/>Therefore, we return &quot;ponter&quot;.<br/> <br/>Constraints:<br/><br/>1 &lt;= s.length &lt;= 100<br/>s consists of lowercase English letters.<br/>s[0] != &#39;i&#39;<br/><br/>*/</td>
<td>Public Class Solution {<br/>    Public String Finalstring(string S) {<br/>        String Result = &quot;&quot;;<br/>        For (Int I = 0; I &lt; S.length(); I++) {<br/>            Char C = S.charat(i);<br/>            If (C == &#39;I&#39;) {<br/>                Result = New Stringbuilder(result).reverse().tostring();<br/>            } Else {<br/>                Result += C;<br/>            }<br/>        }<br/>        Return Result;<br/>    }<br/>}</td>
<td>Class Solution {<br/>    Public String Finalstring(string S) {<br/>        Stringbuilder Nm=new Stringbuilder();<br/>        For(char C:s.tochararray())<br/>        {<br/>            If(c==&#39;i&#39;)<br/>            {<br/>                Nm.reverse();<br/>            }<br/>            Else<br/>            {<br/>                Nm.append(c);<br/>            }<br/>        }<br/>        Return Nm.tostring();<br/>    }<br/>}</td>
</tr>
<tr>
<td align="right">113</td>
<td align="right">2</td>
<td>Python</td>
<td>easy</td>
<td>StarCoder</td>
<td>IDE Extension</td>
<td>Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.<br/><br/>You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.<br/><br/>Return the final string that will be present on your laptop screen.<br/><br/>Example 1:<br/><br/>Input: s = &quot;string&quot;<br/>Output: &quot;rtsng&quot;<br/>Explanation: <br/>After typing first character, the text on the screen is &quot;s&quot;.<br/>After the second character, the text is &quot;st&quot;. <br/>After the third character, the text is &quot;str&quot;.<br/>Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.<br/>After the fifth character, the text is &quot;rtsn&quot;. <br/>After the sixth character, the text is &quot;rtsng&quot;. <br/>Therefore, we return &quot;rtsng&quot;.<br/><br/>Example 2:<br/><br/>Input: s = &quot;poiinter&quot;<br/>Output: &quot;ponter&quot;<br/>Explanation: <br/>After the first character, the text on the screen is &quot;p&quot;.<br/>After the second character, the text is &quot;po&quot;. <br/>Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. <br/>Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.<br/>After the fifth character, the text is &quot;pon&quot;.<br/>After the sixth character, the text is &quot;pont&quot;. <br/>After the seventh character, the text is &quot;ponte&quot;. <br/>After the eighth character, the text is &quot;ponter&quot;. <br/>Therefore, we return &quot;ponter&quot;.<br/> <br/>Constraints:<br/><br/>1 &lt;= s.length &lt;= 100<br/>s consists of lowercase English letters.<br/>s[0] != &#39;i&#39;</td>
<td>&quot;&quot;&quot;Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.<br/><br/>You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.<br/><br/>Return the final string that will be present on your laptop screen.<br/><br/>Example 1:<br/><br/>Input: s = &quot;string&quot;<br/>Output: &quot;rtsng&quot;<br/>Explanation: <br/>After typing first character, the text on the screen is &quot;s&quot;.<br/>After the second character, the text is &quot;st&quot;. <br/>After the third character, the text is &quot;str&quot;.<br/>Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.<br/>After the fifth character, the text is &quot;rtsn&quot;. <br/>After the sixth character, the text is &quot;rtsng&quot;. <br/>Therefore, we return &quot;rtsng&quot;.<br/><br/>Example 2:<br/><br/>Input: s = &quot;poiinter&quot;<br/>Output: &quot;ponter&quot;<br/>Explanation: <br/>After the first character, the text on the screen is &quot;p&quot;.<br/>After the second character, the text is &quot;po&quot;. <br/>Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. <br/>Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.<br/>After the fifth character, the text is &quot;pon&quot;.<br/>After the sixth character, the text is &quot;pont&quot;. <br/>After the seventh character, the text is &quot;ponte&quot;. <br/>After the eighth character, the text is &quot;ponter&quot;. <br/>Therefore, we return &quot;ponter&quot;.<br/> <br/>Constraints:<br/><br/>1 &lt;= s.length &lt;= 100<br/>s consists of lowercase English letters.<br/>s[0] != &#39;i&#39;&quot;&quot;&quot;<br/>class Solution:<br/>    def finalString(self, s: str) -&gt; str:</td>
<td>Class Solution:<br/>    Def Finalstring(self, S: Str) -&gt; Str:<br/>        S = List(s)<br/>        For I In Range(len(s)):<br/>            If S[i] == &#39;I&#39;:<br/>                S[i] = &#39;O&#39;<br/>            Else:<br/>                S[i] = &#39;I&#39;<br/>        Return &#39;&#39;.Join(s)</td>
<td>Class Solution:<br/>    Def Finalstring(self, S: Str) -&gt; Str:<br/>        While &quot;I&quot; In S:<br/>            Index=s.index(&quot;i&quot;)<br/><br/>            #First Half And Second Half<br/>            First=s[:index][::-1]<br/>            Second=s[index+1:]<br/><br/>            S=&quot;&quot;.join([first,second])<br/>        Return S</td>
</tr>
<tr>
<td align="right">114</td>
<td align="right">2</td>
<td>C++</td>
<td>easy</td>
<td>StarCoder</td>
<td>IDE Extension</td>
<td>Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.<br/><br/>You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.<br/><br/>Return the final string that will be present on your laptop screen.<br/><br/>Example 1:<br/><br/>Input: s = &quot;string&quot;<br/>Output: &quot;rtsng&quot;<br/>Explanation: <br/>After typing first character, the text on the screen is &quot;s&quot;.<br/>After the second character, the text is &quot;st&quot;. <br/>After the third character, the text is &quot;str&quot;.<br/>Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.<br/>After the fifth character, the text is &quot;rtsn&quot;. <br/>After the sixth character, the text is &quot;rtsng&quot;. <br/>Therefore, we return &quot;rtsng&quot;.<br/><br/>Example 2:<br/><br/>Input: s = &quot;poiinter&quot;<br/>Output: &quot;ponter&quot;<br/>Explanation: <br/>After the first character, the text on the screen is &quot;p&quot;.<br/>After the second character, the text is &quot;po&quot;. <br/>Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. <br/>Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.<br/>After the fifth character, the text is &quot;pon&quot;.<br/>After the sixth character, the text is &quot;pont&quot;. <br/>After the seventh character, the text is &quot;ponte&quot;. <br/>After the eighth character, the text is &quot;ponter&quot;. <br/>Therefore, we return &quot;ponter&quot;.<br/> <br/>Constraints:<br/><br/>1 &lt;= s.length &lt;= 100<br/>s consists of lowercase English letters.<br/>s[0] != &#39;i&#39;</td>
<td>class Solution {<br/>public:<br/>    string finalString(string s) {<br/>/*Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.<br/><br/>You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.<br/><br/>Return the final string that will be present on your laptop screen.<br/><br/>Example 1:<br/><br/>Input: s = &quot;string&quot;<br/>Output: &quot;rtsng&quot;<br/>Explanation: <br/>After typing first character, the text on the screen is &quot;s&quot;.<br/>After the second character, the text is &quot;st&quot;. <br/>After the third character, the text is &quot;str&quot;.<br/>Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.<br/>After the fifth character, the text is &quot;rtsn&quot;. <br/>After the sixth character, the text is &quot;rtsng&quot;. <br/>Therefore, we return &quot;rtsng&quot;.<br/><br/>Example 2:<br/><br/>Input: s = &quot;poiinter&quot;<br/>Output: &quot;ponter&quot;<br/>Explanation: <br/>After the first character, the text on the screen is &quot;p&quot;.<br/>After the second character, the text is &quot;po&quot;. <br/>Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. <br/>Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.<br/>After the fifth character, the text is &quot;pon&quot;.<br/>After the sixth character, the text is &quot;pont&quot;. <br/>After the seventh character, the text is &quot;ponte&quot;. <br/>After the eighth character, the text is &quot;ponter&quot;. <br/>Therefore, we return &quot;ponter&quot;.<br/> <br/>Constraints:<br/><br/>1 &lt;= s.length &lt;= 100<br/>s consists of lowercase English letters.<br/>s[0] != &#39;i&#39;*/</td>
<td>Class Solution {<br/>Public:<br/>    String Finalstring(string S) {<br/>    Int N=s.length();<br/>    String Ans=&quot;&quot;;<br/>    For(int I=0;i&lt;n;i++){<br/>        If(s[i]==&#39;i&#39;){<br/>            Ans=ans.substr(0,ans.length()-1);<br/>        }<br/>        Else{<br/>            Ans+=s[i];<br/>        }<br/>    }<br/>    Return Ans;<br/>    }<br/>};</td>
<td>Class Solution {<br/>Public:<br/>    String Finalstring(const String &amp;S) {<br/>        String A, B;<br/>        For (Char Ch : S)<br/>            If (Ch == &#39;I&#39;)<br/>                Swap(a, B);<br/>            Else<br/>                A += Ch;<br/>        Return String(rbegin(b), Rend(b)) + A;<br/>    }<br/>};</td>
</tr>
<tr>
<td align="right">115</td>
<td align="right">3</td>
<td>Java</td>
<td>medium</td>
<td>StarCoder</td>
<td>IDE Extension</td>
<td>You are given a 0-indexed integer array nums and an integer x.<br/><br/>Find the minimum absolute difference between two elements in the array that are at least x indices apart.<br/><br/>In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.<br/><br/>Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.<br/><br/>Example 1:<br/><br/>Input: nums = [4,3,2,4], x = 2<br/>Output: 0<br/>Explanation: We can select nums[0] = 4 and nums[3] = 4. <br/>They are at least 2 indices apart, and their absolute difference is the minimum, 0. <br/>It can be shown that 0 is the optimal answer.<br/><br/>Example 2:<br/><br/>Input: nums = [5,3,2,10,15], x = 1<br/>Output: 1<br/>Explanation: We can select nums[1] = 3 and nums[2] = 2.<br/>They are at least 1 index apart, and their absolute difference is the minimum, 1.<br/>It can be shown that 1 is the optimal answer.<br/><br/>Example 3:<br/><br/>Input: nums = [1,2,3,4], x = 3<br/>Output: 3<br/>Explanation: We can select nums[0] = 1 and nums[3] = 4.<br/>They are at least 3 indices apart, and their absolute difference is the minimum, 3.<br/>It can be shown that 3 is the optimal answer.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^9<br/>0 &lt;= x &lt; nums.length </td>
<td>class Solution {<br/>        /*<br/>         * You are given a 0-indexed integer array nums and an integer x.<br/><br/>Find the minimum absolute difference between two elements in the array that are at least x indices apart.<br/><br/>In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.<br/><br/>Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.<br/><br/>Example 1:<br/><br/>Input: nums = [4,3,2,4], x = 2<br/>Output: 0<br/>Explanation: We can select nums[0] = 4 and nums[3] = 4. <br/>They are at least 2 indices apart, and their absolute difference is the minimum, 0. <br/>It can be shown that 0 is the optimal answer.<br/><br/>Example 2:<br/><br/>Input: nums = [5,3,2,10,15], x = 1<br/>Output: 1<br/>Explanation: We can select nums[1] = 3 and nums[2] = 2.<br/>They are at least 1 index apart, and their absolute difference is the minimum, 1.<br/>It can be shown that 1 is the optimal answer.<br/><br/>Example 3:<br/><br/>Input: nums = [1,2,3,4], x = 3<br/>Output: 3<br/>Explanation: We can select nums[0] = 1 and nums[3] = 4.<br/>They are at least 3 indices apart, and their absolute difference is the minimum, 3.<br/>It can be shown that 3 is the optimal answer.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^9<br/>0 &lt;= x &lt; nums.length<br/><br/>*/<br/>    public int minAbsoluteDifference(List&lt;Integer&gt; nums, int x) {</td>
<td>Class Solution {<br/>    Public Int Minabsolutedifference(list&lt;integer&gt; Nums, Int X) {<br/>        Int N = Nums.size();<br/>        Int[] Arr  = New Int[n];<br/>        For(int I = 0; I &lt; N; I++) {<br/>            Arr[i] = Nums.get(i);<br/>        }<br/>        Arrays.sort(arr);<br/>        Int Res = Integer.max_value;<br/>        For(int I =  0; I &lt; N; I++) {<br/>            Int Left = I + 1;<br/>            Int Right = N - 1;<br/>            While(left &lt;= Right) {<br/>                Int Mid = Left + (Right - Left) / 2;<br/>                If(arr[mid] - Arr[  I] &gt;= X) {<br/>                    Right = Mid - 1;<br/>                } Else {<br/>                    Left = Mid + 1;<br/>                }<br/>            }<br/>            If(left &lt; N) {<br/>                Res = Math.min(res, Arr[left] - Arr[i]);<br/>            }<br/>            Left  = 0;<br/>            Right = I - 1;<br/>            While(left &lt;= Right) {<br/>                Int Mid = Left + (Right - Left) / 2;<br/>                If(arr[i] - Arr[mid] &gt;= X) {<br/>                    Left = Mid + 1;<br/>                 } Else {<br/>                    Right = Mid - 1;<br/>                }<br/>            }<br/>            If(right &gt;= 0) {<br/>                Res = Math.min(res, Arr[i] - Arr[right]);<br/>            }<br/>        }<br/>        Return Res;<br/>    }<br/>} </td>
<td>Class Solution {<br/>    Int Minabsolutedifference(list&lt;integer&gt; Nums, Int X) {<br/>        Int Ans = Integer.max_value;<br/>        Treeset&lt;integer&gt; S = New Treeset&lt;&gt;();<br/>        For(int I = X; I &lt; Nums.size(); ++I){<br/>            S.add(nums.get(i-x));<br/>            Integer High = S.ceiling(nums.get(i)), Low = S.floor(nums.get(i));<br/>            If(high != Null) Ans = Math.min(ans, Math.abs(nums.get(i) - High));<br/>            If(low != Null) Ans = Math.min(ans, Math.abs(nums.get(i) - Low));<br/>        }<br/>        Return Ans;<br/>    }<br/>}</td>
</tr>
<tr>
<td align="right">116</td>
<td align="right">3</td>
<td>Python</td>
<td>medium</td>
<td>StarCoder</td>
<td>IDE Extension</td>
<td>You are given a 0-indexed integer array nums and an integer x.<br/><br/>Find the minimum absolute difference between two elements in the array that are at least x indices apart.<br/><br/>In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.<br/><br/>Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.<br/><br/>Example 1:<br/><br/>Input: nums = [4,3,2,4], x = 2<br/>Output: 0<br/>Explanation: We can select nums[0] = 4 and nums[3] = 4. <br/>They are at least 2 indices apart, and their absolute difference is the minimum, 0. <br/>It can be shown that 0 is the optimal answer.<br/><br/>Example 2:<br/><br/>Input: nums = [5,3,2,10,15], x = 1<br/>Output: 1<br/>Explanation: We can select nums[1] = 3 and nums[2] = 2.<br/>They are at least 1 index apart, and their absolute difference is the minimum, 1.<br/>It can be shown that 1 is the optimal answer.<br/><br/>Example 3:<br/><br/>Input: nums = [1,2,3,4], x = 3<br/>Output: 3<br/>Explanation: We can select nums[0] = 1 and nums[3] = 4.<br/>They are at least 3 indices apart, and their absolute difference is the minimum, 3.<br/>It can be shown that 3 is the optimal answer.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^9<br/>0 &lt;= x &lt; nums.length </td>
<td>class Solution:<br/>    def minAbsoluteDifference(self, nums: List[int], x: int) -&gt; int:<br/>&quot;&quot;&quot;You are given a 0-indexed integer array nums and an integer x.<br/><br/>Find the minimum absolute difference between two elements in the array that are at least x indices apart.<br/><br/>In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.<br/><br/>Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.<br/><br/>Example 1:<br/><br/>Input: nums = [4,3,2,4], x = 2<br/>Output: 0<br/>Explanation: We can select nums[0] = 4 and nums[3] = 4. <br/>They are at least 2 indices apart, and their absolute difference is the minimum, 0. <br/>It can be shown that 0 is the optimal answer.<br/><br/>Example 2:<br/><br/>Input: nums = [5,3,2,10,15], x = 1<br/>Output: 1<br/>Explanation: We can select nums[1] = 3 and nums[2] = 2.<br/>They are at least 1 index apart, and their absolute difference is the minimum, 1.<br/>It can be shown that 1 is the optimal answer.<br/><br/>Example 3:<br/><br/>Input: nums = [1,2,3,4], x = 3<br/>Output: 3<br/>Explanation: We can select nums[0] = 1 and nums[3] = 4.<br/>They are at least 3 indices apart, and their absolute difference is the minimum, 3.<br/>It can be shown that 3 is the optimal answer.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^9<br/>0 &lt;= x &lt; nums.length &quot;&quot;&quot;</td>
<td>Class Solution:<br/>    Def Minabsolutedifference(self, Nums: List[int], X: Int) -&gt; Int:<br/>        Nums.sort()<br/>        N = Len(nums)<br/>        Ans = Float(&#39;inf&#39;)<br/>        For I In Range(n):<br/>            For J In Range(i+1, N):<br/>                If Abs(nums[i] - Nums[j]) &lt; Ans:<br/>                    Ans = Abs(nums[i] - Nums[j])<br/>                If Abs(nums[i] - Nums[j]) == Ans And Abs(nums[i] - X) &lt; Abs(nums[j] - X):<br/>                    Ans = Abs(nums[i] - X)<br/>        Return Ans</td>
<td>Class Solution:<br/>  Def Minabsolutedifference(self, Nums: List[int], X: Int) -&gt; Int:<br/>    If X == 0:<br/>      Return 0<br/><br/>    Arr, Best_dist = Sortedlist([]), Float(&#39;inf&#39;)<br/>    For I In Range(x, Len(nums)):<br/>      Arr.add(nums[i - X])<br/>      V = Nums[i]<br/><br/>      Pos = Arr.bisect_left(v)<br/>      If Pos &lt; Len(arr):<br/>        Best_dist = Min(best_dist, Abs(arr[pos] - V))<br/>      If Pos &gt; 0:<br/>        Best_dist = Min(best_dist, Abs(arr[pos - 1] - V))<br/>    <br/>    Return Best_dist</td>
</tr>
<tr>
<td align="right">117</td>
<td align="right">3</td>
<td>C++</td>
<td>medium</td>
<td>StarCoder</td>
<td>IDE Extension</td>
<td>You are given a 0-indexed integer array nums and an integer x.<br/><br/>Find the minimum absolute difference between two elements in the array that are at least x indices apart.<br/><br/>In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.<br/><br/>Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.<br/><br/>Example 1:<br/><br/>Input: nums = [4,3,2,4], x = 2<br/>Output: 0<br/>Explanation: We can select nums[0] = 4 and nums[3] = 4. <br/>They are at least 2 indices apart, and their absolute difference is the minimum, 0. <br/>It can be shown that 0 is the optimal answer.<br/><br/>Example 2:<br/><br/>Input: nums = [5,3,2,10,15], x = 1<br/>Output: 1<br/>Explanation: We can select nums[1] = 3 and nums[2] = 2.<br/>They are at least 1 index apart, and their absolute difference is the minimum, 1.<br/>It can be shown that 1 is the optimal answer.<br/><br/>Example 3:<br/><br/>Input: nums = [1,2,3,4], x = 3<br/>Output: 3<br/>Explanation: We can select nums[0] = 1 and nums[3] = 4.<br/>They are at least 3 indices apart, and their absolute difference is the minimum, 3.<br/>It can be shown that 3 is the optimal answer.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^9<br/>0 &lt;= x &lt; nums.length </td>
<td>class Solution {<br/>public:<br/>    int minAbsoluteDifference(vector&lt;int&gt;&amp; nums, int x) {<br/>/*You are given a 0-indexed integer array nums and an integer x.<br/><br/>Find the minimum absolute difference between two elements in the array that are at least x indices apart.<br/><br/>In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.<br/><br/>Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.<br/><br/>Example 1:<br/><br/>Input: nums = [4,3,2,4], x = 2<br/>Output: 0<br/>Explanation: We can select nums[0] = 4 and nums[3] = 4. <br/>They are at least 2 indices apart, and their absolute difference is the minimum, 0. <br/>It can be shown that 0 is the optimal answer.<br/><br/>Example 2:<br/><br/>Input: nums = [5,3,2,10,15], x = 1<br/>Output: 1<br/>Explanation: We can select nums[1] = 3 and nums[2] = 2.<br/>They are at least 1 index apart, and their absolute difference is the minimum, 1.<br/>It can be shown that 1 is the optimal answer.<br/><br/>Example 3:<br/><br/>Input: nums = [1,2,3,4], x = 3<br/>Output: 3<br/>Explanation: We can select nums[0] = 1 and nums[3] = 4.<br/>They are at least 3 indices apart, and their absolute difference is the minimum, 3.<br/>It can be shown that 3 is the optimal answer.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^9<br/>0 &lt;= x &lt; nums.length*/</td>
<td>Class Solution {<br/>Public:<br/>    Int Minabsolutedifference(vector&lt;int&gt;&amp; Nums, Int X) {<br/>    Int N=nums.size();<br/>    Vector&lt;int&gt;v;<br/>    For(int I=0;i&lt;n;i++)<br/>    {<br/>        V.push_back(abs(nums[i]-x));<br/>    }<br/>    Sort(v.begin(),v.end());<br/>    Int Ans=v[0];<br/>    For(int I=1;i&lt;n;i++)<br/>    {<br/>        Ans=min(ans,v[i]-v[i-1]);<br/>    }<br/>    Return Ans;<br/>    }<br/>};</td>
<td>Class Solution {<br/>Public:<br/>    Int Minabsolutedifference(vector&lt;int&gt;&amp; Nums, Int X) {<br/>        Int Ans = Int_max;<br/>        Set&lt;int&gt; S;<br/>        For(int I = X; I &lt; Nums.size(); ++I){<br/>            S.insert(nums[i-x]);<br/>            Auto It = S.upper_bound(nums[i]);<br/>            If(it != S.end()) Ans = Min(ans, Abs(nums[i] - *It));<br/>            If(it != S.begin()) Ans = Min(ans, Abs(nums[i] - *Prev(it)));<br/>        }<br/>        Return Ans;<br/>    }<br/>};</td>
</tr>
<tr>
<td align="right">118</td>
<td align="right">4</td>
<td>Java</td>
<td>medium</td>
<td>StarCoder</td>
<td>IDE Extension</td>
<td>You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.<br/><br/>Return the head of the linked list after doubling it.<br/><br/>Example 1:<br/><br/>Input: head = [1,8,9]<br/>Output: [3,7,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.<br/><br/>Example 2:<br/><br/>Input: head = [9,9,9]<br/>Output: [1,9,9,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. <br/><br/>Constraints:<br/><br/>The number of nodes in the list is in the range [1, 10^4]<br/>0 &lt;= Node.val &lt;= 9<br/>The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself. </td>
<td>class Solution {<br/>    public ListNode doubleIt(ListNode head) {<br/>/*You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.<br/><br/>Return the head of the linked list after doubling it.<br/><br/>Example 1:<br/><br/>Input: head = [1,8,9]<br/>Output: [3,7,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.<br/><br/>Example 2:<br/><br/>Input: head = [9,9,9]<br/>Output: [1,9,9,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. <br/><br/>Constraints:<br/><br/>The number of nodes in the list is in the range [1, 10^4]<br/>0 &lt;= Node.val &lt;= 9<br/>The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.*/</td>
<td>Class Solution {<br/>    Public Listnode Doubleit(listnode Head) {<br/>    Listnode Dummy = New Listnode(0);<br/>    Dummy.next = Head;<br/>    Listnode Cur = Dummy;<br/>    While (Cur.next != Null &amp;&amp; Cur.next.next != Null) {<br/>        Listnode Next = Cur.next.next;<br/>        Cur.next.next =  Next.next;<br/>        Next.next = Cur.next;<br/>        Cur.next = Next;<br/>        Cur = Cur.next.next;<br/>    }<br/>    Return Dummy.next;<br/>    }<br/>}</td>
<td>Class Solution {<br/>    Public Listnode Doubleit(listnode Head) {<br/>        If (Head.val &gt; 4)<br/>            Head = New Listnode(0, Head);<br/>        For(listnode Node = Head; Node != Null; Node = Node.next) {<br/>            Node.val = (Node.val * 2) % 10;<br/>            If (Node.next != Null &amp;&amp; Node.next.val &gt; 4)<br/>                Node.val++;<br/>        }<br/>        Return Head;<br/>    }<br/>}</td>
</tr>
<tr>
<td align="right">119</td>
<td align="right">4</td>
<td>Python</td>
<td>medium</td>
<td>StarCoder</td>
<td>IDE Extension</td>
<td>You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.<br/><br/>Return the head of the linked list after doubling it.<br/><br/>Example 1:<br/><br/>Input: head = [1,8,9]<br/>Output: [3,7,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.<br/><br/>Example 2:<br/><br/>Input: head = [9,9,9]<br/>Output: [1,9,9,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. <br/><br/>Constraints:<br/><br/>The number of nodes in the list is in the range [1, 10^4]<br/>0 &lt;= Node.val &lt;= 9<br/>The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself. </td>
<td>class Solution:<br/>    def doubleIt(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:<br/>&quot;&quot;&quot;You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.<br/><br/>Return the head of the linked list after doubling it.<br/><br/>Example 1:<br/><br/>Input: head = [1,8,9]<br/>Output: [3,7,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.<br/><br/>Example 2:<br/><br/>Input: head = [9,9,9]<br/>Output: [1,9,9,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. <br/><br/>Constraints:<br/><br/>The number of nodes in the list is in the range [1, 10^4]<br/>0 &lt;= Node.val &lt;= 9<br/>The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself. &quot;&quot;&quot;</td>
<td>Class Solution:<br/>    Def Doubleit(self, Head: Optional[listnode]) -&gt; Optional[listnode]:<br/>        If Head Is None:<br/>            Return None<br/>        Temp = Head<br/>        While Temp Is Not None:<br/>            Temp.val *= 2<br/>            Temp = Temp.next<br/>        Return Head</td>
<td>Class Solution:<br/>    Def Doubleit(self, Head: Optional[listnode]) -&gt; Optional[listnode]:<br/>        If Head.val &gt; 4:<br/>            Head = Listnode(0, Head)<br/>        Node = Head<br/>        While Node:<br/>            Node.val = (Node.val * 2) % 10<br/>            If Node.next And Node.next.val &gt; 4:<br/>                Node.val += 1<br/>            Node = Node.next<br/>        Return Head</td>
</tr>
<tr>
<td align="right">120</td>
<td align="right">4</td>
<td>C++</td>
<td>medium</td>
<td>StarCoder</td>
<td>IDE Extension</td>
<td>You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.<br/><br/>Return the head of the linked list after doubling it.<br/><br/>Example 1:<br/><br/>Input: head = [1,8,9]<br/>Output: [3,7,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.<br/><br/>Example 2:<br/><br/>Input: head = [9,9,9]<br/>Output: [1,9,9,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. <br/><br/>Constraints:<br/><br/>The number of nodes in the list is in the range [1, 10^4]<br/>0 &lt;= Node.val &lt;= 9<br/>The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself. </td>
<td>class Solution {<br/>public:<br/>    ListNode* doubleIt(ListNode* head) {<br/>/*You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.<br/><br/>Return the head of the linked list after doubling it.<br/><br/>Example 1:<br/><br/>Input: head = [1,8,9]<br/>Output: [3,7,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.<br/><br/>Example 2:<br/><br/>Input: head = [9,9,9]<br/>Output: [1,9,9,8]<br/>Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. <br/><br/>Constraints:<br/><br/>The number of nodes in the list is in the range [1, 10^4]<br/>0 &lt;= Node.val &lt;= 9<br/>The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself. */</td>
<td>Class Solution {<br/>Public:<br/>    Listnode* Doubleit(listnode* Head) {<br/>        Listnode* Temp=head;<br/>        While(temp!=null){<br/>            Listnode* Temp2=temp-&gt;next;<br/>            Temp-&gt;next=new Listnode(temp-&gt;val);<br/>            Temp-&gt;next-&gt;next=temp2;<br/>            Temp=temp2;<br/>        }<br/>        Return Head;<br/>    }<br/>};</td>
<td>Class Solution {<br/>Public:<br/>    Listnode* Doubleit(listnode* Head) {<br/>        If (Head-&gt;val &gt; 4)<br/>            Head = New Listnode(0, Head);<br/>        For(listnode* Node = Head; Node; Node = Node-&gt;next) {<br/>            Node-&gt;val = (Node-&gt;val * 2) % 10;<br/>            If (Node-&gt;next &amp;&amp; Node-&gt;next-&gt;val &gt; 4)<br/>                Node-&gt;val++;<br/>        }<br/>        Return Head;<br/>    }<br/>};</td>
</tr>
<tr>
<td align="right">121</td>
<td align="right">5</td>
<td>Java</td>
<td>hard</td>
<td>StarCoder</td>
<td>IDE Extension</td>
<td>You are given an array nums of n positive integers and an integer k.<br/><br/>Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:<br/><br/>Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.<br/>Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.<br/>Multiply your score by x.<br/>Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.<br/><br/>The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.<br/><br/>Return the maximum possible score after applying at most k operations.<br/><br/>Since the answer may be large, return it modulo 10^9 + 7.<br/><br/>Example 1:<br/><br/>Input: nums = [8,3,9,3,8], k = 2<br/>Output: 81<br/>Explanation: To get a score of 81, we can apply the following operations:<br/>- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.<br/>It can be proven that 81 is the highest score one can obtain.<br/><br/>Example 2:<br/><br/>Input: nums = [19,12,14,6,10,18], k = 3<br/>Output: 4788<br/>Explanation: To get a score of 4788, we can apply the following operations: <br/>- Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.<br/>- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.<br/>It can be proven that 4788 is the highest score one can obtain.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length == n &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^5<br/>1 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9) </td>
<td>public class Solution {<br/>/*<br/> * You are given an array nums of n positive integers and an integer k.<br/><br/>Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:<br/><br/>Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.<br/>Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.<br/>Multiply your score by x.<br/>Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.<br/><br/>The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.<br/><br/>Return the maximum possible score after applying at most k operations.<br/><br/>Since the answer may be large, return it modulo 10^9 + 7.<br/><br/>Constraints:<br/><br/>1 &lt;= nums.length == n &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^5<br/>1 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9).<br/>*/<br/>    public int maximumScore(List&lt;Integer&gt; nums, int k) {</td>
<td>Public Class Solution {<br/>    Public Int Maximumscore(list&lt;integer&gt; Nums, Int K) {<br/>        <br/>        Int N = Nums.size();<br/>        Int[] Dp = New Int[n];<br/>        Int[] Prime = New Int[n];<br/>        Int[] Primecount = New Int[n];<br/>        Int[] Prefix = New Int[n];<br/>        Int[] Suffix = New Int[n];<br/>        <br/>        <br/>        For(int I = 0; I &lt; N; I++){<br/>            Dp[i] = Nums.get(i);<br/>            Prime[i] = Getprime(nums.get(i));<br/>            Primecount[i] = Getprimecount(nums.get(i));<br/>            <br/>        }<br/>        <br/>        For(int I = 1; I &lt; N; I++){<br/>            Prefix[i] = Prefix[i-1] + Primecount[i-1];<br/>        }<br/>        <br/>        For(int I = N-2; I &gt;= 0; I--){<br/>            Suffix[  I] = Suffix[i+1] + Primecount[i+1];<br/>        }<br/>        <br/>        Int[] Dp2 = New Int[n];<br/>        Int[] Dp3 = New Int[n];<br/>        Int[] Dp4 = New Int[n];<br/>        <br/>        For(int I = 0  ; I &lt; N; I++){<br/>            Dp2[i] = Dp[i];<br/>            Dp3[i] = Dp[i];<br/>            Dp4[i] = Dp[i];<br/>        }<br/>        <br/>        For(int I = 0; I &lt; K; I++){<br/>            Int Max  = -1;<br/>            Int Maxindex = -1;<br/>            For(int J = 0; J &lt; N; J++){<br/>                If(j == 0){<br/>                    Dp2[j] = Dp[j] * Prime[j];<br/>                }Else{<br/>                    Dp2[j  ] = Math.max(dp2[j-1], Dp[j] * Prime[j]);<br/>                }<br/>                <br/>                If(j == N-1){<br/>                    Dp3[j] = Dp[j] * Prime[j];<br/>                }Else{<br/>                    Dp3[j]  = Math.max(dp3[j+1], Dp[j] * Prime[j]);<br/>                }<br/>                <br/>                If(prefix[j] + Suffix[j] - Primecount[j] &gt; Max){<br/>                    Max = Prefix[j] + Suffix[j] - Primecount  [J];<br/>                    Maxindex = J;<br/>                }<br/>            }<br/>            <br/>            Dp4[maxindex] = 0;<br/>            <br/>            For(int J = 0; J &lt; N; J++){<br/>                If(j == 0){<br/>                    Dp4[j] = Math.max(dp4  [J], Dp2[j]);<br/>                }Else If(j == N-1){<br/>                    Dp4[j] = Math.max(dp4[j], Dp3[j]);<br/>                }Else{<br/>                    Dp4[j] = Math.max(dp4[j],  Math.max(dp2[j], Dp3[j]));<br/>                }<br/>            }<br/>            <br/>            For(int J = 0; J &lt; N; J++){<br/>                Dp[j] = Dp4[j];<br/>            }<br/>        }<br/>        <br/>        Int Sum = 0;<br/>        For(int I  = 0; I &lt; N; I++){<br/>            Sum = (Sum + Dp[i]) % 1000000007;<br/>        }<br/>        <br/>        Return Sum;<br/>    }<br/>    <br/>    Public Int Getprime(int Num){<br/>        Int Count = 0;<br/>        For(  Int I = 2; I &lt;= Num; I++){<br/>            If(num % I == 0){<br/>                Count++;<br/>            }<br/>        }<br/>        Return Count;<br/>    }<br/>    <br/>    Public Int Getprimecount(int Num){<br/>        Int Count = 0;<br/>        For(  Int I =  2; I &lt;= Num; I++){<br/>            If(num % I == 0){<br/>                Count++;<br/>            }<br/>        }<br/>        Return Count - 1;<br/>    }<br/>}</td>
<td>Class Solution {<br/>    Static Final Int Mod = 1000000007;<br/><br/>    Public Int Maximumscore(list&lt;integer&gt; Nums, Int K) {<br/>        Int N = Nums.size();<br/><br/>        Int Upper = Collections.max(nums) + 1;<br/><br/>        Boolean[] Prime = New Boolean[upper];<br/>        Int[] Primescore = New Int[upper];<br/>        Arrays.fill(prime, True);<br/>        Prime[0] = Prime[1] = False;<br/>        For (Int I = 2; I &lt; Upper; I++) {<br/>            If (Prime[i]) {<br/>                For (Int J = I; J &lt; Upper; J += I) {<br/>                    Primescore[j]++;<br/>                    Prime[j] = False;<br/>                }<br/>            }<br/>        }<br/><br/>        Int[] Nextgreaterelement = New Int[n];<br/>        Arrays.fill(nextgreaterelement, N);<br/>        Stack&lt;integer&gt; S = New Stack&lt;&gt;();<br/>        For (Int I = N - 1; I &gt;= 0; I--) {<br/>            While (!S.empty() &amp;&amp; Primescore[nums.get(i)] &gt;= Primescore[nums.get(s.peek())]) {<br/>                S.pop();<br/>            }<br/>            Nextgreaterelement[i] = S.empty() ? N : S.peek();<br/>            S.push(i);<br/>        }<br/><br/>        Int[] Prevgreaterorequalelement = New Int[n];<br/>        Arrays.fill(prevgreaterorequalelement, -1);<br/>        S = New Stack&lt;&gt;();<br/>        For (Int I = 0; I &lt; N; I++) {<br/>            While (!S.empty() &amp;&amp; Primescore[nums.get(i)] &gt; Primescore[nums.get(s.peek())]) {<br/>                S.pop();<br/>            }<br/>            Prevgreaterorequalelement[i] = S.empty() ? -1 : S.peek();<br/>            S.push(i);<br/>        }<br/><br/>        Int Res = 1;<br/>        Int[][] Tuples = New Int[n][2];<br/>        For (Int I = 0; I &lt; N; I++) {<br/>            Tuples[i][0] = Nums.get(i);<br/>            Tuples[i][1] = I;<br/>        }<br/>        Arrays.sort(tuples, New Comparator&lt;int[]&gt;() {<br/>            Public Int Compare(int[] A, Int[] B) {<br/>                Return B[0] - A[0];<br/>            }<br/>        });<br/>        For (Int I = 0; I &lt; N; I++) {<br/>            Int Num = Tuples[i][0];<br/>            Int Idx = Tuples[i][1];<br/>            Int Operations = Math.min((idx - Prevgreaterorequalelement[idx]) * (Nextgreaterelement[idx] - Idx), K);<br/>            Res = (Int)((1l * Res * Pow(num, Operations)) % Mod);<br/>            K -= Operations;<br/>            If (K == 0) {<br/>                Return Res;<br/>            }<br/>        }<br/><br/>        Return Res;<br/>    }<br/><br/>    Public Int Pow(int X, Int N) {<br/>        Int Res = 1;<br/>        While (N &gt; 0) {<br/>            If (N % 2 == 1) {<br/>                Res = (Int)((1l * Res * X) % Mod);<br/>            }<br/>            X = (Int)((1l * X * X) % Mod);<br/>            N /= 2;<br/>        }<br/>        Return Res;<br/>    }<br/>}</td>
</tr>
<tr>
<td align="right">122</td>
<td align="right">5</td>
<td>Python</td>
<td>hard</td>
<td>StarCoder</td>
<td>IDE Extension</td>
<td>You are given an array nums of n positive integers and an integer k.<br/><br/>Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:<br/><br/>Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.<br/>Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.<br/>Multiply your score by x.<br/>Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.<br/><br/>The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.<br/><br/>Return the maximum possible score after applying at most k operations.<br/><br/>Since the answer may be large, return it modulo 10^9 + 7.<br/><br/>Example 1:<br/><br/>Input: nums = [8,3,9,3,8], k = 2<br/>Output: 81<br/>Explanation: To get a score of 81, we can apply the following operations:<br/>- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.<br/>It can be proven that 81 is the highest score one can obtain.<br/><br/>Example 2:<br/><br/>Input: nums = [19,12,14,6,10,18], k = 3<br/>Output: 4788<br/>Explanation: To get a score of 4788, we can apply the following operations: <br/>- Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.<br/>- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.<br/>It can be proven that 4788 is the highest score one can obtain.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length == n &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^5<br/>1 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9) </td>
<td>class Solution:<br/>    def maximumScore(self, nums: List[int], k: int) -&gt; int:<br/>&quot;&quot;&quot;You are given an array nums of n positive integers and an integer k.<br/><br/>Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:<br/><br/>Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.<br/>Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.<br/>Multiply your score by x.<br/>Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.<br/><br/>The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.<br/><br/>Return the maximum possible score after applying at most k operations.<br/><br/>Since the answer may be large, return it modulo 10^9 + 7.<br/><br/>Example 1:<br/><br/>Input: nums = [8,3,9,3,8], k = 2<br/>Output: 81<br/>Explanation: To get a score of 81, we can apply the following operations:<br/>- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.<br/>It can be proven that 81 is the highest score one can obtain.<br/><br/>Example 2:<br/><br/>Input: nums = [19,12,14,6,10,18], k = 3<br/>Output: 4788<br/>Explanation: To get a score of 4788, we can apply the following operations: <br/>- Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.<br/>- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.<br/>It can be proven that 4788 is the highest score one can obtain.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length == n &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^5<br/>1 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9) &quot;&quot;&quot;</td>
<td>Class Solution:<br/>    Def Maximumscore(self, Nums: List[int], K: Int) -&gt; Int:<br/>        N = Len(nums)<br/>        Dp = [0]*n<br/>        Dp[0] = Nums[0]<br/>        For I In Range(1, N):<br/>            Dp[i] = Max(dp[i-1], Nums[i])<br/>        Ans = Dp[k-1]<br/>        For I In Range(k-1, N):<br/>            Ans = Max(ans, Dp[i] * Dp[k-1-i])<br/>        Return Ans % (10**9 + 7)</td>
<td>Class Solution: <br/>    Mod = 1000000007<br/><br/>    Def Maximumscore(self, Nums: List[int], K: Int) -&gt; Int:<br/>        N = Len(nums)<br/><br/>        Upper = Max(nums) + 1<br/><br/>        Prime = [True]*upper<br/>        Prime[0] = Prime[1] = False<br/>        Primescore = [0]*upper<br/>        For I In Range(2, Upper):<br/>            If Prime[i]:<br/>                For J In Range(i, Upper, I):<br/>                    Primescore[j] += 1<br/>                    Prime[j] = False<br/><br/>        Nextgreaterelement = [N]*n<br/>        S = []<br/>        For I In Range(n - 1, -1, -1):<br/>            While S And Primescore[nums[i]] &gt;= Primescore[nums[s[-1]]]:<br/>                S.pop()<br/>            Nextgreaterelement[i] = S[-1] If S Else N<br/>            S.append(i)<br/><br/>        Prevgreaterorequalelement = [-1]*n<br/>        S = []<br/>        For I In Range(n):<br/>            While S And Primescore[nums[i]] &gt; Primescore[nums[s[-1]]]:<br/>                S.pop()<br/>            Prevgreaterorequalelement[i] = S[-1] If S Else -1<br/>            S.append(i)<br/><br/>        Res = 1<br/>        Tuples = [[Nums[i], I] For I In Range(n)]<br/>        Tuples.sort(reverse=true)<br/>        For Num, Idx In Tuples:<br/>            Operations = Min((idx - Prevgreaterorequalelement[idx]) * (Nextgreaterelement[idx] - Idx), K)<br/>            Res = (Res * Self.pow(num, Operations)) % Self.mod<br/>            K -= Operations<br/>            If K == 0:<br/>                Return Res<br/><br/>        Return Res<br/><br/>    Def Pow(self, X: Int, N: Int) -&gt; Int:<br/>        Res = 1<br/>        While N &gt; 0:<br/>            If N % 2 == 1:<br/>                Res = (Res * X) % Self.mod<br/>            X = (X * X) % Self.mod<br/>            N //= 2<br/>        Return Res</td>
</tr>
<tr>
<td align="right">123</td>
<td align="right">5</td>
<td>C++</td>
<td>hard</td>
<td>StarCoder</td>
<td>IDE Extension</td>
<td>You are given an array nums of n positive integers and an integer k.<br/><br/>Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:<br/><br/>Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.<br/>Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.<br/>Multiply your score by x.<br/>Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.<br/><br/>The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.<br/><br/>Return the maximum possible score after applying at most k operations.<br/><br/>Since the answer may be large, return it modulo 10^9 + 7.<br/><br/>Example 1:<br/><br/>Input: nums = [8,3,9,3,8], k = 2<br/>Output: 81<br/>Explanation: To get a score of 81, we can apply the following operations:<br/>- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.<br/>It can be proven that 81 is the highest score one can obtain.<br/><br/>Example 2:<br/><br/>Input: nums = [19,12,14,6,10,18], k = 3<br/>Output: 4788<br/>Explanation: To get a score of 4788, we can apply the following operations: <br/>- Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.<br/>- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.<br/>It can be proven that 4788 is the highest score one can obtain.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length == n &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^5<br/>1 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9) </td>
<td>class Solution {<br/>public:<br/>    int maximumScore(vector&lt;int&gt;&amp; nums, int k) {<br/>/*You are given an array nums of n positive integers and an integer k.<br/><br/>Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:<br/><br/>Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.<br/>Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.<br/>Multiply your score by x.<br/>Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.<br/><br/>The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.<br/><br/>Return the maximum possible score after applying at most k operations.<br/><br/>Since the answer may be large, return it modulo 10^9 + 7.<br/><br/>Example 1:<br/><br/>Input: nums = [8,3,9,3,8], k = 2<br/>Output: 81<br/>Explanation: To get a score of 81, we can apply the following operations:<br/>- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.<br/>It can be proven that 81 is the highest score one can obtain.<br/><br/>Example 2:<br/><br/>Input: nums = [19,12,14,6,10,18], k = 3<br/>Output: 4788<br/>Explanation: To get a score of 4788, we can apply the following operations: <br/>- Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.<br/>- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.<br/>- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.<br/>It can be proven that 4788 is the highest score one can obtain.<br/> <br/>Constraints:<br/><br/>1 &lt;= nums.length == n &lt;= 10^5<br/>1 &lt;= nums[i] &lt;= 10^5<br/>1 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9)*/</td>
<td>Class Solution {<br/>Public:<br/>    Int Maximumscore(vector&lt;int&gt;&amp; Nums, Int K) {<br/>        Int Mod=1e9+7;<br/>        Int N=nums.size();<br/>        Vector&lt;int&gt; Dp(n+1,0);<br/>        Vector&lt;int&gt; Primes;<br/>        For(int I=2;i&lt;=n;i++) {<br/>            If(dp[i]==0) {<br/>                Primes.push_back(i);<br/>                For(int J=i;j&lt;=n;j+=i) {<br/>                    Dp[j]+=1;<br/>                }<br/>            }<br/>        }<br/>        Int Ans=0;<br/>        For(int I=0;i&lt;k;i++) {<br/>            Int Mx=0;<br/>            Int Mx_idx=-1;<br/>            For(int J=i;j&lt;n;j++) {<br/>                If(mx&lt;dp[j]) {<br/>                    Mx=dp[j];<br/>                    Mx_idx=j;<br/>                }<br/>            }<br/>            Ans=(ans+nums[mx_idx]*primes[mx-1])%mod;<br/>            Dp[mx_idx]=0;<br/>        }<br/>        Return Ans;<br/>    }<br/>};</td>
<td>Class Solution {<br/>Public:<br/>    Const Int Mod = 1000000007;<br/><br/>    Int Maximumscore(vector&lt;int&gt;&amp; Nums, Int K) {<br/>        Int N = Nums.size();<br/><br/>        Int Upper = *Max_element(nums.begin(), Nums.end()) + 1;<br/><br/>        Vector&lt;bool&gt; Prime(upper, True);<br/>        Prime[0] = Prime[1] = False;<br/>        Vector&lt;int&gt; Primescore(upper, 0);<br/>        For (Int I = 2; I &lt; Upper; I++) {<br/>            If (Prime[i]) {<br/>                For (Int J = I; J &lt; Upper; J += I) {<br/>                    Primescore[j]++;<br/>                    Prime[j] = False;<br/>                }<br/>            }<br/>        }<br/><br/>        Vector&lt;int&gt; Nextgreaterelement(n, N);<br/>        Stack&lt;int&gt; S;<br/>        For (Int I = N - 1; I &gt;= 0; I--) {<br/>            While (!S.empty() &amp;&amp; Primescore[nums[i]] &gt;= Primescore[nums[s.top()]]) {<br/>                S.pop();<br/>            }<br/>            Nextgreaterelement[i] = S.empty() ? N : S.top();<br/>            S.push(i);<br/>        }<br/><br/>        Vector&lt;int&gt; Prevgreaterorequalelement(n, -1);<br/>        S = Stack&lt;int&gt;();<br/>        For (Int I = 0; I &lt; N; I++) {<br/>            While (!S.empty() &amp;&amp; Primescore[nums[i]] &gt; Primescore[nums[s.top()]]) {<br/>                S.pop();<br/>            }<br/>            Prevgreaterorequalelement[i] = S.empty() ? -1 : S.top();<br/>            S.push(i);<br/>        }<br/><br/>        Int Res = 1;<br/>        Vector&lt;pair&lt;int, Int&gt;&gt; Tuples(n);<br/>        For (Int I = 0; I &lt; N; I++) {<br/>            Tuples[i].first = Nums[i];<br/>            Tuples[i].second = I;<br/>        }<br/>        Sort(tuples.rbegin(), Tuples.rend());<br/>        For (Const Auto&amp; [Num, I] : Tuples) {<br/>            Int Operations = Min((i - Prevgreaterorequalelement[i]) * (Nextgreaterelement[i] - I), K);<br/>            Res = (Int)((1l * Res * Pow(num, Operations)) % Mod);<br/>            K -= Operations;<br/>            If (K == 0) {<br/>                Return Res;<br/>            }<br/>        }<br/><br/>        Return Res;<br/>    }<br/><br/>    Int Pow(int X, Int N) {<br/>        Int Res = 1;<br/>        While (N &gt; 0) {<br/>            If (N % 2 == 1) {<br/>                Res = (Int)((1l * Res * X) % Mod);<br/>            }<br/>            X = (Int)((1l * X * X) % Mod);<br/>            N /= 2;<br/>        }<br/>        Return Res;<br/>    }<br/>};</td>
</tr>
<tr>
<td align="right">124</td>
<td align="right">6</td>
<td>Java</td>
<td>hard</td>
<td>StarCoder</td>
<td>IDE Extension</td>
<td>You are given a 0-indexed 2D integer array items of length n and an integer k.<br/><br/>items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.<br/><br/>Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.<br/><br/>Your task is to find the maximum elegance from all subsequences of size k in items.<br/><br/>Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.<br/><br/>Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.<br/><br/>Example 1:<br/><br/>Input: items = [[3,2],[5,1],[10,1]], k = 2<br/>Output: 17<br/>Explanation: In this example, we have to select a subsequence of size 2.<br/>We can select items[0] = [3,2] and items[2] = [10,1].<br/>The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].<br/>Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. <br/><br/>Example 2:<br/><br/>Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3<br/>Output: 19<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. <br/>The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. <br/>Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.<br/><br/>Example 3:<br/><br/>Input: items = [[1,1],[2,1],[3,1]], k = 3<br/>Output: 7<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We should select all the items. <br/>The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. <br/>Hence, the maximum elegance is 6 + 1^2 = 7.  <br/> <br/>Constraints:<br/><br/>1 &lt;= items.length == n &lt;= 10^5<br/>items[i].length == 2<br/>items[i][0] == profit_i<br/>items[i][1] == category_i<br/>1 &lt;= profit_i &lt;= 10^9<br/>1 &lt;= category_i &lt;= n <br/>1 &lt;= k &lt;= n </td>
<td>public class Solution {<br/>    public int findMaximumElegance(int[][] items, int k) {<br/>/*<br/> * You are given a 0-indexed 2D integer array items of length n and an integer k.<br/><br/>items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.<br/><br/>Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.<br/><br/>Your task is to find the maximum elegance from all subsequences of size k in items.<br/><br/>Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.<br/><br/>Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.<br/><br/>Example 1:<br/><br/>Input: items = [[3,2],[5,1],[10,1]], k = 2<br/>Output: 17<br/>Explanation: In this example, we have to select a subsequence of size 2.<br/>We can select items[0] = [3,2] and items[2] = [10,1].<br/>The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].<br/>Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. <br/><br/>Example 2:<br/><br/>Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3<br/>Output: 19<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. <br/>The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. <br/>Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.<br/><br/>Example 3:<br/><br/>Input: items = [[1,1],[2,1],[3,1]], k = 3<br/>Output: 7<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We should select all the items. <br/>The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. <br/>Hence, the maximum elegance is 6 + 1^2 = 7.  <br/> <br/>Constraints:<br/><br/>1 &lt;= items.length == n &lt;= 10^5<br/>items[i].length == 2<br/>items[i][0] == profit_i<br/>items[i][1] == category_i<br/>1 &lt;= profit_i &lt;= 10^9<br/>1 &lt;= category_i &lt;= n <br/>1 &lt;= k &lt;= n<br/>*/</td>
<td>Public Class Solution {<br/>    Public Int Findmaximumelegance(int[][] Items, Int K) {<br/>        Int N = Items.length;<br/>        Int[][] Dp = New Int[n][k];<br/>        For(int I=0; I&lt;n; I++) {<br/>            Dp[i][0] = Items[i][0];<br/>        }<br/>        For(int I=1; I  &lt;N; I++) {<br/>            For(int J=1; J&lt;k; J++) {<br/>                Int Max = Integer.min_value;<br/>                For(int M=0; M&lt;i; M++) {<br/>                    If(items[m][1] != Items[i][ 1]) {<br/>                        Max = Math.max(max, Dp[m][j-1]);<br/>                    }<br/>                }<br/>                Dp[i][j] = Max + Items[i][0];<br/>            }<br/>        }<br/>        Int Max = Integer.min_value;<br/>        For(int I= 0; I&lt;n; I++) {<br/>            Max = Math.max(max, Dp[i][k-1]);<br/>        }<br/>        Return Max;<br/>    }<br/>}</td>
<td>Class Solution {<br/>    Public Long Findmaximumelegance(int[][] A, Int K) {<br/>        Arrays.sort(a, (A, B) -&gt; B[0] - A[0]);<br/>        Long Res = 0, Cur = 0;<br/>        List&lt;integer&gt; Dup = New Arraylist&lt;&gt;();<br/>        Set&lt;integer&gt; Seen = New Hashset&lt;&gt;();<br/>        For (Int I = 0; I &lt; A.length; ++I) {<br/>            If (I &lt; K) {<br/>                If (Seen.contains(a[i][1])) {<br/>                    Dup.add(a[i][0]);<br/>                }<br/>                Cur += A[i][0];<br/>            } Else If (!Seen.contains(a[i][1])) {<br/>                If (Dup.isempty()) Break;<br/>                Cur += A[i][0] - Dup.remove(dup.size() - 1);<br/>            }<br/>            Seen.add(a[i][1]);<br/>            Res = Math.max(res, Cur + 1l * Seen.size() * Seen.size());<br/>        }<br/>        Return Res;<br/>    }<br/>}</td>
</tr>
<tr>
<td align="right">125</td>
<td align="right">6</td>
<td>Python</td>
<td>hard</td>
<td>StarCoder</td>
<td>IDE Extension</td>
<td>You are given a 0-indexed 2D integer array items of length n and an integer k.<br/><br/>items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.<br/><br/>Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.<br/><br/>Your task is to find the maximum elegance from all subsequences of size k in items.<br/><br/>Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.<br/><br/>Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.<br/><br/>Example 1:<br/><br/>Input: items = [[3,2],[5,1],[10,1]], k = 2<br/>Output: 17<br/>Explanation: In this example, we have to select a subsequence of size 2.<br/>We can select items[0] = [3,2] and items[2] = [10,1].<br/>The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].<br/>Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. <br/><br/>Example 2:<br/><br/>Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3<br/>Output: 19<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. <br/>The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. <br/>Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.<br/><br/>Example 3:<br/><br/>Input: items = [[1,1],[2,1],[3,1]], k = 3<br/>Output: 7<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We should select all the items. <br/>The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. <br/>Hence, the maximum elegance is 6 + 1^2 = 7.  <br/> <br/>Constraints:<br/><br/>1 &lt;= items.length == n &lt;= 10^5<br/>items[i].length == 2<br/>items[i][0] == profit_i<br/>items[i][1] == category_i<br/>1 &lt;= profit_i &lt;= 10^9<br/>1 &lt;= category_i &lt;= n <br/>1 &lt;= k &lt;= n </td>
<td>class Solution:<br/>    def findMaximumElegance(self, items: List[List[int]], k: int) -&gt; int:<br/>&quot;&quot;&quot;You are given a 0-indexed 2D integer array items of length n and an integer k.<br/><br/>items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.<br/><br/>Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.<br/><br/>Your task is to find the maximum elegance from all subsequences of size k in items.<br/><br/>Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.<br/><br/>Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.<br/><br/>Example 1:<br/><br/>Input: items = [[3,2],[5,1],[10,1]], k = 2<br/>Output: 17<br/>Explanation: In this example, we have to select a subsequence of size 2.<br/>We can select items[0] = [3,2] and items[2] = [10,1].<br/>The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].<br/>Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. <br/><br/>Example 2:<br/><br/>Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3<br/>Output: 19<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. <br/>The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. <br/>Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.<br/><br/>Example 3:<br/><br/>Input: items = [[1,1],[2,1],[3,1]], k = 3<br/>Output: 7<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We should select all the items. <br/>The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. <br/>Hence, the maximum elegance is 6 + 1^2 = 7.  <br/> <br/>Constraints:<br/><br/>1 &lt;= items.length == n &lt;= 10^5<br/>items[i].length == 2<br/>items[i][0] == profit_i<br/>items[i][1] == category_i<br/>1 &lt;= profit_i &lt;= 10^9<br/>1 &lt;= category_i &lt;= n <br/>1 &lt;= k &lt;= n &quot;&quot;&quot;</td>
<td>Class Solution:<br/>    Def Findmaximumelegance(self, Items: List[list[int]], K: Int) -&gt; Int:<br/>        N = Len(items)<br/>        Dp = [[0]*n For _ In Range(n)]<br/>        For I In Range(n):<br/>            Dp[i][i] = Items[i][0]<br/>        For L In Range(2, N+1):<br/>            For I In Range(n-l+1):<br/>                J = I+l-1<br/>                Dp[i][j] = Max(dp[i][j-1], Dp[i+1][j]) + Items[j][0]<br/>        Return Max(dp[0][k-1], Dp[n-k][n-1])</td>
<td>Class Solution:<br/>    Def Findmaximumelegance(self, Items: List[list[int]], K: Int) -&gt; Int:<br/>        Items = Sorted(items, Key=lambda V: -V[0])<br/>        Res = Cur = 0<br/>        A = []<br/>        Seen = Set()<br/>        For I, (P, C) In Enumerate(items):<br/>            If I &lt; K:<br/>                If C In Seen:<br/>                    A.append(p)<br/>                Cur += P<br/>            Elif C Not In Seen:<br/>                If Not A: Break<br/>                Cur += P - A.pop()<br/>            Seen.add(c)<br/>            Res = Max(res, Cur + Len(seen) * Len(seen))<br/>        Return Res</td>
</tr>
<tr>
<td align="right">126</td>
<td align="right">6</td>
<td>C++</td>
<td>hard</td>
<td>StarCoder</td>
<td>IDE Extension</td>
<td>You are given a 0-indexed 2D integer array items of length n and an integer k.<br/><br/>items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.<br/><br/>Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.<br/><br/>Your task is to find the maximum elegance from all subsequences of size k in items.<br/><br/>Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.<br/><br/>Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.<br/><br/>Example 1:<br/><br/>Input: items = [[3,2],[5,1],[10,1]], k = 2<br/>Output: 17<br/>Explanation: In this example, we have to select a subsequence of size 2.<br/>We can select items[0] = [3,2] and items[2] = [10,1].<br/>The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].<br/>Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. <br/><br/>Example 2:<br/><br/>Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3<br/>Output: 19<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. <br/>The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. <br/>Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.<br/><br/>Example 3:<br/><br/>Input: items = [[1,1],[2,1],[3,1]], k = 3<br/>Output: 7<br/>Explanation: In this example, we have to select a subsequence of size 3. <br/>We should select all the items. <br/>The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. <br/>Hence, the maximum elegance is 6 + 1^2 = 7.  <br/> <br/>Constraints:<br/><br/>1 &lt;= items.length == n &lt;= 10^5<br/>items[i].length == 2<br/>items[i][0] == profit_i<br/>items[i][1] == category_i<br/>1 &lt;= profit_i &lt;= 10^9<br/>1 &lt;= category_i &lt;= n <br/>1 &lt;= k &lt;= n </td>
<td>class Solution {<br/>public:<br/>    long long findMaximumElegance(vector&lt;vector&lt;int&gt;&gt;&amp; items, int k) {<br/>/*You are given a 0-indexed 2D integer array items of length n and an integer k.<br/><br/>items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.<br/><br/>Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.<br/><br/>Your task is to find the maximum elegance from all subsequences of size k in items.<br/><br/>Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.<br/><br/>Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.<br/><br/>Example 1:<br/><br/>Input: items = [[3,2],[5,1],[10,1]], k = 2<br/>Output: 17<br/><br/>Example 2:<br/><br/>Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3<br/>Output: 19<br/><br/>Example 3:<br/><br/>Input: items = [[1,1],[2,1],[3,1]], k = 3<br/>Output: 7<br/> <br/>Constraints:<br/><br/>1 &lt;= items.length == n &lt;= 10^5<br/>items[i].length == 2<br/>items[i][0] == profit_i<br/>items[i][1] == category_i<br/>1 &lt;= profit_i &lt;= 10^9<br/>1 &lt;= category_i &lt;= n <br/>1 &lt;= k &lt;= n */</td>
<td>Class Solution {<br/>Public:<br/>    Long Long Findmaximumelegance(vector&lt;vector&lt;int&gt;&gt;&amp; Items, Int K) {<br/>  Int N=items.size();<br/>  Vector&lt;vector&lt;int&gt;&gt;dp(n,vector&lt;int&gt;(k,0));<br/>  For(int I=0;i&lt;n;i++)<br/>  {<br/>    Dp[i][0]=items[i][0];<br/>  }<br/>  For(int I=1;i&lt;n;i++)<br/>  {<br/>    For(int J=1;j&lt;k;j++)<br/>    {<br/>      Dp[i][j]=max(dp[i-1][j],dp[i-1][j-1]);<br/>      If(items[i][1]!=items[i-1][1])<br/>      {<br/>        Dp[i][j]=max(dp[i][j],dp[i-1][j]+items[i][0]);<br/>      }<br/>    }<br/>  }<br/>  Return Dp[n-1][k-1];<br/>    }<br/>};</td>
<td>Class Solution {<br/>Public:<br/>    Long Long Findmaximumelegance(vector&lt;vector&lt;int&gt;&gt;&amp; A, Int K) {<br/>        Sort(a.begin(), A.end(), [](Const Vector&lt;int&gt;&amp; A, Const Vector&lt;int&gt;&amp; B) {<br/>            Return A[0] &gt; B[0];<br/>        });<br/>        Long Long Res = 0, Cur = 0;<br/>        Vector&lt;int&gt; Dup;<br/>        Unordered_set&lt;int&gt; Seen;<br/>        For (Int I = 0; I &lt; A.size(); ++I) {<br/>            If (I &lt; K) {<br/>                If (Seen.count(a[i][1])) {<br/>                    Dup.push_back(a[i][0]);<br/>                }<br/>                Cur += A[i][0];<br/>            } Else If (Seen.find(a[i][1]) == Seen.end()) {<br/>                If (Dup.empty()) Break;<br/>                Cur += A[i][0] - Dup.back();<br/>                Dup.pop_back();<br/>            }<br/>            Seen.insert(a[i][1]);<br/>            Res = Fmax(res, Cur + 1l * Seen.size() * Seen.size());<br/>        }<br/>        Return Res;<br/>    }<br/>};</td>
</tr>
</tbody></table>