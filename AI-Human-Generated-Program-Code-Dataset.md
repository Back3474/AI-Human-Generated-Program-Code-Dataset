|id |problem_number|language|difficulty|generator_name |generator_type   |description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |prompt                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |ai_generated_code                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |human_generated_code                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
|---|--------------|--------|----------|---------------|-----------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|1  |1             |Java    |easy      |Bing AI Chat   |Chatbot          |You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.  Return the maximum sum or -1 if no such pair exists.  Example 1:  Input: nums = [51,71,17,24,42] Output: 88 Explanation:  For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88.  For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66. It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.  Example 2:  Input: nums = [1,2,3,4] Output: -1 Explanation: No pair exists in nums with equal maximum digits.  Constraints:  2 <= nums.length <= 100 1 <= nums[i] <= 10^4                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |solve the following problem with java code. Class name: Solution, Method name: maxSum(int[] nums).  You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.  Return the maximum sum or -1 if no such pair exists.  Example 1:  Input: nums = [51,71,17,24,42] Output: 88 Explanation:  For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88.  For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66. It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.  Example 2:  Input: nums = [1,2,3,4] Output: -1 Explanation: No pair exists in nums with equal maximum digits.  Constraints:  2 <= nums.length <= 100 1 <= nums[i] <= 10^4                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |public class Solution {     public int maxSum(int[] nums) {         int[] maxSum = new int[10];         for (int num : nums) {             int maxDigit = 0;             int temp = num;             while (temp > 0) {                 maxDigit = Math.max(maxDigit, temp % 10);                 temp /= 10;             }             for (int i = 0; i < 10; i++) {                 if (i == maxDigit) {                     maxSum[i] = Math.max(maxSum[i], num + maxSum[i]);                 } else {                     maxSum[i] = Math.max(maxSum[i], num);                 }             }         }         int res = -1;         for (int sum : maxSum) {             res = Math.max(res, sum);         }         return res == 0 ? -1 : res;     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |class Solution {     public int maxSum(int[] nums) {     int ans = -1;     Map<Integer,List<Integer>> ump = new HashMap<>();     for(int i = 0; i < nums.length; ++i){         int t = nums[i], maxDigit = 0;         while(t != 0){ //evaluate max digit in the number             maxDigit = Math.max(t%10, maxDigit);             t = t/10;         }         if(!ump.containsKey(maxDigit)) ump.put(maxDigit, new ArrayList<>());         ump.get(maxDigit).add(nums[i]); // add the number to the map      }     for(Map.Entry<Integer, List<Integer>> entry: ump.entrySet()){         entry.getValue().sort(Comparator.reverseOrder()); //to find max two number in each max digit          if(entry.getValue().size() >= 2) ans = Math.max(ans, entry.getValue().get(0) + entry.getValue().get(1)); //sum max two number and take max     }     return ans;     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
|2  |1             |Python  |easy      |Bing AI Chat   |Chatbot          |You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.  Return the maximum sum or -1 if no such pair exists.  Example 1:  Input: nums = [51,71,17,24,42] Output: 88 Explanation:  For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88.  For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66. It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.  Example 2:  Input: nums = [1,2,3,4] Output: -1 Explanation: No pair exists in nums with equal maximum digits.  Constraints:  2 <= nums.length <= 100 1 <= nums[i] <= 10^4                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |solve the following problem with python3 code. Class name: Solution, Method name: def maxSum(self, nums: List[int]) -> int:.  You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.  Return the maximum sum or -1 if no such pair exists.  Example 1:  Input: nums = [51,71,17,24,42] Output: 88 Explanation:  For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88.  For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66. It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.  Example 2:  Input: nums = [1,2,3,4] Output: -1 Explanation: No pair exists in nums with equal maximum digits.  Constraints:  2 <= nums.length <= 100 1 <= nums[i] <= 10^4                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |class Solution:     def maxSum(self, nums: List[int]) -> int:         max_digit = {}         for num in nums:             digit = max(int(d) for d in str(num))             if digit not in max_digit:                 max_digit[digit] = []             max_digit[digit].append(num)         res = -1         for digit, values in max_digit.items():             if len(values) >= 2:                 values.sort(reverse=True)                 res = max(res, values[0] + values[1])         return res                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |class Solution:     def maxSum(self, nums: List[int]) -> int:         max_by_digit = defaultdict(int)         max_sum = -1          for num in nums:             digit = max(str(num))              if digit in max_by_digit:                 max_sum = max(max_sum, max_by_digit[digit] + num)              max_by_digit[digit] = max(max_by_digit[digit], num)          return max_sum                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
|3  |1             |C++     |easy      |Bing AI Chat   |Chatbot          |You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.  Return the maximum sum or -1 if no such pair exists.  Example 1:  Input: nums = [51,71,17,24,42] Output: 88 Explanation:  For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88.  For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66. It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.  Example 2:  Input: nums = [1,2,3,4] Output: -1 Explanation: No pair exists in nums with equal maximum digits.  Constraints:  2 <= nums.length <= 100 1 <= nums[i] <= 10^4                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |solve the following problem with C++ code. Class name: Solution, Method name: maxSum(std::vector<int>& nums).  You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.  Return the maximum sum or -1 if no such pair exists.  Example 1:  Input: nums = [51,71,17,24,42] Output: 88 Explanation:  For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88.  For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66. It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.  Example 2:  Input: nums = [1,2,3,4] Output: -1 Explanation: No pair exists in nums with equal maximum digits.  Constraints:  2 <= nums.length <= 100 1 <= nums[i] <= 10^4                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |class Solution { public:     int maxSum(std::vector<int>& nums) {         int maxSum = -1;         for (int i = 0; i < nums.size(); i++) {             for (int j = i + 1; j < nums.size(); j++) {                 if (maxDigit(nums[i]) == maxDigit(nums[j])) {                     maxSum = std::max(maxSum, nums[i] + nums[j]);                 }             }         }         return maxSum;     }  private:     int maxDigit(int num) {         int maxDigit = 0;         while (num > 0) {             maxDigit = std::max(maxDigit, num % 10);             num /= 10;         }         return maxDigit;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |class Solution {     public:         int maxSum(vector<int>& nums) {         int res = -1, max_num[10] = {};         for (auto num : nums) {             int max_d = 0;             for (int v = num; v; v /= 10)                 max_d = max(max_d, v % 10);             if (max_num[max_d])                 res = max(res, max_num[max_d] + num);             max_num[max_d] = max(max_num[max_d], num);         }         return res;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|4  |2             |Java    |easy      |Bing AI Chat   |Chatbot          |Your laptop keyboard is faulty, and whenever you type a character 'i' on it, it reverses the string that you have written. Typing other characters works as expected.  You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.  Return the final string that will be present on your laptop screen.  Example 1:  Input: s = "string" Output: "rtsng" Explanation:  After typing first character, the text on the screen is "s". After the second character, the text is "st".  After the third character, the text is "str". Since the fourth character is an 'i', the text gets reversed and becomes "rts". After the fifth character, the text is "rtsn".  After the sixth character, the text is "rtsng".  Therefore, we return "rtsng".  Example 2:  Input: s = "poiinter" Output: "ponter" Explanation:  After the first character, the text on the screen is "p". After the second character, the text is "po".  Since the third character you type is an 'i', the text gets reversed and becomes "op".  Since the fourth character you type is an 'i', the text gets reversed and becomes "po". After the fifth character, the text is "pon". After the sixth character, the text is "pont".  After the seventh character, the text is "ponte".  After the eighth character, the text is "ponter".  Therefore, we return "ponter".   Constraints:  1 <= s.length <= 100 s consists of lowercase English letters. s[0] != 'i'                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |Solve the following problem with java code. Class name: Solution, Method name: finalString(String s).  Your laptop keyboard is faulty, and whenever you type a character 'i' on it, it reverses the string that you have written. Typing other characters works as expected.  You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.  Return the final string that will be present on your laptop screen.  Example 1:  Input: s = "string" Output: "rtsng" Explanation:  After typing first character, the text on the screen is "s". After the second character, the text is "st".  After the third character, the text is "str". Since the fourth character is an 'i', the text gets reversed and becomes "rts". After the fifth character, the text is "rtsn".  After the sixth character, the text is "rtsng".  Therefore, we return "rtsng".  Example 2:  Input: s = "poiinter" Output: "ponter" Explanation:  After the first character, the text on the screen is "p". After the second character, the text is "po".  Since the third character you type is an 'i', the text gets reversed and becomes "op".  Since the fourth character you type is an 'i', the text gets reversed and becomes "po". After the fifth character, the text is "pon". After the sixth character, the text is "pont".  After the seventh character, the text is "ponte".  After the eighth character, the text is "ponter".  Therefore, we return "ponter".   Constraints:  1 <= s.length <= 100 s consists of lowercase English letters. s[0] != 'i'                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |class Solution {     public String finalString(String s) {         StringBuilder sb = new StringBuilder();         for (char c : s.toCharArray()) {             if (c == 'i') {                 sb.reverse();             } else {                 sb.append(c);             }         }         return sb.toString();     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |class Solution {     public String finalString(String s) {         StringBuilder nm=new StringBuilder();         for(char c:s.toCharArray())         {             if(c=='i')             {                 nm.reverse();             }             else             {                 nm.append(c);             }         }         return nm.toString();     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|5  |2             |Python  |easy      |Bing AI Chat   |Chatbot          |Your laptop keyboard is faulty, and whenever you type a character 'i' on it, it reverses the string that you have written. Typing other characters works as expected.  You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.  Return the final string that will be present on your laptop screen.  Example 1:  Input: s = "string" Output: "rtsng" Explanation:  After typing first character, the text on the screen is "s". After the second character, the text is "st".  After the third character, the text is "str". Since the fourth character is an 'i', the text gets reversed and becomes "rts". After the fifth character, the text is "rtsn".  After the sixth character, the text is "rtsng".  Therefore, we return "rtsng".  Example 2:  Input: s = "poiinter" Output: "ponter" Explanation:  After the first character, the text on the screen is "p". After the second character, the text is "po".  Since the third character you type is an 'i', the text gets reversed and becomes "op".  Since the fourth character you type is an 'i', the text gets reversed and becomes "po". After the fifth character, the text is "pon". After the sixth character, the text is "pont".  After the seventh character, the text is "ponte".  After the eighth character, the text is "ponter".  Therefore, we return "ponter".   Constraints:  1 <= s.length <= 100 s consists of lowercase English letters. s[0] != 'i'                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |Solve the following problem with python3 code. Class name: Solution, Method name: def finalString(self, s: str) -> str:.  Your laptop keyboard is faulty, and whenever you type a character 'i' on it, it reverses the string that you have written. Typing other characters works as expected.  You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.  Return the final string that will be present on your laptop screen.  Example 1:  Input: s = "string" Output: "rtsng" Explanation:  After typing first character, the text on the screen is "s". After the second character, the text is "st".  After the third character, the text is "str". Since the fourth character is an 'i', the text gets reversed and becomes "rts". After the fifth character, the text is "rtsn".  After the sixth character, the text is "rtsng".  Therefore, we return "rtsng".  Example 2:  Input: s = "poiinter" Output: "ponter" Explanation:  After the first character, the text on the screen is "p". After the second character, the text is "po".  Since the third character you type is an 'i', the text gets reversed and becomes "op".  Since the fourth character you type is an 'i', the text gets reversed and becomes "po". After the fifth character, the text is "pon". After the sixth character, the text is "pont".  After the seventh character, the text is "ponte".  After the eighth character, the text is "ponter".  Therefore, we return "ponter".   Constraints:  1 <= s.length <= 100 s consists of lowercase English letters. s[0] != 'i'                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |class Solution:     def finalString(self, s: str) -> str:         res = ""         for c in s:             if c == 'i':                 res = res[::-1]             else:                 res += c         return res                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |class Solution:     def finalString(self, s: str) -> str:         while "i" in s:             index=s.index("i")              #first half and second half             first=s[:index][::-1]             second=s[index+1:]              s="".join([first,second])         return s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|6  |2             |C++     |easy      |Bing AI Chat   |Chatbot          |Your laptop keyboard is faulty, and whenever you type a character 'i' on it, it reverses the string that you have written. Typing other characters works as expected.  You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.  Return the final string that will be present on your laptop screen.  Example 1:  Input: s = "string" Output: "rtsng" Explanation:  After typing first character, the text on the screen is "s". After the second character, the text is "st".  After the third character, the text is "str". Since the fourth character is an 'i', the text gets reversed and becomes "rts". After the fifth character, the text is "rtsn".  After the sixth character, the text is "rtsng".  Therefore, we return "rtsng".  Example 2:  Input: s = "poiinter" Output: "ponter" Explanation:  After the first character, the text on the screen is "p". After the second character, the text is "po".  Since the third character you type is an 'i', the text gets reversed and becomes "op".  Since the fourth character you type is an 'i', the text gets reversed and becomes "po". After the fifth character, the text is "pon". After the sixth character, the text is "pont".  After the seventh character, the text is "ponte".  After the eighth character, the text is "ponter".  Therefore, we return "ponter".   Constraints:  1 <= s.length <= 100 s consists of lowercase English letters. s[0] != 'i'                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |Solve the following problem with C++ code. Class name: Solution, Method name: string finalString(string s).  Your laptop keyboard is faulty, and whenever you type a character 'i' on it, it reverses the string that you have written. Typing other characters works as expected.  You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.  Return the final string that will be present on your laptop screen.  Example 1:  Input: s = "string" Output: "rtsng" Explanation:  After typing first character, the text on the screen is "s". After the second character, the text is "st".  After the third character, the text is "str". Since the fourth character is an 'i', the text gets reversed and becomes "rts". After the fifth character, the text is "rtsn".  After the sixth character, the text is "rtsng".  Therefore, we return "rtsng".  Example 2:  Input: s = "poiinter" Output: "ponter" Explanation:  After the first character, the text on the screen is "p". After the second character, the text is "po".  Since the third character you type is an 'i', the text gets reversed and becomes "op".  Since the fourth character you type is an 'i', the text gets reversed and becomes "po". After the fifth character, the text is "pon". After the sixth character, the text is "pont".  After the seventh character, the text is "ponte".  After the eighth character, the text is "ponter".  Therefore, we return "ponter".   Constraints:  1 <= s.length <= 100 s consists of lowercase English letters. s[0] != 'i'                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |class Solution { public:     std::string finalString(std::string s) {         std::string result = "";         for (char c : s) {             if (c == 'i') {                 std::reverse(result.begin(), result.end());             } else {                 result += c;             }         }         return result;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |class Solution { public:     string finalString(const string &s) {         string a, b;         for (char ch : s)             if (ch == 'i')                 swap(a, b);             else                 a += ch;         return string(rbegin(b), rend(b)) + a;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
|7  |3             |Java    |medium    |Bing AI Chat   |Chatbot          |You are given a 0-indexed integer array nums and an integer x.  Find the minimum absolute difference between two elements in the array that are at least x indices apart.  In other words, find two indices i and j such that abs(i - j) >= x and abs(nums[i] - nums[j]) is minimized.  Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.  Example 1:  Input: nums = [4,3,2,4], x = 2 Output: 0 Explanation: We can select nums[0] = 4 and nums[3] = 4.  They are at least 2 indices apart, and their absolute difference is the minimum, 0.  It can be shown that 0 is the optimal answer.  Example 2:  Input: nums = [5,3,2,10,15], x = 1 Output: 1 Explanation: We can select nums[1] = 3 and nums[2] = 2. They are at least 1 index apart, and their absolute difference is the minimum, 1. It can be shown that 1 is the optimal answer.  Example 3:  Input: nums = [1,2,3,4], x = 3 Output: 3 Explanation: We can select nums[0] = 1 and nums[3] = 4. They are at least 3 indices apart, and their absolute difference is the minimum, 3. It can be shown that 3 is the optimal answer.   Constraints:  1 <= nums.length <= 10^5 1 <= nums[i] <= 10^9 0 <= x < nums.length                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |Solve the following problem with java code. Class name: Solution, Method name: minAbsoluteDifference(List<Integer> nums, int x).  You are given a 0-indexed integer array nums and an integer x.  Find the minimum absolute difference between two elements in the array that are at least x indices apart.  In other words, find two indices i and j such that abs(i - j) >= x and abs(nums[i] - nums[j]) is minimized.  Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.  Example 1:  Input: nums = [4,3,2,4], x = 2 Output: 0 Explanation: We can select nums[0] = 4 and nums[3] = 4.  They are at least 2 indices apart, and their absolute difference is the minimum, 0.  It can be shown that 0 is the optimal answer.  Example 2:  Input: nums = [5,3,2,10,15], x = 1 Output: 1 Explanation: We can select nums[1] = 3 and nums[2] = 2. They are at least 1 index apart, and their absolute difference is the minimum, 1. It can be shown that 1 is the optimal answer.  Example 3:  Input: nums = [1,2,3,4], x = 3 Output: 3 Explanation: We can select nums[0] = 1 and nums[3] = 4. They are at least 3 indices apart, and their absolute difference is the minimum, 3. It can be shown that 3 is the optimal answer.   Constraints:  1 <= nums.length <= 10^5 1 <= nums[i] <= 10^9 0 <= x < nums.length                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |public class Solution {     public int minAbsoluteDifference(List<Integer> nums, int x) {         TreeMap<Integer, Integer> map = new TreeMap<>();         map.put(nums.get(0), 0);         int n = nums.size();         int minDiff = Integer.MAX_VALUE;          for (int i = 1; i < n; i++) {             if (i >= x) {                 map.remove(nums.get(i - x));             }             Integer lower = map.floorKey(nums.get(i));             Integer higher = map.ceilingKey(nums.get(i));             if (lower != null) {                 minDiff = Math.min(minDiff, Math.abs(nums.get(i) - lower));             }             if (higher != null) {                 minDiff = Math.min(minDiff, Math.abs(nums.get(i) - higher));             }             map.put(nums.get(i), i);         }          return minDiff;     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |class Solution {     int minAbsoluteDifference(List<Integer> nums, int x) {         int ans = Integer.MAX_VALUE;         TreeSet<Integer> s = new TreeSet<>();         for(int i = x; i < nums.size(); ++i){             s.add(nums.get(i-x));             Integer high = s.ceiling(nums.get(i)), low = s.floor(nums.get(i));             if(high != null) ans = Math.min(ans, Math.abs(nums.get(i) - high));             if(low != null) ans = Math.min(ans, Math.abs(nums.get(i) - low));         }         return ans;     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|8  |3             |Python  |medium    |Bing AI Chat   |Chatbot          |You are given a 0-indexed integer array nums and an integer x.  Find the minimum absolute difference between two elements in the array that are at least x indices apart.  In other words, find two indices i and j such that abs(i - j) >= x and abs(nums[i] - nums[j]) is minimized.  Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.  Example 1:  Input: nums = [4,3,2,4], x = 2 Output: 0 Explanation: We can select nums[0] = 4 and nums[3] = 4.  They are at least 2 indices apart, and their absolute difference is the minimum, 0.  It can be shown that 0 is the optimal answer.  Example 2:  Input: nums = [5,3,2,10,15], x = 1 Output: 1 Explanation: We can select nums[1] = 3 and nums[2] = 2. They are at least 1 index apart, and their absolute difference is the minimum, 1. It can be shown that 1 is the optimal answer.  Example 3:  Input: nums = [1,2,3,4], x = 3 Output: 3 Explanation: We can select nums[0] = 1 and nums[3] = 4. They are at least 3 indices apart, and their absolute difference is the minimum, 3. It can be shown that 3 is the optimal answer.   Constraints:  1 <= nums.length <= 10^5 1 <= nums[i] <= 10^9 0 <= x < nums.length                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |Solve the following problem with python3 code. Class name: Solution, Method name: def minAbsoluteDifference(self, nums: List[int], x: int) -> int:.  You are given a 0-indexed integer array nums and an integer x.  Find the minimum absolute difference between two elements in the array that are at least x indices apart.  In other words, find two indices i and j such that abs(i - j) >= x and abs(nums[i] - nums[j]) is minimized.  Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.  Example 1:  Input: nums = [4,3,2,4], x = 2 Output: 0 Explanation: We can select nums[0] = 4 and nums[3] = 4.  They are at least 2 indices apart, and their absolute difference is the minimum, 0.  It can be shown that 0 is the optimal answer.  Example 2:  Input: nums = [5,3,2,10,15], x = 1 Output: 1 Explanation: We can select nums[1] = 3 and nums[2] = 2. They are at least 1 index apart, and their absolute difference is the minimum, 1. It can be shown that 1 is the optimal answer.  Example 3:  Input: nums = [1,2,3,4], x = 3 Output: 3 Explanation: We can select nums[0] = 1 and nums[3] = 4. They are at least 3 indices apart, and their absolute difference is the minimum, 3. It can be shown that 3 is the optimal answer.   Constraints:  1 <= nums.length <= 10^5 1 <= nums[i] <= 10^9 0 <= x < nums.length                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |class Solution:     def minAbsoluteDifference(self, nums: List[int], x: int) -> int:         n = len(nums)         min_diff = float('inf')         for i in range(n):             for j in range(i + x, n):                 min_diff = min(min_diff, abs(nums[i] - nums[j]))         return min_diff                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |class Solution:   def minAbsoluteDifference(self, nums: List[int], x: int) -> int:     if x == 0:       return 0      arr, best_dist = SortedList([]), float('inf')     for i in range(x, len(nums)):       arr.add(nums[i - x])       v = nums[i]        pos = arr.bisect_left(v)       if pos < len(arr):         best_dist = min(best_dist, abs(arr[pos] - v))       if pos > 0:         best_dist = min(best_dist, abs(arr[pos - 1] - v))          return best_dist                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
|9  |3             |C++     |medium    |Bing AI Chat   |Chatbot          |You are given a 0-indexed integer array nums and an integer x.  Find the minimum absolute difference between two elements in the array that are at least x indices apart.  In other words, find two indices i and j such that abs(i - j) >= x and abs(nums[i] - nums[j]) is minimized.  Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.  Example 1:  Input: nums = [4,3,2,4], x = 2 Output: 0 Explanation: We can select nums[0] = 4 and nums[3] = 4.  They are at least 2 indices apart, and their absolute difference is the minimum, 0.  It can be shown that 0 is the optimal answer.  Example 2:  Input: nums = [5,3,2,10,15], x = 1 Output: 1 Explanation: We can select nums[1] = 3 and nums[2] = 2. They are at least 1 index apart, and their absolute difference is the minimum, 1. It can be shown that 1 is the optimal answer.  Example 3:  Input: nums = [1,2,3,4], x = 3 Output: 3 Explanation: We can select nums[0] = 1 and nums[3] = 4. They are at least 3 indices apart, and their absolute difference is the minimum, 3. It can be shown that 3 is the optimal answer.   Constraints:  1 <= nums.length <= 10^5 1 <= nums[i] <= 10^9 0 <= x < nums.length                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |Solve the following problem with C++ code. Class name: Solution, Method name: int minAbsoluteDifference(vector<int>& nums, int x).  You are given a 0-indexed integer array nums and an integer x.  Find the minimum absolute difference between two elements in the array that are at least x indices apart.  In other words, find two indices i and j such that abs(i - j) >= x and abs(nums[i] - nums[j]) is minimized.  Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.  Example 1:  Input: nums = [4,3,2,4], x = 2 Output: 0 Explanation: We can select nums[0] = 4 and nums[3] = 4.  They are at least 2 indices apart, and their absolute difference is the minimum, 0.  It can be shown that 0 is the optimal answer.  Example 2:  Input: nums = [5,3,2,10,15], x = 1 Output: 1 Explanation: We can select nums[1] = 3 and nums[2] = 2. They are at least 1 index apart, and their absolute difference is the minimum, 1. It can be shown that 1 is the optimal answer.  Example 3:  Input: nums = [1,2,3,4], x = 3 Output: 3 Explanation: We can select nums[0] = 1 and nums[3] = 4. They are at least 3 indices apart, and their absolute difference is the minimum, 3. It can be shown that 3 is the optimal answer.   Constraints:  1 <= nums.length <= 10^5 1 <= nums[i] <= 10^9 0 <= x < nums.length                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |class Solution { public:     int minAbsoluteDifference(std::vector<int>& nums, int x) {         int minDiff = INT_MAX;         for (int i = 0; i < nums.size(); i++) {             for (int j = i + x; j < nums.size(); j++) {                 minDiff = std::min(minDiff, std::abs(nums[i] - nums[j]));             }         }         return minDiff;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |class Solution { public:     int minAbsoluteDifference(vector<int>& nums, int x) {         int ans = INT_MAX;         set<int> s;         for(int i = x; i < nums.size(); ++i){             s.insert(nums[i-x]);             auto it = s.upper_bound(nums[i]);             if(it != s.end()) ans = min(ans, abs(nums[i] - *it));             if(it != s.begin()) ans = min(ans, abs(nums[i] - *prev(it)));         }         return ans;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|10 |4             |Java    |medium    |Bing AI Chat   |Chatbot          |You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.  Return the head of the linked list after doubling it.  Example 1:  Input: head = [1,8,9] Output: [3,7,8] Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.  Example 2:  Input: head = [9,9,9] Output: [1,9,9,8] Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998.   Constraints:  The number of nodes in the list is in the range [1, 10^4] 0 <= Node.val <= 9 The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |Solve the following problem with java code. Class name: Solution, Method name: doubleIt(ListNode head).  You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.  Return the head of the linked list after doubling it.  Example 1:  Input: head = [1,8,9] Output: [3,7,8] Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.  Example 2:  Input: head = [9,9,9] Output: [1,9,9,8] Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998.   Constraints:  The number of nodes in the list is in the range [1, 10^4] 0 <= Node.val <= 9 The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |class Solution {     public ListNode doubleIt(ListNode head) {         // Convert linked list to number         long num = 0;         while (head != null) {             num = num * 10 + head.val;             head = head.next;         }          // Double the number         num *= 2;          // Convert number back to linked list         ListNode dummy = new ListNode(0);         ListNode curr = dummy;         do {             curr.next = new ListNode((int)(num % 10));             num /= 10;             curr = curr.next;         } while (num > 0);          // Reverse the linked list and return         return reverse(dummy.next);     }      private ListNode reverse(ListNode head) {         ListNode prev = null;         while (head != null) {             ListNode next = head.next;             head.next = prev;             prev = head;             head = next;         }         return prev;     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |class Solution {     public ListNode doubleIt(ListNode head) {         if (head.val > 4)             head = new ListNode(0, head);         for(ListNode node = head; node != null; node = node.next) {             node.val = (node.val * 2) % 10;             if (node.next != null && node.next.val > 4)                 node.val++;         }         return head;     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
|11 |4             |Python  |medium    |Bing AI Chat   |Chatbot          |You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.  Return the head of the linked list after doubling it.  Example 1:  Input: head = [1,8,9] Output: [3,7,8] Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.  Example 2:  Input: head = [9,9,9] Output: [1,9,9,8] Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998.   Constraints:  The number of nodes in the list is in the range [1, 10^4] 0 <= Node.val <= 9 The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |Solve the following problem with python3 code. Class name: Solution, Method name: def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:.  You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.  Return the head of the linked list after doubling it.  Example 1:  Input: head = [1,8,9] Output: [3,7,8] Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.  Example 2:  Input: head = [9,9,9] Output: [1,9,9,8] Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998.   Constraints:  The number of nodes in the list is in the range [1, 10^4] 0 <= Node.val <= 9 The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |class Solution:     def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:         # Convert linked list to integer         num = 0         curr = head         while curr:             num = num * 10 + curr.val             curr = curr.next          # Double the integer         num *= 2          # Convert integer to linked list         dummy = ListNode(0)         curr = dummy         for digit in str(num):             curr.next = ListNode(int(digit))             curr = curr.next          return dummy.next                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |class Solution:     def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:         if head.val > 4:             head = ListNode(0, head)         node = head         while node:             node.val = (node.val * 2) % 10             if node.next and node.next.val > 4:                 node.val += 1             node = node.next         return head                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
|12 |4             |C++     |medium    |Bing AI Chat   |Chatbot          |You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.  Return the head of the linked list after doubling it.  Example 1:  Input: head = [1,8,9] Output: [3,7,8] Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.  Example 2:  Input: head = [9,9,9] Output: [1,9,9,8] Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998.   Constraints:  The number of nodes in the list is in the range [1, 10^4] 0 <= Node.val <= 9 The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |Solve the following problem with C++ code. Class name: Solution, Method name: ListNode* doubleIt(ListNode* head).  You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.  Return the head of the linked list after doubling it.  Example 1:  Input: head = [1,8,9] Output: [3,7,8] Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.  Example 2:  Input: head = [9,9,9] Output: [1,9,9,8] Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998.   Constraints:  The number of nodes in the list is in the range [1, 10^4] 0 <= Node.val <= 9 The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |class Solution { public:     ListNode* doubleIt(ListNode* head) {         ListNode* current = head;         int carry = 0;         while (current != nullptr) {             int sum = current->val * 2 + carry;             current->val = sum % 10;             carry = sum / 10;             if (current->next == nullptr && carry > 0) {                 current->next = new ListNode(carry);                 break;             }             current = current->next;         }         return head;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |class Solution { public:     ListNode* doubleIt(ListNode* head) {         if (head->val > 4)             head = new ListNode(0, head);         for(ListNode* node = head; node; node = node->next) {             node->val = (node->val * 2) % 10;             if (node->next && node->next->val > 4)                 node->val++;         }         return head;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
|13 |5             |Java    |hard      |Bing AI Chat   |Chatbot          |You are given an array nums of n positive integers and an integer k.  Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:  Choose any non-empty subarray nums[l, ..., r] that you haven't chosen previously. Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index. Multiply your score by x. Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.  The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.  Return the maximum possible score after applying at most k operations.  Since the answer may be large, return it modulo 10^9 + 7.  Example 1:  Input: nums = [8,3,9,3,8], k = 2 Output: 81 Explanation: To get a score of 81, we can apply the following operations: - Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81. It can be proven that 81 is the highest score one can obtain.  Example 2:  Input: nums = [19,12,14,6,10,18], k = 3 Output: 4788 Explanation: To get a score of 4788, we can apply the following operations:  - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19. - Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788. It can be proven that 4788 is the highest score one can obtain.   Constraints:  1 <= nums.length == n <= 10^5 1 <= nums[i] <= 10^5 1 <= k <= min(n * (n + 1) / 2, 10^9) |Solve the following problem with java code. Class name: Solution, Method name: maximumScore(List<Integer> nums, int k).  You are given an array nums of n positive integers and an integer k.  Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:  Choose any non-empty subarray nums[l, ..., r] that you haven't chosen previously. Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index. Multiply your score by x. Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.  The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.  Return the maximum possible score after applying at most k operations.  Since the answer may be large, return it modulo 10^9 + 7.  Example 1:  Input: nums = [8,3,9,3,8], k = 2 Output: 81 Explanation: To get a score of 81, we can apply the following operations: - Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81. It can be proven that 81 is the highest score one can obtain.  Example 2:  Input: nums = [19,12,14,6,10,18], k = 3 Output: 4788 Explanation: To get a score of 4788, we can apply the following operations:  - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19. - Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788. It can be proven that 4788 is the highest score one can obtain.   Constraints:  1 <= nums.length == n <= 10^5 1 <= nums[i] <= 10^5 1 <= k <= min(n * (n + 1) / 2, 10^9).                   |public class Solution {     private static final int MOD = 1_000_000_007;     private List<Integer> nums;     private int n;     private List<Integer>[] factors;      public int maximumScore(List<Integer> nums, int k) {         this.nums = nums;         this.n = nums.size();         this.factors = new ArrayList[n];         for (int i = 0; i < n; i++) {             factors[i] = primeFactors(nums.get(i));         }          PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> b[2] - a[2]);         pq.offer(new int[]{0, n - 1, maxPrimeScore(0, n - 1)});          long res = 1;         boolean[] chosen = new boolean[n];         while (k-- > 0) {             int[] cur = pq.poll();             int l = cur[0], r = cur[1], maxScore = cur[2];             res = (res * maxScore) % MOD;              int maxIdx = maxPrimeScoreIndex(l, r);             chosen[maxIdx] = true;              if (maxIdx - 1 >= l && !chosen[maxIdx - 1]) {                 pq.offer(new int[]{l, maxIdx - 1, maxPrimeScore(l, maxIdx - 1)});             }             if (maxIdx + 1 <= r && !chosen[maxIdx + 1]) {                 pq.offer(new int[]{maxIdx + 1, r, maxPrimeScore(maxIdx + 1, r)});             }         }          return (int) res;     }      private List<Integer> primeFactors(int num) {         List<Integer> factors = new ArrayList<>();         for (int i = 2; i * i <= num; i++) {             if (num % i == 0) {                 factors.add(i);                 while (num % i == 0) {                     num /= i;                 }             }         }         if (num > 1) {             factors.add(num);         }         return factors;     }      private int maxPrimeScore(int l, int r) {         int maxScore = 0;         for (int i = l; i <= r; i++) {             maxScore = Math.max(maxScore, factors[i].size());         }         return maxScore;     }      private int maxPrimeScoreIndex(int l, int r) {         int maxScore = 0, idx = -1;         for (int i = l; i <= r; i++) {             if (factors[i].size() >= maxScore) {                 maxScore = factors[i].size();                 idx = i;             }         }         return idx;     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |class Solution {     static final int MOD = 1000000007;      public int maximumScore(List<Integer> nums, int k) {         int n = nums.size();          int upper = Collections.max(nums) + 1;          boolean[] prime = new boolean[upper];         int[] primeScore = new int[upper];         Arrays.fill(prime, true);         prime[0] = prime[1] = false;         for (int i = 2; i < upper; i++) {             if (prime[i]) {                 for (int j = i; j < upper; j += i) {                     primeScore[j]++;                     prime[j] = false;                 }             }         }          int[] nextGreaterElement = new int[n];         Arrays.fill(nextGreaterElement, n);         Stack<Integer> s = new Stack<>();         for (int i = n - 1; i >= 0; i--) {             while (!s.empty() && primeScore[nums.get(i)] >= primeScore[nums.get(s.peek())]) {                 s.pop();             }             nextGreaterElement[i] = s.empty() ? n : s.peek();             s.push(i);         }          int[] prevGreaterOrEqualElement = new int[n];         Arrays.fill(prevGreaterOrEqualElement, -1);         s = new Stack<>();         for (int i = 0; i < n; i++) {             while (!s.empty() && primeScore[nums.get(i)] > primeScore[nums.get(s.peek())]) {                 s.pop();             }             prevGreaterOrEqualElement[i] = s.empty() ? -1 : s.peek();             s.push(i);         }          int res = 1;         int[][] tuples = new int[n][2];         for (int i = 0; i < n; i++) {             tuples[i][0] = nums.get(i);             tuples[i][1] = i;         }         Arrays.sort(tuples, new Comparator<int[]>() {             public int compare(int[] a, int[] b) {                 return b[0] - a[0];             }         });         for (int i = 0; i < n; i++) {             int num = tuples[i][0];             int idx = tuples[i][1];             int operations = Math.min((idx - prevGreaterOrEqualElement[idx]) * (nextGreaterElement[idx] - idx), k);             res = (int)((1L * res * pow(num, operations)) % MOD);             k -= operations;             if (k == 0) {                 return res;             }         }          return res;     }      public int pow(int x, int n) {         int res = 1;         while (n > 0) {             if (n % 2 == 1) {                 res = (int)((1L * res * x) % MOD);             }             x = (int)((1L * x * x) % MOD);             n /= 2;         }         return res;     } }|
|14 |5             |Python  |hard      |Bing AI Chat   |Chatbot          |You are given an array nums of n positive integers and an integer k.  Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:  Choose any non-empty subarray nums[l, ..., r] that you haven't chosen previously. Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index. Multiply your score by x. Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.  The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.  Return the maximum possible score after applying at most k operations.  Since the answer may be large, return it modulo 10^9 + 7.  Example 1:  Input: nums = [8,3,9,3,8], k = 2 Output: 81 Explanation: To get a score of 81, we can apply the following operations: - Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81. It can be proven that 81 is the highest score one can obtain.  Example 2:  Input: nums = [19,12,14,6,10,18], k = 3 Output: 4788 Explanation: To get a score of 4788, we can apply the following operations:  - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19. - Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788. It can be proven that 4788 is the highest score one can obtain.   Constraints:  1 <= nums.length == n <= 10^5 1 <= nums[i] <= 10^5 1 <= k <= min(n * (n + 1) / 2, 10^9) |Solve the following problem with python3 code. Class name: Solution, Method name: def maximumScore(self, nums: List[int], k: int) -> int:.  You are given an array nums of n positive integers and an integer k.  Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:  Choose any non-empty subarray nums[l, ..., r] that you haven't chosen previously. Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index. Multiply your score by x. Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.  The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.  Return the maximum possible score after applying at most k operations.  Since the answer may be large, return it modulo 10^9 + 7.  Example 1:  Input: nums = [8,3,9,3,8], k = 2 Output: 81 Explanation: To get a score of 81, we can apply the following operations: - Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81. It can be proven that 81 is the highest score one can obtain.  Example 2:  Input: nums = [19,12,14,6,10,18], k = 3 Output: 4788 Explanation: To get a score of 4788, we can apply the following operations:  - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19. - Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788. It can be proven that 4788 is the highest score one can obtain.   Constraints:  1 <= nums.length == n <= 10^5 1 <= nums[i] <= 10^5 1 <= k <= min(n * (n + 1) / 2, 10^9).|class Solution:     def maximumScore(self, nums: List[int], k: int) -> int:         n = len(nums)         MOD = 10**9 + 7          # Precompute the prime score of all numbers in nums         prime_score = [0] * n         for i, num in enumerate(nums):             for j in range(2, int(sqrt(num)) + 1):                 if num % j == 0:                     prime_score[i] += 1                     while num % j == 0:                         num //= j             if num > 1:                 prime_score[i] += 1          # Compute the maximum score using dynamic programming         dp = [1]         for _ in range(k):             new_dp = [0] * (n + 1)             for l in range(n):                 for r in range(l, n):                     max_prime_score = max(prime_score[l:r+1])                     max_index = prime_score[l:r+1].index(max_prime_score) + l                     new_dp[r+1] = max(new_dp[r+1], dp[l] * nums[max_index] % MOD)             dp = new_dp          return max(dp) % MOD                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |class Solution:      MOD = 1000000007      def maximumScore(self, nums: List[int], k: int) -> int:         n = len(nums)          upper = max(nums) + 1          prime = [True]*upper         prime[0] = prime[1] = False         primeScore = [0]*upper         for i in range(2, upper):             if prime[i]:                 for j in range(i, upper, i):                     primeScore[j] += 1                     prime[j] = False          nextGreaterElement = [n]*n         s = []         for i in range(n - 1, -1, -1):             while s and primeScore[nums[i]] >= primeScore[nums[s[-1]]]:                 s.pop()             nextGreaterElement[i] = s[-1] if s else n             s.append(i)          prevGreaterOrEqualElement = [-1]*n         s = []         for i in range(n):             while s and primeScore[nums[i]] > primeScore[nums[s[-1]]]:                 s.pop()             prevGreaterOrEqualElement[i] = s[-1] if s else -1             s.append(i)          res = 1         tuples = [[nums[i], i] for i in range(n)]         tuples.sort(reverse=True)         for num, idx in tuples:             operations = min((idx - prevGreaterOrEqualElement[idx]) * (nextGreaterElement[idx] - idx), k)             res = (res * self.pow(num, operations)) % self.MOD             k -= operations             if k == 0:                 return res          return res      def pow(self, x: int, n: int) -> int:         res = 1         while n > 0:             if n % 2 == 1:                 res = (res * x) % self.MOD             x = (x * x) % self.MOD             n //= 2         return res                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
|15 |5             |C++     |hard      |Bing AI Chat   |Chatbot          |You are given an array nums of n positive integers and an integer k.  Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:  Choose any non-empty subarray nums[l, ..., r] that you haven't chosen previously. Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index. Multiply your score by x. Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.  The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.  Return the maximum possible score after applying at most k operations.  Since the answer may be large, return it modulo 10^9 + 7.  Example 1:  Input: nums = [8,3,9,3,8], k = 2 Output: 81 Explanation: To get a score of 81, we can apply the following operations: - Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81. It can be proven that 81 is the highest score one can obtain.  Example 2:  Input: nums = [19,12,14,6,10,18], k = 3 Output: 4788 Explanation: To get a score of 4788, we can apply the following operations:  - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19. - Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788. It can be proven that 4788 is the highest score one can obtain.   Constraints:  1 <= nums.length == n <= 10^5 1 <= nums[i] <= 10^5 1 <= k <= min(n * (n + 1) / 2, 10^9) |Solve the following problem with C++ code. Class name: Solution, Method name: int maximumScore(vector<int>& nums, int k).  You are given an array nums of n positive integers and an integer k.  Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:  Choose any non-empty subarray nums[l, ..., r] that you haven't chosen previously. Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index. Multiply your score by x. Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.  The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.  Return the maximum possible score after applying at most k operations.  Since the answer may be large, return it modulo 10^9 + 7.  Example 1:  Input: nums = [8,3,9,3,8], k = 2 Output: 81 Explanation: To get a score of 81, we can apply the following operations: - Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81. It can be proven that 81 is the highest score one can obtain.  Example 2:  Input: nums = [19,12,14,6,10,18], k = 3 Output: 4788 Explanation: To get a score of 4788, we can apply the following operations:  - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19. - Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788. It can be proven that 4788 is the highest score one can obtain.   Constraints:  1 <= nums.length == n <= 10^5 1 <= nums[i] <= 10^5 1 <= k <= min(n * (n + 1) / 2, 10^9).                 |class Solution { public:     int maximumScore(std::vector<int>& nums, int k) {         const int MOD = 1e9 + 7;         int n = nums.size();         std::vector<int> primeScore(n);         for (int i = 0; i < n; i++) {             primeScore[i] = getPrimeScore(nums[i]);         }         std::vector<std::vector<long long>> dp(n, std::vector<long long>(k + 1));         for (int i = 0; i < n; i++) {             dp[i][0] = nums[i];             for (int j = 1; j <= k; j++) {                 for (int l = 0; l < i; l++) {                     if (primeScore[l] >= primeScore[i]) {                         dp[i][j] = std::max(dp[i][j], dp[l][j - 1] * nums[i] % MOD);                     }                 }             }         }         long long maxScore = 0;         for (int i = 0; i < n; i++) {             maxScore = std::max(maxScore, dp[i][k]);         }         return maxScore % MOD;     }  private:     int getPrimeScore(int num) {         int score = 0;         for (int i = 2; i <= std::sqrt(num); i++) {             if (num % i == 0) {                 score++;                 while (num % i == 0) {                     num /= i;                 }             }         }         if (num > 1) {             score++;         }         return score;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |class Solution { public:     const int MOD = 1000000007;      int maximumScore(vector<int>& nums, int k) {         int n = nums.size();          int upper = *max_element(nums.begin(), nums.end()) + 1;          vector<bool> prime(upper, true);         prime[0] = prime[1] = false;         vector<int> primeScore(upper, 0);         for (int i = 2; i < upper; i++) {             if (prime[i]) {                 for (int j = i; j < upper; j += i) {                     primeScore[j]++;                     prime[j] = false;                 }             }         }          vector<int> nextGreaterElement(n, n);         stack<int> s;         for (int i = n - 1; i >= 0; i--) {             while (!s.empty() && primeScore[nums[i]] >= primeScore[nums[s.top()]]) {                 s.pop();             }             nextGreaterElement[i] = s.empty() ? n : s.top();             s.push(i);         }          vector<int> prevGreaterOrEqualElement(n, -1);         s = stack<int>();         for (int i = 0; i < n; i++) {             while (!s.empty() && primeScore[nums[i]] > primeScore[nums[s.top()]]) {                 s.pop();             }             prevGreaterOrEqualElement[i] = s.empty() ? -1 : s.top();             s.push(i);         }          int res = 1;         vector<pair<int, int>> tuples(n);         for (int i = 0; i < n; i++) {             tuples[i].first = nums[i];             tuples[i].second = i;         }         sort(tuples.rbegin(), tuples.rend());         for (const auto& [num, i] : tuples) {             int operations = min((i - prevGreaterOrEqualElement[i]) * (nextGreaterElement[i] - i), k);             res = (int)((1L * res * pow(num, operations)) % MOD);             k -= operations;             if (k == 0) {                 return res;             }         }          return res;     }      int pow(int x, int n) {         int res = 1;         while (n > 0) {             if (n % 2 == 1) {                 res = (int)((1L * res * x) % MOD);             }             x = (int)((1L * x * x) % MOD);             n /= 2;         }         return res;     } };                                                                                                                                                                                                                                                                                                                                                                               |
|16 |6             |Java    |hard      |Bing AI Chat   |Chatbot          |You are given a 0-indexed 2D integer array items of length n and an integer k.  items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.  Let's define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.  Your task is to find the maximum elegance from all subsequences of size k in items.  Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.  Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order.  Example 1:  Input: items = [[3,2],[5,1],[10,1]], k = 2 Output: 17 Explanation: In this example, we have to select a subsequence of size 2. We can select items[0] = [3,2] and items[2] = [10,1]. The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1]. Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance.   Example 2:  Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3 Output: 19 Explanation: In this example, we have to select a subsequence of size 3.  We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3].  The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3].  Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.  Example 3:  Input: items = [[1,1],[2,1],[3,1]], k = 3 Output: 7 Explanation: In this example, we have to select a subsequence of size 3.  We should select all the items.  The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1].  Hence, the maximum elegance is 6 + 1^2 = 7.     Constraints:  1 <= items.length == n <= 10^5 items[i].length == 2 items[i][0] == profit_i items[i][1] == category_i 1 <= profit_i <= 10^9 1 <= category_i <= n  1 <= k <= n                                             |Solve the following problem with java code. Class name: Solution, Method name: findMaximumElegance(int [][] items, int k).  You are given a 0-indexed 2D integer array items of length n and an integer k.  items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.  Let's define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.  Your task is to find the maximum elegance from all subsequences of size k in items.  Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.  Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order.  Example 1:  Input: items = [[3,2],[5,1],[10,1]], k = 2 Output: 17 Explanation: In this example, we have to select a subsequence of size 2. We can select items[0] = [3,2] and items[2] = [10,1]. The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1]. Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance.   Example 2:  Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3 Output: 19 Explanation: In this example, we have to select a subsequence of size 3.  We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3].  The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3].  Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.  Example 3:  Input: items = [[1,1],[2,1],[3,1]], k = 3 Output: 7 Explanation: In this example, we have to select a subsequence of size 3.  We should select all the items.  The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1].  Hence, the maximum elegance is 6 + 1^2 = 7.     Constraints:  1 <= items.length == n <= 10^5 items[i].length == 2 items[i][0] == profit_i items[i][1] == category_i 1 <= profit_i <= 10^9 1 <= category_i <= n  1 <= k <= n                                                             |class Solution {     private static final int MOD = 1_000_000_007;      public int findMaximumElegance(int[][] items, int k) {         int n = items.length;         List<int[]>[] categoryItems = new List[n + 1];         for (int i = 0; i <= n; i++) {             categoryItems[i] = new ArrayList<>();         }         for (int[] item : items) {             categoryItems[item[1]].add(item);         }          PriorityQueue<Integer> pq = new PriorityQueue<>();         long[] dp = new long[k + 1];         dp[0] = 0;         int totalItems = 0;         for (List<int[]> itemList : categoryItems) {             if (itemList.isEmpty()) continue;              Collections.sort(itemList, Comparator.comparingInt(a -> -a[0]));             int categoryProfit = 0;             for (int[] item : itemList) {                 categoryProfit += item[0];                 pq.offer(item[0]);                 if (pq.size() > totalItems + 1) {                     categoryProfit -= pq.poll();                 }             }              for (int j = Math.min(k, totalItems + itemList.size()); j >= 0; j--) {                 for (int l = Math.max(0, j - totalItems); l <= Math.min(j, itemList.size()); l++) {                     dp[j] = Math.max(dp[j], (j - l > 0 ? dp[j - l - 1] : 0) + categoryProfit);                 }             }              totalItems += itemList.size();         }          long res = 0;         for (int i = 1; i <= k; i++) {             res = Math.max(res, dp[i] + (long)i * i);         }          return (int)(res % MOD);     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |class Solution {     public long findMaximumElegance(int[][] A, int k) {         Arrays.sort(A, (a, b) -> b[0] - a[0]);         long res = 0, cur = 0;         List<Integer> dup = new ArrayList<>();         Set<Integer> seen = new HashSet<>();         for (int i = 0; i < A.length; ++i) {             if (i < k) {                 if (seen.contains(A[i][1])) {                     dup.add(A[i][0]);                 }                 cur += A[i][0];             } else if (!seen.contains(A[i][1])) {                 if (dup.isEmpty()) break;                 cur += A[i][0] - dup.remove(dup.size() - 1);             }             seen.add(A[i][1]);             res = Math.max(res, cur + 1L * seen.size() * seen.size());         }         return res;     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|17 |6             |Python  |hard      |Bing AI Chat   |Chatbot          |You are given a 0-indexed 2D integer array items of length n and an integer k.  items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.  Let's define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.  Your task is to find the maximum elegance from all subsequences of size k in items.  Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.  Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order.  Example 1:  Input: items = [[3,2],[5,1],[10,1]], k = 2 Output: 17 Explanation: In this example, we have to select a subsequence of size 2. We can select items[0] = [3,2] and items[2] = [10,1]. The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1]. Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance.   Example 2:  Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3 Output: 19 Explanation: In this example, we have to select a subsequence of size 3.  We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3].  The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3].  Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.  Example 3:  Input: items = [[1,1],[2,1],[3,1]], k = 3 Output: 7 Explanation: In this example, we have to select a subsequence of size 3.  We should select all the items.  The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1].  Hence, the maximum elegance is 6 + 1^2 = 7.     Constraints:  1 <= items.length == n <= 10^5 items[i].length == 2 items[i][0] == profit_i items[i][1] == category_i 1 <= profit_i <= 10^9 1 <= category_i <= n  1 <= k <= n                                             |Solve the following problem with python3 code. Class name: Solution, Method name: def findMaximumElegance(self, items: List[List[int]], k: int) -> int:.  You are given a 0-indexed 2D integer array items of length n and an integer k.  items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.  Let's define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.  Your task is to find the maximum elegance from all subsequences of size k in items.  Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.  Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order.  Example 1:  Input: items = [[3,2],[5,1],[10,1]], k = 2 Output: 17 Explanation: In this example, we have to select a subsequence of size 2. We can select items[0] = [3,2] and items[2] = [10,1]. The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1]. Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance.   Example 2:  Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3 Output: 19 Explanation: In this example, we have to select a subsequence of size 3.  We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3].  The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3].  Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.  Example 3:  Input: items = [[1,1],[2,1],[3,1]], k = 3 Output: 7 Explanation: In this example, we have to select a subsequence of size 3.  We should select all the items.  The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1].  Hence, the maximum elegance is 6 + 1^2 = 7.     Constraints:  1 <= items.length == n <= 10^5 items[i].length == 2 items[i][0] == profit_i items[i][1] == category_i 1 <= profit_i <= 10^9 1 <= category_i <= n  1 <= k <= n                               |class Solution:     def findMaximumElegance(self, items: List[List[int]], k: int) -> int:         n = len(items)         items.sort(key=lambda x: (-x[0], x[1]))         dp = [[0, 0] for _ in range(n + 1)]         for i in range(1, n + 1):             dp[i][0] = max(dp[i - 1][0], dp[i - 1][1])             dp[i][1] = max(dp[i - 1][0] + items[i - 1][0], dp[i - 1][1] + items[i - 1][0])         return max(dp[k]) + len(set([item[1] for item in items[:k]])) ** 2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |class Solution:     def findMaximumElegance(self, items: List[List[int]], k: int) -> int:         items = sorted(items, key=lambda v: -v[0])         res = cur = 0         A = []         seen = set()         for i, (p, c) in enumerate(items):             if i < k:                 if c in seen:                     A.append(p)                 cur += p             elif c not in seen:                 if not A: break                 cur += p - A.pop()             seen.add(c)             res = max(res, cur + len(seen) * len(seen))         return res                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
|18 |6             |C++     |hard      |Bing AI Chat   |Chatbot          |You are given a 0-indexed 2D integer array items of length n and an integer k.  items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.  Let's define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.  Your task is to find the maximum elegance from all subsequences of size k in items.  Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.  Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order.  Example 1:  Input: items = [[3,2],[5,1],[10,1]], k = 2 Output: 17 Explanation: In this example, we have to select a subsequence of size 2. We can select items[0] = [3,2] and items[2] = [10,1]. The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1]. Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance.   Example 2:  Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3 Output: 19 Explanation: In this example, we have to select a subsequence of size 3.  We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3].  The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3].  Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.  Example 3:  Input: items = [[1,1],[2,1],[3,1]], k = 3 Output: 7 Explanation: In this example, we have to select a subsequence of size 3.  We should select all the items.  The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1].  Hence, the maximum elegance is 6 + 1^2 = 7.     Constraints:  1 <= items.length == n <= 10^5 items[i].length == 2 items[i][0] == profit_i items[i][1] == category_i 1 <= profit_i <= 10^9 1 <= category_i <= n  1 <= k <= n                                             |Solve the following problem with C++ code. Class name: Solution, Method name: long long findMaximumElegance(vector<vector<int>>& items, int k).  You are given a 0-indexed 2D integer array items of length n and an integer k.  items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.  Let's define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.  Your task is to find the maximum elegance from all subsequences of size k in items.  Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.  Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order.  Example 1:  Input: items = [[3,2],[5,1],[10,1]], k = 2 Output: 17 Explanation: In this example, we have to select a subsequence of size 2. We can select items[0] = [3,2] and items[2] = [10,1]. The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1]. Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance.   Example 2:  Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3 Output: 19 Explanation: In this example, we have to select a subsequence of size 3.  We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3].  The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3].  Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.  Example 3:  Input: items = [[1,1],[2,1],[3,1]], k = 3 Output: 7 Explanation: In this example, we have to select a subsequence of size 3.  We should select all the items.  The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1].  Hence, the maximum elegance is 6 + 1^2 = 7.     Constraints:  1 <= items.length == n <= 10^5 items[i].length == 2 items[i][0] == profit_i items[i][1] == category_i 1 <= profit_i <= 10^9 1 <= category_i <= n  1 <= k <= n                                        |class Solution { public:     long long findMaximumElegance(std::vector<std::vector<int>>& items, int k) {         const int MOD = 1e9 + 7;         int n = items.size();         std::vector<std::unordered_map<int, long long>> dp(n);         for (int i = 0; i < n; i++) {             dp[i][1 << items[i][1]] = items[i][0];             for (int j = 0; j < i; j++) {                 for (auto& [mask, val] : dp[j]) {                     int newMask = mask &#124; (1 << items[i][1]);                     dp[i][newMask] = std::max(dp[i][newMask], val + items[i][0]);                 }             }         }         long long maxElegance = 0;         for (int i = 0; i < n; i++) {             for (auto& [mask, val] : dp[i]) {                 int cnt = __builtin_popcount(mask);                 if (cnt >= k) {                     maxElegance = std::max(maxElegance, val + cnt * cnt);                 }             }         }         return maxElegance % MOD;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |class Solution { public:     long long findMaximumElegance(vector<vector<int>>& A, int k) {         sort(A.begin(), A.end(), [](const vector<int>& a, const vector<int>& b) {             return a[0] > b[0];         });         long long res = 0, cur = 0;         vector<int> dup;         unordered_set<int> seen;         for (int i = 0; i < A.size(); ++i) {             if (i < k) {                 if (seen.count(A[i][1])) {                     dup.push_back(A[i][0]);                 }                 cur += A[i][0];             } else if (seen.find(A[i][1]) == seen.end()) {                 if (dup.empty()) break;                 cur += A[i][0] - dup.back();                 dup.pop_back();             }             seen.insert(A[i][1]);             res = fmax(res, cur + 1L * seen.size() * seen.size());         }         return res;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
|19 |1             |Java    |easy      |ChatGPT        |Chatbot          |You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.  Return the maximum sum or -1 if no such pair exists.  Example 1:  Input: nums = [51,71,17,24,42] Output: 88 Explanation:  For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88.  For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66. It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.  Example 2:  Input: nums = [1,2,3,4] Output: -1 Explanation: No pair exists in nums with equal maximum digits.  Constraints:  2 <= nums.length <= 100 1 <= nums[i] <= 10^4                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |solve the following problem with java code. Class name: Solution, Method name: maxSum(int[] nums).  You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.  Return the maximum sum or -1 if no such pair exists.  Example 1:  Input: nums = [51,71,17,24,42] Output: 88 Explanation:  For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88.  For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66. It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.  Example 2:  Input: nums = [1,2,3,4] Output: -1 Explanation: No pair exists in nums with equal maximum digits.  Constraints:  2 <= nums.length <= 100 1 <= nums[i] <= 10^4                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |public class Solution {     public int maxSum(int[] nums) {         // Create an array of size 10 to keep track of the maximum values for each digit (0-9)         int[] maxDigits = new int[10];                  // Iterate through the array and update the maxDigits array with the maximum values for each digit         for (int num : nums) {             int maxDigit = getMaxDigit(num);             maxDigits[maxDigit] = Math.max(maxDigits[maxDigit], num);         }                  int maxSum = -1;                  // Iterate through the maxDigits array to find pairs with equal maximum digits         for (int i = 0; i <= 9; i++) {             for (int j = i; j <= 9; j++) {                 if (maxDigits[i] != 0 && maxDigits[j] != 0 && i == j) {                     maxSum = Math.max(maxSum, maxDigits[i] + maxDigits[j]);                 }             }         }                  return maxSum;     }          // Helper method to get the maximum digit from a number     private int getMaxDigit(int num) {         int maxDigit = 0;         while (num > 0) {             maxDigit = Math.max(maxDigit, num % 10);             num /= 10;         }         return maxDigit;     }      }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |class Solution {     public int maxSum(int[] nums) {     int ans = -1;     Map<Integer,List<Integer>> ump = new HashMap<>();     for(int i = 0; i < nums.length; ++i){         int t = nums[i], maxDigit = 0;         while(t != 0){ //evaluate max digit in the number             maxDigit = Math.max(t%10, maxDigit);             t = t/10;         }         if(!ump.containsKey(maxDigit)) ump.put(maxDigit, new ArrayList<>());         ump.get(maxDigit).add(nums[i]); // add the number to the map      }     for(Map.Entry<Integer, List<Integer>> entry: ump.entrySet()){         entry.getValue().sort(Comparator.reverseOrder()); //to find max two number in each max digit          if(entry.getValue().size() >= 2) ans = Math.max(ans, entry.getValue().get(0) + entry.getValue().get(1)); //sum max two number and take max     }     return ans;     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
|20 |1             |Python  |easy      |ChatGPT        |Chatbot          |You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.  Return the maximum sum or -1 if no such pair exists.  Example 1:  Input: nums = [51,71,17,24,42] Output: 88 Explanation:  For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88.  For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66. It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.  Example 2:  Input: nums = [1,2,3,4] Output: -1 Explanation: No pair exists in nums with equal maximum digits.  Constraints:  2 <= nums.length <= 100 1 <= nums[i] <= 10^4                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |solve the following problem with python3 code. Class name: Solution, Method name: def maxSum(self, nums: List[int]) -> int:.  You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.  Return the maximum sum or -1 if no such pair exists.  Example 1:  Input: nums = [51,71,17,24,42] Output: 88 Explanation:  For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88.  For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66. It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.  Example 2:  Input: nums = [1,2,3,4] Output: -1 Explanation: No pair exists in nums with equal maximum digits.  Constraints:  2 <= nums.length <= 100 1 <= nums[i] <= 10^4                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |class Solution:     def maxSum(self, nums: List[int]) -> int:         max_digit_sum = {}  # Dictionary to store the maximum sum for each maximum digit                  for num in nums:             max_digit = max(str(num))  # Find the maximum digit in the current number             if max_digit in max_digit_sum:                 max_digit_sum[max_digit] = max(max_digit_sum[max_digit], num)             else:                 max_digit_sum[max_digit] = num                  max_sum = -1  # Initialize the maximum sum to -1                  # Iterate through the dictionary to find the maximum sum         for digit, num in max_digit_sum.items():             if max_digit_sum[digit] != num:                 max_sum = max(max_sum, num + max_digit_sum[digit])                  return max_sum                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |class Solution:     def maxSum(self, nums: List[int]) -> int:         max_by_digit = defaultdict(int)         max_sum = -1          for num in nums:             digit = max(str(num))              if digit in max_by_digit:                 max_sum = max(max_sum, max_by_digit[digit] + num)              max_by_digit[digit] = max(max_by_digit[digit], num)          return max_sum                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
|21 |1             |C++     |easy      |ChatGPT        |Chatbot          |You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.  Return the maximum sum or -1 if no such pair exists.  Example 1:  Input: nums = [51,71,17,24,42] Output: 88 Explanation:  For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88.  For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66. It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.  Example 2:  Input: nums = [1,2,3,4] Output: -1 Explanation: No pair exists in nums with equal maximum digits.  Constraints:  2 <= nums.length <= 100 1 <= nums[i] <= 10^4                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |solve the following problem with C++ code. Class name: Solution, Method name: maxSum(std::vector<int>& nums).  You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.  Return the maximum sum or -1 if no such pair exists.  Example 1:  Input: nums = [51,71,17,24,42] Output: 88 Explanation:  For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88.  For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66. It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.  Example 2:  Input: nums = [1,2,3,4] Output: -1 Explanation: No pair exists in nums with equal maximum digits.  Constraints:  2 <= nums.length <= 100 1 <= nums[i] <= 10^4                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |class Solution { public:     int maxSum(std::vector<int>& nums) {         std::vector<int> maxDigit(10, -1); // To store the maximum number for each digit (0-9)         int maxSum = -1; // Initialize maxSum to -1 as the minimum possible answer                  for (int num : nums) {             int maxDig = 0; // To store the maximum digit in the current number             int temp = num; // Temporary variable to avoid modifying num                          while (temp > 0) {                 int digit = temp % 10;                 maxDig = std::max(maxDig, digit); // Update maxDig if a larger digit is found                 temp /= 10;             }                          if (maxDigit[maxDig] != -1) {                 // If we have seen a number with the same maximum digit before, update maxSum                 maxSum = std::max(maxSum, maxDigit[maxDig] + num);             }                          // Update maxDigit[maxDig] with the maximum of the current number and the previous maximum             maxDigit[maxDig] = std::max(maxDigit[maxDig], num);         }                  return maxSum;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |class Solution {     public:         int maxSum(vector<int>& nums) {         int res = -1, max_num[10] = {};         for (auto num : nums) {             int max_d = 0;             for (int v = num; v; v /= 10)                 max_d = max(max_d, v % 10);             if (max_num[max_d])                 res = max(res, max_num[max_d] + num);             max_num[max_d] = max(max_num[max_d], num);         }         return res;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|22 |2             |Java    |easy      |ChatGPT        |Chatbot          |Your laptop keyboard is faulty, and whenever you type a character 'i' on it, it reverses the string that you have written. Typing other characters works as expected.  You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.  Return the final string that will be present on your laptop screen.  Example 1:  Input: s = "string" Output: "rtsng" Explanation:  After typing first character, the text on the screen is "s". After the second character, the text is "st".  After the third character, the text is "str". Since the fourth character is an 'i', the text gets reversed and becomes "rts". After the fifth character, the text is "rtsn".  After the sixth character, the text is "rtsng".  Therefore, we return "rtsng".  Example 2:  Input: s = "poiinter" Output: "ponter" Explanation:  After the first character, the text on the screen is "p". After the second character, the text is "po".  Since the third character you type is an 'i', the text gets reversed and becomes "op".  Since the fourth character you type is an 'i', the text gets reversed and becomes "po". After the fifth character, the text is "pon". After the sixth character, the text is "pont".  After the seventh character, the text is "ponte".  After the eighth character, the text is "ponter".  Therefore, we return "ponter".   Constraints:  1 <= s.length <= 100 s consists of lowercase English letters. s[0] != 'i'                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |Solve the following problem with java code. Class name: Solution, Method name: finalString(String s).  Your laptop keyboard is faulty, and whenever you type a character 'i' on it, it reverses the string that you have written. Typing other characters works as expected.  You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.  Return the final string that will be present on your laptop screen.  Example 1:  Input: s = "string" Output: "rtsng" Explanation:  After typing first character, the text on the screen is "s". After the second character, the text is "st".  After the third character, the text is "str". Since the fourth character is an 'i', the text gets reversed and becomes "rts". After the fifth character, the text is "rtsn".  After the sixth character, the text is "rtsng".  Therefore, we return "rtsng".  Example 2:  Input: s = "poiinter" Output: "ponter" Explanation:  After the first character, the text on the screen is "p". After the second character, the text is "po".  Since the third character you type is an 'i', the text gets reversed and becomes "op".  Since the fourth character you type is an 'i', the text gets reversed and becomes "po". After the fifth character, the text is "pon". After the sixth character, the text is "pont".  After the seventh character, the text is "ponte".  After the eighth character, the text is "ponter".  Therefore, we return "ponter".   Constraints:  1 <= s.length <= 100 s consists of lowercase English letters. s[0] != 'i'                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |public class Solution {     public String finalString(String s) {         StringBuilder result = new StringBuilder();         StringBuilder reverseBuffer = new StringBuilder();                  boolean reverse = false;                  for (char c : s.toCharArray()) {             if (c == 'i') {                 reverse = !reverse;             } else {                 if (reverse) {                     reverseBuffer.insert(0, c);                 } else {                     result.append(c);                 }             }         }                  result.append(reverseBuffer);                  return result.toString();     }      }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |class Solution {     public String finalString(String s) {         StringBuilder nm=new StringBuilder();         for(char c:s.toCharArray())         {             if(c=='i')             {                 nm.reverse();             }             else             {                 nm.append(c);             }         }         return nm.toString();     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|23 |2             |Python  |easy      |ChatGPT        |Chatbot          |Your laptop keyboard is faulty, and whenever you type a character 'i' on it, it reverses the string that you have written. Typing other characters works as expected.  You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.  Return the final string that will be present on your laptop screen.  Example 1:  Input: s = "string" Output: "rtsng" Explanation:  After typing first character, the text on the screen is "s". After the second character, the text is "st".  After the third character, the text is "str". Since the fourth character is an 'i', the text gets reversed and becomes "rts". After the fifth character, the text is "rtsn".  After the sixth character, the text is "rtsng".  Therefore, we return "rtsng".  Example 2:  Input: s = "poiinter" Output: "ponter" Explanation:  After the first character, the text on the screen is "p". After the second character, the text is "po".  Since the third character you type is an 'i', the text gets reversed and becomes "op".  Since the fourth character you type is an 'i', the text gets reversed and becomes "po". After the fifth character, the text is "pon". After the sixth character, the text is "pont".  After the seventh character, the text is "ponte".  After the eighth character, the text is "ponter".  Therefore, we return "ponter".   Constraints:  1 <= s.length <= 100 s consists of lowercase English letters. s[0] != 'i'                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |Solve the following problem with python3 code. Class name: Solution, Method name: def finalString(self, s: str) -> str:.  Your laptop keyboard is faulty, and whenever you type a character 'i' on it, it reverses the string that you have written. Typing other characters works as expected.  You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.  Return the final string that will be present on your laptop screen.  Example 1:  Input: s = "string" Output: "rtsng" Explanation:  After typing first character, the text on the screen is "s". After the second character, the text is "st".  After the third character, the text is "str". Since the fourth character is an 'i', the text gets reversed and becomes "rts". After the fifth character, the text is "rtsn".  After the sixth character, the text is "rtsng".  Therefore, we return "rtsng".  Example 2:  Input: s = "poiinter" Output: "ponter" Explanation:  After the first character, the text on the screen is "p". After the second character, the text is "po".  Since the third character you type is an 'i', the text gets reversed and becomes "op".  Since the fourth character you type is an 'i', the text gets reversed and becomes "po". After the fifth character, the text is "pon". After the sixth character, the text is "pont".  After the seventh character, the text is "ponte".  After the eighth character, the text is "ponter".  Therefore, we return "ponter".   Constraints:  1 <= s.length <= 100 s consists of lowercase English letters. s[0] != 'i'                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |class Solution:     def finalString(self, s: str) -> str:         stack = []  # Use a stack to simulate typing process                  for char in s:             if char == 'i':                 # If the character is 'i', reverse the stack                 stack.reverse()             else:                 stack.append(char)                  # Convert the stack to a string and return         return ''.join(stack)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |class Solution:     def finalString(self, s: str) -> str:         while "i" in s:             index=s.index("i")              #first half and second half             first=s[:index][::-1]             second=s[index+1:]              s="".join([first,second])         return s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|24 |2             |C++     |easy      |ChatGPT        |Chatbot          |Your laptop keyboard is faulty, and whenever you type a character 'i' on it, it reverses the string that you have written. Typing other characters works as expected.  You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.  Return the final string that will be present on your laptop screen.  Example 1:  Input: s = "string" Output: "rtsng" Explanation:  After typing first character, the text on the screen is "s". After the second character, the text is "st".  After the third character, the text is "str". Since the fourth character is an 'i', the text gets reversed and becomes "rts". After the fifth character, the text is "rtsn".  After the sixth character, the text is "rtsng".  Therefore, we return "rtsng".  Example 2:  Input: s = "poiinter" Output: "ponter" Explanation:  After the first character, the text on the screen is "p". After the second character, the text is "po".  Since the third character you type is an 'i', the text gets reversed and becomes "op".  Since the fourth character you type is an 'i', the text gets reversed and becomes "po". After the fifth character, the text is "pon". After the sixth character, the text is "pont".  After the seventh character, the text is "ponte".  After the eighth character, the text is "ponter".  Therefore, we return "ponter".   Constraints:  1 <= s.length <= 100 s consists of lowercase English letters. s[0] != 'i'                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |Solve the following problem with C++ code. Class name: Solution, Method name: string finalString(string s).  Your laptop keyboard is faulty, and whenever you type a character 'i' on it, it reverses the string that you have written. Typing other characters works as expected.  You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.  Return the final string that will be present on your laptop screen.  Example 1:  Input: s = "string" Output: "rtsng" Explanation:  After typing first character, the text on the screen is "s". After the second character, the text is "st".  After the third character, the text is "str". Since the fourth character is an 'i', the text gets reversed and becomes "rts". After the fifth character, the text is "rtsn".  After the sixth character, the text is "rtsng".  Therefore, we return "rtsng".  Example 2:  Input: s = "poiinter" Output: "ponter" Explanation:  After the first character, the text on the screen is "p". After the second character, the text is "po".  Since the third character you type is an 'i', the text gets reversed and becomes "op".  Since the fourth character you type is an 'i', the text gets reversed and becomes "po". After the fifth character, the text is "pon". After the sixth character, the text is "pont".  After the seventh character, the text is "ponte".  After the eighth character, the text is "ponter".  Therefore, we return "ponter".   Constraints:  1 <= s.length <= 100 s consists of lowercase English letters. s[0] != 'i'                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |class Solution { public:     std::string finalString(std::string s) {         std::string result = ""; // Initialize the result string                  for (char c : s) {             if (c == 'i') {                 // If the character is 'i', reverse the result string                 std::reverse(result.begin(), result.end());             } else {                 // Otherwise, append the character to the result string                 result += c;             }         }                  return result;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |class Solution { public:     string finalString(const string &s) {         string a, b;         for (char ch : s)             if (ch == 'i')                 swap(a, b);             else                 a += ch;         return string(rbegin(b), rend(b)) + a;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
|25 |3             |Java    |medium    |ChatGPT        |Chatbot          |You are given a 0-indexed integer array nums and an integer x.  Find the minimum absolute difference between two elements in the array that are at least x indices apart.  In other words, find two indices i and j such that abs(i - j) >= x and abs(nums[i] - nums[j]) is minimized.  Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.  Example 1:  Input: nums = [4,3,2,4], x = 2 Output: 0 Explanation: We can select nums[0] = 4 and nums[3] = 4.  They are at least 2 indices apart, and their absolute difference is the minimum, 0.  It can be shown that 0 is the optimal answer.  Example 2:  Input: nums = [5,3,2,10,15], x = 1 Output: 1 Explanation: We can select nums[1] = 3 and nums[2] = 2. They are at least 1 index apart, and their absolute difference is the minimum, 1. It can be shown that 1 is the optimal answer.  Example 3:  Input: nums = [1,2,3,4], x = 3 Output: 3 Explanation: We can select nums[0] = 1 and nums[3] = 4. They are at least 3 indices apart, and their absolute difference is the minimum, 3. It can be shown that 3 is the optimal answer.   Constraints:  1 <= nums.length <= 10^5 1 <= nums[i] <= 10^9 0 <= x < nums.length                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |Solve the following problem with java code. Class name: Solution, Method name: minAbsoluteDifference(List<Integer> nums, int x).  You are given a 0-indexed integer array nums and an integer x.  Find the minimum absolute difference between two elements in the array that are at least x indices apart.  In other words, find two indices i and j such that abs(i - j) >= x and abs(nums[i] - nums[j]) is minimized.  Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.  Example 1:  Input: nums = [4,3,2,4], x = 2 Output: 0 Explanation: We can select nums[0] = 4 and nums[3] = 4.  They are at least 2 indices apart, and their absolute difference is the minimum, 0.  It can be shown that 0 is the optimal answer.  Example 2:  Input: nums = [5,3,2,10,15], x = 1 Output: 1 Explanation: We can select nums[1] = 3 and nums[2] = 2. They are at least 1 index apart, and their absolute difference is the minimum, 1. It can be shown that 1 is the optimal answer.  Example 3:  Input: nums = [1,2,3,4], x = 3 Output: 3 Explanation: We can select nums[0] = 1 and nums[3] = 4. They are at least 3 indices apart, and their absolute difference is the minimum, 3. It can be shown that 3 is the optimal answer.   Constraints:  1 <= nums.length <= 10^5 1 <= nums[i] <= 10^9 0 <= x < nums.length                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |public class Solution {     public int minAbsoluteDifference(List<Integer> nums, int x) {         int n = nums.size();         int minAbsDiff = Integer.MAX_VALUE;                  // Create a TreeMap to store the indices of elements         TreeMap<Integer, Integer> indexMap = new TreeMap<>();                  for (int i = 0; i < n; i++) {             int num = nums.get(i);                          // Check if there exists a number in the TreeMap with a difference of at least x             // from the current number, and update the minimum absolute difference accordingly.             Integer floorKey = indexMap.floorKey(num - x);             if (floorKey != null) {                 int index = indexMap.get(floorKey);                 minAbsDiff = Math.min(minAbsDiff, Math.abs(num - nums.get(index)));             }                          // Check if there exists a number in the TreeMap with a difference of at least x             // from the current number, and update the minimum absolute difference accordingly.             Integer ceilingKey = indexMap.ceilingKey(num + x);             if (ceilingKey != null) {                 int index = indexMap.get(ceilingKey);                 minAbsDiff = Math.min(minAbsDiff, Math.abs(num - nums.get(index)));             }                          // Update the index of the current number in the TreeMap.             indexMap.put(num, i);         }                  return minAbsDiff;     }     }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |class Solution {     int minAbsoluteDifference(List<Integer> nums, int x) {         int ans = Integer.MAX_VALUE;         TreeSet<Integer> s = new TreeSet<>();         for(int i = x; i < nums.size(); ++i){             s.add(nums.get(i-x));             Integer high = s.ceiling(nums.get(i)), low = s.floor(nums.get(i));             if(high != null) ans = Math.min(ans, Math.abs(nums.get(i) - high));             if(low != null) ans = Math.min(ans, Math.abs(nums.get(i) - low));         }         return ans;     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|26 |3             |Python  |medium    |ChatGPT        |Chatbot          |You are given a 0-indexed integer array nums and an integer x.  Find the minimum absolute difference between two elements in the array that are at least x indices apart.  In other words, find two indices i and j such that abs(i - j) >= x and abs(nums[i] - nums[j]) is minimized.  Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.  Example 1:  Input: nums = [4,3,2,4], x = 2 Output: 0 Explanation: We can select nums[0] = 4 and nums[3] = 4.  They are at least 2 indices apart, and their absolute difference is the minimum, 0.  It can be shown that 0 is the optimal answer.  Example 2:  Input: nums = [5,3,2,10,15], x = 1 Output: 1 Explanation: We can select nums[1] = 3 and nums[2] = 2. They are at least 1 index apart, and their absolute difference is the minimum, 1. It can be shown that 1 is the optimal answer.  Example 3:  Input: nums = [1,2,3,4], x = 3 Output: 3 Explanation: We can select nums[0] = 1 and nums[3] = 4. They are at least 3 indices apart, and their absolute difference is the minimum, 3. It can be shown that 3 is the optimal answer.   Constraints:  1 <= nums.length <= 10^5 1 <= nums[i] <= 10^9 0 <= x < nums.length                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |Solve the following problem with python3 code. Class name: Solution, Method name: def minAbsoluteDifference(self, nums: List[int], x: int) -> int:.  You are given a 0-indexed integer array nums and an integer x.  Find the minimum absolute difference between two elements in the array that are at least x indices apart.  In other words, find two indices i and j such that abs(i - j) >= x and abs(nums[i] - nums[j]) is minimized.  Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.  Example 1:  Input: nums = [4,3,2,4], x = 2 Output: 0 Explanation: We can select nums[0] = 4 and nums[3] = 4.  They are at least 2 indices apart, and their absolute difference is the minimum, 0.  It can be shown that 0 is the optimal answer.  Example 2:  Input: nums = [5,3,2,10,15], x = 1 Output: 1 Explanation: We can select nums[1] = 3 and nums[2] = 2. They are at least 1 index apart, and their absolute difference is the minimum, 1. It can be shown that 1 is the optimal answer.  Example 3:  Input: nums = [1,2,3,4], x = 3 Output: 3 Explanation: We can select nums[0] = 1 and nums[3] = 4. They are at least 3 indices apart, and their absolute difference is the minimum, 3. It can be shown that 3 is the optimal answer.   Constraints:  1 <= nums.length <= 10^5 1 <= nums[i] <= 10^9 0 <= x < nums.length                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |class Solution:     def minAbsoluteDifference(self, nums: List[int], x: int) -> int:         nums.sort()  # Sort the input array                  min_diff = float('inf')  # Initialize the minimum difference to positive infinity                  left = 0  # Initialize the left pointer         right = x  # Initialize the right pointer                  while right < len(nums):             min_diff = min(min_diff, nums[right] - nums[left])  # Update the minimum difference                          left += 1  # Move the left pointer             right += 1  # Move the right pointer                  return min_diff                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |class Solution:   def minAbsoluteDifference(self, nums: List[int], x: int) -> int:     if x == 0:       return 0      arr, best_dist = SortedList([]), float('inf')     for i in range(x, len(nums)):       arr.add(nums[i - x])       v = nums[i]        pos = arr.bisect_left(v)       if pos < len(arr):         best_dist = min(best_dist, abs(arr[pos] - v))       if pos > 0:         best_dist = min(best_dist, abs(arr[pos - 1] - v))          return best_dist                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
|27 |3             |C++     |medium    |ChatGPT        |Chatbot          |You are given a 0-indexed integer array nums and an integer x.  Find the minimum absolute difference between two elements in the array that are at least x indices apart.  In other words, find two indices i and j such that abs(i - j) >= x and abs(nums[i] - nums[j]) is minimized.  Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.  Example 1:  Input: nums = [4,3,2,4], x = 2 Output: 0 Explanation: We can select nums[0] = 4 and nums[3] = 4.  They are at least 2 indices apart, and their absolute difference is the minimum, 0.  It can be shown that 0 is the optimal answer.  Example 2:  Input: nums = [5,3,2,10,15], x = 1 Output: 1 Explanation: We can select nums[1] = 3 and nums[2] = 2. They are at least 1 index apart, and their absolute difference is the minimum, 1. It can be shown that 1 is the optimal answer.  Example 3:  Input: nums = [1,2,3,4], x = 3 Output: 3 Explanation: We can select nums[0] = 1 and nums[3] = 4. They are at least 3 indices apart, and their absolute difference is the minimum, 3. It can be shown that 3 is the optimal answer.   Constraints:  1 <= nums.length <= 10^5 1 <= nums[i] <= 10^9 0 <= x < nums.length                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |Solve the following problem with C++ code. Class name: Solution, Method name: int minAbsoluteDifference(vector<int>& nums, int x).  You are given a 0-indexed integer array nums and an integer x.  Find the minimum absolute difference between two elements in the array that are at least x indices apart.  In other words, find two indices i and j such that abs(i - j) >= x and abs(nums[i] - nums[j]) is minimized.  Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.  Example 1:  Input: nums = [4,3,2,4], x = 2 Output: 0 Explanation: We can select nums[0] = 4 and nums[3] = 4.  They are at least 2 indices apart, and their absolute difference is the minimum, 0.  It can be shown that 0 is the optimal answer.  Example 2:  Input: nums = [5,3,2,10,15], x = 1 Output: 1 Explanation: We can select nums[1] = 3 and nums[2] = 2. They are at least 1 index apart, and their absolute difference is the minimum, 1. It can be shown that 1 is the optimal answer.  Example 3:  Input: nums = [1,2,3,4], x = 3 Output: 3 Explanation: We can select nums[0] = 1 and nums[3] = 4. They are at least 3 indices apart, and their absolute difference is the minimum, 3. It can be shown that 3 is the optimal answer.   Constraints:  1 <= nums.length <= 10^5 1 <= nums[i] <= 10^9 0 <= x < nums.length                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |class Solution { public:     int minAbsoluteDifference(std::vector<int>& nums, int x) {         int n = nums.size();         std::vector<std::pair<int, int>> indexedNums; // Store the numbers along with their indices                  // Create a vector of pairs (number, index)         for (int i = 0; i < n; ++i) {             indexedNums.push_back({nums[i], i});         }                  // Sort the vector based on numbers         std::sort(indexedNums.begin(), indexedNums.end());                  int minDiff = INT_MAX; // Initialize the minimum difference to a large value                  // Traverse the sorted vector and find the minimum absolute difference         for (int i = 0; i < n; ++i) {             // Find the index of the element that is at least x indices apart             int j = i + x;             if (j < n) {                 int diff = abs(indexedNums[i].first - indexedNums[j].first);                 minDiff = std::min(minDiff, diff);             }         }                  return minDiff;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |class Solution { public:     int minAbsoluteDifference(vector<int>& nums, int x) {         int ans = INT_MAX;         set<int> s;         for(int i = x; i < nums.size(); ++i){             s.insert(nums[i-x]);             auto it = s.upper_bound(nums[i]);             if(it != s.end()) ans = min(ans, abs(nums[i] - *it));             if(it != s.begin()) ans = min(ans, abs(nums[i] - *prev(it)));         }         return ans;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|28 |4             |Java    |medium    |ChatGPT        |Chatbot          |You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.  Return the head of the linked list after doubling it.  Example 1:  Input: head = [1,8,9] Output: [3,7,8] Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.  Example 2:  Input: head = [9,9,9] Output: [1,9,9,8] Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998.   Constraints:  The number of nodes in the list is in the range [1, 10^4] 0 <= Node.val <= 9 The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |Solve the following problem with java code. Class name: Solution, Method name: doubleIt(ListNode head).  You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.  Return the head of the linked list after doubling it.  Example 1:  Input: head = [1,8,9] Output: [3,7,8] Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.  Example 2:  Input: head = [9,9,9] Output: [1,9,9,8] Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998.   Constraints:  The number of nodes in the list is in the range [1, 10^4] 0 <= Node.val <= 9 The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |public class Solution {     public ListNode doubleIt(ListNode head) {         if (head == null) {             return null;         }          int carry = 0;         ListNode current = head;         ListNode prev = null;          // Traverse the list in reverse order and double the values         while (current != null) {             int newVal = current.val * 2 + carry;             carry = newVal / 10;             current.val = newVal % 10;              prev = current;             current = current.next;         }          // If there's a remaining carry, add a new node for it         if (carry > 0) {             ListNode newNode = new ListNode(carry);             prev.next = newNode;         }          return reverseList(head);     }      public ListNode reverseList(ListNode head) {         ListNode prev = null;         ListNode current = head;          while (current != null) {             ListNode nextNode = current.next;             current.next = prev;             prev = current;             current = nextNode;         }          return prev;     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |class Solution {     public ListNode doubleIt(ListNode head) {         if (head.val > 4)             head = new ListNode(0, head);         for(ListNode node = head; node != null; node = node.next) {             node.val = (node.val * 2) % 10;             if (node.next != null && node.next.val > 4)                 node.val++;         }         return head;     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
|29 |4             |Python  |medium    |ChatGPT        |Chatbot          |You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.  Return the head of the linked list after doubling it.  Example 1:  Input: head = [1,8,9] Output: [3,7,8] Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.  Example 2:  Input: head = [9,9,9] Output: [1,9,9,8] Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998.   Constraints:  The number of nodes in the list is in the range [1, 10^4] 0 <= Node.val <= 9 The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |Solve the following problem with python3 code. Class name: Solution, Method name: def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:.  You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.  Return the head of the linked list after doubling it.  Example 1:  Input: head = [1,8,9] Output: [3,7,8] Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.  Example 2:  Input: head = [9,9,9] Output: [1,9,9,8] Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998.   Constraints:  The number of nodes in the list is in the range [1, 10^4] 0 <= Node.val <= 9 The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |class Solution:     def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:         if not head:             return None                  carry = 0         current = head         prev = None                  # Traverse the list in reverse order and double the values         while current:             newVal = current.val * 2 + carry             carry = newVal // 10             current.val = newVal % 10                          prev = current             current = current.next                  # If there's a remaining carry, add a new node for it         if carry > 0:             newNode = ListNode(carry)             prev.next = newNode                  return self.reverseList(head)          def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:         prev = None         current = head                  while current:             nextNode = current.next             current.next = prev             prev = current             current = nextNode                  return prev                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |class Solution:     def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:         if head.val > 4:             head = ListNode(0, head)         node = head         while node:             node.val = (node.val * 2) % 10             if node.next and node.next.val > 4:                 node.val += 1             node = node.next         return head                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
|30 |4             |C++     |medium    |ChatGPT        |Chatbot          |You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.  Return the head of the linked list after doubling it.  Example 1:  Input: head = [1,8,9] Output: [3,7,8] Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.  Example 2:  Input: head = [9,9,9] Output: [1,9,9,8] Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998.   Constraints:  The number of nodes in the list is in the range [1, 10^4] 0 <= Node.val <= 9 The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |Solve the following problem with C++ code. Class name: Solution, Method name: ListNode* doubleIt(ListNode* head).  You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.  Return the head of the linked list after doubling it.  Example 1:  Input: head = [1,8,9] Output: [3,7,8] Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.  Example 2:  Input: head = [9,9,9] Output: [1,9,9,8] Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998.   Constraints:  The number of nodes in the list is in the range [1, 10^4] 0 <= Node.val <= 9 The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |class Solution { public:     ListNode* doubleIt(ListNode* head) {         if (!head) {             return nullptr;         }          int carry = 0;         ListNode* current = head;         ListNode* prev = nullptr;          // Traverse the list in reverse order and double the values         while (current) {             int newVal = current->val * 2 + carry;             carry = newVal / 10;             current->val = newVal % 10;              prev = current;             current = current->next;         }          // If there's a remaining carry, add a new node for it         if (carry > 0) {             ListNode* newNode = new ListNode(carry);             prev->next = newNode;         }          return reverseList(head);     }      ListNode* reverseList(ListNode* head) {         ListNode* prev = nullptr;         ListNode* current = head;          while (current) {             ListNode* nextNode = current->next;             current->next = prev;             prev = current;             current = nextNode;         }          return prev;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |class Solution { public:     ListNode* doubleIt(ListNode* head) {         if (head->val > 4)             head = new ListNode(0, head);         for(ListNode* node = head; node; node = node->next) {             node->val = (node->val * 2) % 10;             if (node->next && node->next->val > 4)                 node->val++;         }         return head;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
|31 |5             |Java    |hard      |ChatGPT        |Chatbot          |You are given an array nums of n positive integers and an integer k.  Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:  Choose any non-empty subarray nums[l, ..., r] that you haven't chosen previously. Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index. Multiply your score by x. Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.  The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.  Return the maximum possible score after applying at most k operations.  Since the answer may be large, return it modulo 10^9 + 7.  Example 1:  Input: nums = [8,3,9,3,8], k = 2 Output: 81 Explanation: To get a score of 81, we can apply the following operations: - Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81. It can be proven that 81 is the highest score one can obtain.  Example 2:  Input: nums = [19,12,14,6,10,18], k = 3 Output: 4788 Explanation: To get a score of 4788, we can apply the following operations:  - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19. - Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788. It can be proven that 4788 is the highest score one can obtain.   Constraints:  1 <= nums.length == n <= 10^5 1 <= nums[i] <= 10^5 1 <= k <= min(n * (n + 1) / 2, 10^9) |Solve the following problem with java code. Class name: Solution, Method name: maximumScore(List<Integer> nums, int k).  You are given an array nums of n positive integers and an integer k.  Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:  Choose any non-empty subarray nums[l, ..., r] that you haven't chosen previously. Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index. Multiply your score by x. Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.  The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.  Return the maximum possible score after applying at most k operations.  Since the answer may be large, return it modulo 10^9 + 7.  Example 1:  Input: nums = [8,3,9,3,8], k = 2 Output: 81 Explanation: To get a score of 81, we can apply the following operations: - Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81. It can be proven that 81 is the highest score one can obtain.  Example 2:  Input: nums = [19,12,14,6,10,18], k = 3 Output: 4788 Explanation: To get a score of 4788, we can apply the following operations:  - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19. - Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788. It can be proven that 4788 is the highest score one can obtain.   Constraints:  1 <= nums.length == n <= 10^5 1 <= nums[i] <= 10^5 1 <= k <= min(n * (n + 1) / 2, 10^9).                   |public class Solution {     public int maximumScore(List<Integer> nums, int k) {         int MOD = 1000000007;         int n = nums.size();                  // Create an array to store the prime scores for each element.         int[] primeScores = new int[n];                  // Calculate the prime scores for each element using a helper function.         for (int i = 0; i < n; i++) {             primeScores[i] = calculatePrimeScore(nums.get(i));         }                  long score = 1L; // Initialize the score as a long integer to avoid overflow.                  // Create a max heap to keep track of the elements with the highest prime scores.         PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> Integer.compare(primeScores[b], primeScores[a]));                  // Initialize the max heap with the element at index k.         maxHeap.offer(k);                  // Create two arrays to keep track of the left and right boundaries of the subarray.         int[] left = new int[n];         int[] right = new int[n];                  // Initialize the left and right boundaries.         left[k] = k;         right[k] = k;                  // Perform at most k operations.         for (int i = 0; i < k; i++) {             int maxIndex = maxHeap.poll(); // Get the index with the highest prime score.                          // Calculate the new score by multiplying the current score by the selected element.             score = (score * nums.get(maxIndex)) % MOD;                          // Update the left and right boundaries for the subarray.             int newLeft = left[maxIndex] - 1;             int newRight = right[maxIndex] + 1;                          // Add the new potential candidates to the max heap.             if (newLeft >= 0) {                 maxHeap.offer(newLeft);                 left[newLeft] = newLeft;                 right[newLeft] = right[maxIndex];             }             if (newRight < n) {                 maxHeap.offer(newRight);                 left[newRight] = left[maxIndex];                 right[newRight] = newRight;             }         }                  return (int)score;     }          // Helper function to calculate the prime score of an integer.     private int calculatePrimeScore(int num) {         Set<Integer> factors = new HashSet<>();                  // Find prime factors of the number.         while (num % 2 == 0) {             factors.add(2);             num /= 2;         }                  for (int i = 3; i <= Math.sqrt(num); i += 2) {             while (num % i == 0) {                 factors.add(i);                 num /= i;             }         }                  if (num > 2) {             factors.add(num);         }                  return factors.size();     } }                                                      |class Solution {     static final int MOD = 1000000007;      public int maximumScore(List<Integer> nums, int k) {         int n = nums.size();          int upper = Collections.max(nums) + 1;          boolean[] prime = new boolean[upper];         int[] primeScore = new int[upper];         Arrays.fill(prime, true);         prime[0] = prime[1] = false;         for (int i = 2; i < upper; i++) {             if (prime[i]) {                 for (int j = i; j < upper; j += i) {                     primeScore[j]++;                     prime[j] = false;                 }             }         }          int[] nextGreaterElement = new int[n];         Arrays.fill(nextGreaterElement, n);         Stack<Integer> s = new Stack<>();         for (int i = n - 1; i >= 0; i--) {             while (!s.empty() && primeScore[nums.get(i)] >= primeScore[nums.get(s.peek())]) {                 s.pop();             }             nextGreaterElement[i] = s.empty() ? n : s.peek();             s.push(i);         }          int[] prevGreaterOrEqualElement = new int[n];         Arrays.fill(prevGreaterOrEqualElement, -1);         s = new Stack<>();         for (int i = 0; i < n; i++) {             while (!s.empty() && primeScore[nums.get(i)] > primeScore[nums.get(s.peek())]) {                 s.pop();             }             prevGreaterOrEqualElement[i] = s.empty() ? -1 : s.peek();             s.push(i);         }          int res = 1;         int[][] tuples = new int[n][2];         for (int i = 0; i < n; i++) {             tuples[i][0] = nums.get(i);             tuples[i][1] = i;         }         Arrays.sort(tuples, new Comparator<int[]>() {             public int compare(int[] a, int[] b) {                 return b[0] - a[0];             }         });         for (int i = 0; i < n; i++) {             int num = tuples[i][0];             int idx = tuples[i][1];             int operations = Math.min((idx - prevGreaterOrEqualElement[idx]) * (nextGreaterElement[idx] - idx), k);             res = (int)((1L * res * pow(num, operations)) % MOD);             k -= operations;             if (k == 0) {                 return res;             }         }          return res;     }      public int pow(int x, int n) {         int res = 1;         while (n > 0) {             if (n % 2 == 1) {                 res = (int)((1L * res * x) % MOD);             }             x = (int)((1L * x * x) % MOD);             n /= 2;         }         return res;     } }|
|32 |5             |Python  |hard      |ChatGPT        |Chatbot          |You are given an array nums of n positive integers and an integer k.  Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:  Choose any non-empty subarray nums[l, ..., r] that you haven't chosen previously. Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index. Multiply your score by x. Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.  The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.  Return the maximum possible score after applying at most k operations.  Since the answer may be large, return it modulo 10^9 + 7.  Example 1:  Input: nums = [8,3,9,3,8], k = 2 Output: 81 Explanation: To get a score of 81, we can apply the following operations: - Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81. It can be proven that 81 is the highest score one can obtain.  Example 2:  Input: nums = [19,12,14,6,10,18], k = 3 Output: 4788 Explanation: To get a score of 4788, we can apply the following operations:  - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19. - Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788. It can be proven that 4788 is the highest score one can obtain.   Constraints:  1 <= nums.length == n <= 10^5 1 <= nums[i] <= 10^5 1 <= k <= min(n * (n + 1) / 2, 10^9) |Solve the following problem with python3 code. Class name: Solution, Method name: def maximumScore(self, nums: List[int], k: int) -> int:.  You are given an array nums of n positive integers and an integer k.  Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:  Choose any non-empty subarray nums[l, ..., r] that you haven't chosen previously. Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index. Multiply your score by x. Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.  The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.  Return the maximum possible score after applying at most k operations.  Since the answer may be large, return it modulo 10^9 + 7.  Example 1:  Input: nums = [8,3,9,3,8], k = 2 Output: 81 Explanation: To get a score of 81, we can apply the following operations: - Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81. It can be proven that 81 is the highest score one can obtain.  Example 2:  Input: nums = [19,12,14,6,10,18], k = 3 Output: 4788 Explanation: To get a score of 4788, we can apply the following operations:  - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19. - Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788. It can be proven that 4788 is the highest score one can obtain.   Constraints:  1 <= nums.length == n <= 10^5 1 <= nums[i] <= 10^5 1 <= k <= min(n * (n + 1) / 2, 10^9).|class Solution:     def maximumScore(self, nums: List[int], k: int) -> int:         def prime_score(x):             factors = set()             while x % 2 == 0:                 factors.add(2)                 x //= 2             for i in range(3, int(x ** 0.5) + 1, 2):                 while x % i == 0:                     factors.add(i)                     x //= i             if x > 2:                 factors.add(x)             return len(factors)                  max_score = 1         MOD = 10 ** 9 + 7                  pq = []  # Priority queue to store elements by their prime scores                  for num in nums:             heapq.heappush(pq, (-prime_score(num), num))  # Use a negative score to get the maximum prime score first                  while k > 0:             prime_score, num = heapq.heappop(pq)  # Pop the element with the highest prime score             max_score = (max_score * num) % MOD             k -= 1                  return max_score                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |class Solution:      MOD = 1000000007      def maximumScore(self, nums: List[int], k: int) -> int:         n = len(nums)          upper = max(nums) + 1          prime = [True]*upper         prime[0] = prime[1] = False         primeScore = [0]*upper         for i in range(2, upper):             if prime[i]:                 for j in range(i, upper, i):                     primeScore[j] += 1                     prime[j] = False          nextGreaterElement = [n]*n         s = []         for i in range(n - 1, -1, -1):             while s and primeScore[nums[i]] >= primeScore[nums[s[-1]]]:                 s.pop()             nextGreaterElement[i] = s[-1] if s else n             s.append(i)          prevGreaterOrEqualElement = [-1]*n         s = []         for i in range(n):             while s and primeScore[nums[i]] > primeScore[nums[s[-1]]]:                 s.pop()             prevGreaterOrEqualElement[i] = s[-1] if s else -1             s.append(i)          res = 1         tuples = [[nums[i], i] for i in range(n)]         tuples.sort(reverse=True)         for num, idx in tuples:             operations = min((idx - prevGreaterOrEqualElement[idx]) * (nextGreaterElement[idx] - idx), k)             res = (res * self.pow(num, operations)) % self.MOD             k -= operations             if k == 0:                 return res          return res      def pow(self, x: int, n: int) -> int:         res = 1         while n > 0:             if n % 2 == 1:                 res = (res * x) % self.MOD             x = (x * x) % self.MOD             n //= 2         return res                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
|33 |5             |C++     |hard      |ChatGPT        |Chatbot          |You are given an array nums of n positive integers and an integer k.  Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:  Choose any non-empty subarray nums[l, ..., r] that you haven't chosen previously. Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index. Multiply your score by x. Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.  The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.  Return the maximum possible score after applying at most k operations.  Since the answer may be large, return it modulo 10^9 + 7.  Example 1:  Input: nums = [8,3,9,3,8], k = 2 Output: 81 Explanation: To get a score of 81, we can apply the following operations: - Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81. It can be proven that 81 is the highest score one can obtain.  Example 2:  Input: nums = [19,12,14,6,10,18], k = 3 Output: 4788 Explanation: To get a score of 4788, we can apply the following operations:  - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19. - Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788. It can be proven that 4788 is the highest score one can obtain.   Constraints:  1 <= nums.length == n <= 10^5 1 <= nums[i] <= 10^5 1 <= k <= min(n * (n + 1) / 2, 10^9) |Solve the following problem with C++ code. Class name: Solution, Method name: int maximumScore(vector<int>& nums, int k).  You are given an array nums of n positive integers and an integer k.  Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:  Choose any non-empty subarray nums[l, ..., r] that you haven't chosen previously. Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index. Multiply your score by x. Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.  The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.  Return the maximum possible score after applying at most k operations.  Since the answer may be large, return it modulo 10^9 + 7.  Example 1:  Input: nums = [8,3,9,3,8], k = 2 Output: 81 Explanation: To get a score of 81, we can apply the following operations: - Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81. It can be proven that 81 is the highest score one can obtain.  Example 2:  Input: nums = [19,12,14,6,10,18], k = 3 Output: 4788 Explanation: To get a score of 4788, we can apply the following operations:  - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19. - Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788. It can be proven that 4788 is the highest score one can obtain.   Constraints:  1 <= nums.length == n <= 10^5 1 <= nums[i] <= 10^5 1 <= k <= min(n * (n + 1) / 2, 10^9).                 |class Solution { public:     const int MOD = 1e9 + 7;      int maximumScore(std::vector<int>& nums, int k) {         int n = nums.size();         std::unordered_map<int, int> primeScore; // Map to store prime scores of elements         int left = 0; // Left pointer of the sliding window         long long score = 1; // Initial score         int maxScore = 1; // Maximum score          for (int right = 0; right < n; ++right) {             // Calculate prime score for the new element             int curScore = calculatePrimeScore(nums[right]);              // Update prime score map             primeScore[nums[right]]++;              // Increment the score by multiplying it with the prime score             score = (score * curScore) % MOD;              // Check if the window size exceeds k, then we need to shrink the window             while (right - left + 1 > k) {                 int leftElem = nums[left];                 primeScore[leftElem]--;                  // If the left element has no more occurrences in the window, remove it from the map                 if (primeScore[leftElem] == 0) {                     primeScore.erase(leftElem);                 }                  // Move the left pointer to the right                 left++;             }              // Update the maximum score             maxScore = std::max(maxScore, static_cast<int>(score));         }          return maxScore;     }      // Helper function to calculate the prime score of an integer     int calculatePrimeScore(int x) {         int score = 0;         for (int i = 2; i * i <= x; ++i) {             while (x % i == 0) {                 x /= i;                 score++;             }         }         if (x > 1) {             score++;         }         return score;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |class Solution { public:     const int MOD = 1000000007;      int maximumScore(vector<int>& nums, int k) {         int n = nums.size();          int upper = *max_element(nums.begin(), nums.end()) + 1;          vector<bool> prime(upper, true);         prime[0] = prime[1] = false;         vector<int> primeScore(upper, 0);         for (int i = 2; i < upper; i++) {             if (prime[i]) {                 for (int j = i; j < upper; j += i) {                     primeScore[j]++;                     prime[j] = false;                 }             }         }          vector<int> nextGreaterElement(n, n);         stack<int> s;         for (int i = n - 1; i >= 0; i--) {             while (!s.empty() && primeScore[nums[i]] >= primeScore[nums[s.top()]]) {                 s.pop();             }             nextGreaterElement[i] = s.empty() ? n : s.top();             s.push(i);         }          vector<int> prevGreaterOrEqualElement(n, -1);         s = stack<int>();         for (int i = 0; i < n; i++) {             while (!s.empty() && primeScore[nums[i]] > primeScore[nums[s.top()]]) {                 s.pop();             }             prevGreaterOrEqualElement[i] = s.empty() ? -1 : s.top();             s.push(i);         }          int res = 1;         vector<pair<int, int>> tuples(n);         for (int i = 0; i < n; i++) {             tuples[i].first = nums[i];             tuples[i].second = i;         }         sort(tuples.rbegin(), tuples.rend());         for (const auto& [num, i] : tuples) {             int operations = min((i - prevGreaterOrEqualElement[i]) * (nextGreaterElement[i] - i), k);             res = (int)((1L * res * pow(num, operations)) % MOD);             k -= operations;             if (k == 0) {                 return res;             }         }          return res;     }      int pow(int x, int n) {         int res = 1;         while (n > 0) {             if (n % 2 == 1) {                 res = (int)((1L * res * x) % MOD);             }             x = (int)((1L * x * x) % MOD);             n /= 2;         }         return res;     } };                                                                                                                                                                                                                                                                                                                                                                               |
|34 |6             |Java    |hard      |ChatGPT        |Chatbot          |You are given a 0-indexed 2D integer array items of length n and an integer k.  items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.  Let's define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.  Your task is to find the maximum elegance from all subsequences of size k in items.  Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.  Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order.  Example 1:  Input: items = [[3,2],[5,1],[10,1]], k = 2 Output: 17 Explanation: In this example, we have to select a subsequence of size 2. We can select items[0] = [3,2] and items[2] = [10,1]. The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1]. Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance.   Example 2:  Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3 Output: 19 Explanation: In this example, we have to select a subsequence of size 3.  We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3].  The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3].  Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.  Example 3:  Input: items = [[1,1],[2,1],[3,1]], k = 3 Output: 7 Explanation: In this example, we have to select a subsequence of size 3.  We should select all the items.  The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1].  Hence, the maximum elegance is 6 + 1^2 = 7.     Constraints:  1 <= items.length == n <= 10^5 items[i].length == 2 items[i][0] == profit_i items[i][1] == category_i 1 <= profit_i <= 10^9 1 <= category_i <= n  1 <= k <= n                                             |Solve the following problem with java code. Class name: Solution, Method name: findMaximumElegance(int [][] items, int k).  You are given a 0-indexed 2D integer array items of length n and an integer k.  items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.  Let's define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.  Your task is to find the maximum elegance from all subsequences of size k in items.  Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.  Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order.  Example 1:  Input: items = [[3,2],[5,1],[10,1]], k = 2 Output: 17 Explanation: In this example, we have to select a subsequence of size 2. We can select items[0] = [3,2] and items[2] = [10,1]. The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1]. Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance.   Example 2:  Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3 Output: 19 Explanation: In this example, we have to select a subsequence of size 3.  We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3].  The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3].  Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.  Example 3:  Input: items = [[1,1],[2,1],[3,1]], k = 3 Output: 7 Explanation: In this example, we have to select a subsequence of size 3.  We should select all the items.  The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1].  Hence, the maximum elegance is 6 + 1^2 = 7.     Constraints:  1 <= items.length == n <= 10^5 items[i].length == 2 items[i][0] == profit_i items[i][1] == category_i 1 <= profit_i <= 10^9 1 <= category_i <= n  1 <= k <= n                                                             |public class Solution {     public int findMaximumElegance(int[][] items, int k) {         List<int[]> itemList = new ArrayList<>();         Map<Integer, Integer> categoryFreq = new HashMap<>();         int totalProfit = 0;         int distinctCategories = 0;         int maxElegance = 0;          for (int[] item : items) {             itemList.add(item);         }          Collections.sort(itemList, (a, b) -> b[0] - a[0]); // Sort by profit in descending order          for (int i = 0; i < itemList.size(); i++) {             int[] item = itemList.get(i);             int profit = item[0];             int category = item[1];              categoryFreq.put(category, categoryFreq.getOrDefault(category, 0) + 1);             totalProfit += profit;              if (categoryFreq.get(category) == 1) {                 distinctCategories++;             }              int elegance = totalProfit + distinctCategories * distinctCategories;             maxElegance = Math.max(maxElegance, elegance);              if (distinctCategories == k) {                 break; // We have reached the required number of distinct categories             }         }          return maxElegance;     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |class Solution {     public long findMaximumElegance(int[][] A, int k) {         Arrays.sort(A, (a, b) -> b[0] - a[0]);         long res = 0, cur = 0;         List<Integer> dup = new ArrayList<>();         Set<Integer> seen = new HashSet<>();         for (int i = 0; i < A.length; ++i) {             if (i < k) {                 if (seen.contains(A[i][1])) {                     dup.add(A[i][0]);                 }                 cur += A[i][0];             } else if (!seen.contains(A[i][1])) {                 if (dup.isEmpty()) break;                 cur += A[i][0] - dup.remove(dup.size() - 1);             }             seen.add(A[i][1]);             res = Math.max(res, cur + 1L * seen.size() * seen.size());         }         return res;     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|35 |6             |Python  |hard      |ChatGPT        |Chatbot          |You are given a 0-indexed 2D integer array items of length n and an integer k.  items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.  Let's define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.  Your task is to find the maximum elegance from all subsequences of size k in items.  Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.  Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order.  Example 1:  Input: items = [[3,2],[5,1],[10,1]], k = 2 Output: 17 Explanation: In this example, we have to select a subsequence of size 2. We can select items[0] = [3,2] and items[2] = [10,1]. The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1]. Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance.   Example 2:  Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3 Output: 19 Explanation: In this example, we have to select a subsequence of size 3.  We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3].  The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3].  Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.  Example 3:  Input: items = [[1,1],[2,1],[3,1]], k = 3 Output: 7 Explanation: In this example, we have to select a subsequence of size 3.  We should select all the items.  The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1].  Hence, the maximum elegance is 6 + 1^2 = 7.     Constraints:  1 <= items.length == n <= 10^5 items[i].length == 2 items[i][0] == profit_i items[i][1] == category_i 1 <= profit_i <= 10^9 1 <= category_i <= n  1 <= k <= n                                             |Solve the following problem with python3 code. Class name: Solution, Method name: def findMaximumElegance(self, items: List[List[int]], k: int) -> int:.  You are given a 0-indexed 2D integer array items of length n and an integer k.  items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.  Let's define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.  Your task is to find the maximum elegance from all subsequences of size k in items.  Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.  Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order.  Example 1:  Input: items = [[3,2],[5,1],[10,1]], k = 2 Output: 17 Explanation: In this example, we have to select a subsequence of size 2. We can select items[0] = [3,2] and items[2] = [10,1]. The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1]. Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance.   Example 2:  Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3 Output: 19 Explanation: In this example, we have to select a subsequence of size 3.  We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3].  The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3].  Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.  Example 3:  Input: items = [[1,1],[2,1],[3,1]], k = 3 Output: 7 Explanation: In this example, we have to select a subsequence of size 3.  We should select all the items.  The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1].  Hence, the maximum elegance is 6 + 1^2 = 7.     Constraints:  1 <= items.length == n <= 10^5 items[i].length == 2 items[i][0] == profit_i items[i][1] == category_i 1 <= profit_i <= 10^9 1 <= category_i <= n  1 <= k <= n                               |class Solution:     def findMaximumElegance(self, items: List[List[int]], k: int) -> int:         n = len(items)         max_elegance = 0                  # Generate all possible combinations of items with size k         for combo in combinations(items, k):             total_profit = sum(item[0] for item in combo)             categories = [item[1] for item in combo]             distinct_categories = len(Counter(categories))             elegance = total_profit + distinct_categories ** 2             max_elegance = max(max_elegance, elegance)                  return max_elegance                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |class Solution:     def findMaximumElegance(self, items: List[List[int]], k: int) -> int:         items = sorted(items, key=lambda v: -v[0])         res = cur = 0         A = []         seen = set()         for i, (p, c) in enumerate(items):             if i < k:                 if c in seen:                     A.append(p)                 cur += p             elif c not in seen:                 if not A: break                 cur += p - A.pop()             seen.add(c)             res = max(res, cur + len(seen) * len(seen))         return res                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
|36 |6             |C++     |hard      |ChatGPT        |Chatbot          |You are given a 0-indexed 2D integer array items of length n and an integer k.  items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.  Let's define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.  Your task is to find the maximum elegance from all subsequences of size k in items.  Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.  Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order.  Example 1:  Input: items = [[3,2],[5,1],[10,1]], k = 2 Output: 17 Explanation: In this example, we have to select a subsequence of size 2. We can select items[0] = [3,2] and items[2] = [10,1]. The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1]. Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance.   Example 2:  Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3 Output: 19 Explanation: In this example, we have to select a subsequence of size 3.  We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3].  The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3].  Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.  Example 3:  Input: items = [[1,1],[2,1],[3,1]], k = 3 Output: 7 Explanation: In this example, we have to select a subsequence of size 3.  We should select all the items.  The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1].  Hence, the maximum elegance is 6 + 1^2 = 7.     Constraints:  1 <= items.length == n <= 10^5 items[i].length == 2 items[i][0] == profit_i items[i][1] == category_i 1 <= profit_i <= 10^9 1 <= category_i <= n  1 <= k <= n                                             |Solve the following problem with C++ code. Class name: Solution, Method name: long long findMaximumElegance(vector<vector<int>>& items, int k).  You are given a 0-indexed 2D integer array items of length n and an integer k.  items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.  Let's define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.  Your task is to find the maximum elegance from all subsequences of size k in items.  Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.  Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order.  Example 1:  Input: items = [[3,2],[5,1],[10,1]], k = 2 Output: 17 Explanation: In this example, we have to select a subsequence of size 2. We can select items[0] = [3,2] and items[2] = [10,1]. The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1]. Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance.   Example 2:  Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3 Output: 19 Explanation: In this example, we have to select a subsequence of size 3.  We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3].  The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3].  Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.  Example 3:  Input: items = [[1,1],[2,1],[3,1]], k = 3 Output: 7 Explanation: In this example, we have to select a subsequence of size 3.  We should select all the items.  The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1].  Hence, the maximum elegance is 6 + 1^2 = 7.     Constraints:  1 <= items.length == n <= 10^5 items[i].length == 2 items[i][0] == profit_i items[i][1] == category_i 1 <= profit_i <= 10^9 1 <= category_i <= n  1 <= k <= n                                        |class Solution { public:     long long findMaximumElegance(std::vector<std::vector<int>>& items, int k) {         std::unordered_map<int, std::vector<int>> categoryToProfits;         std::unordered_map<int, long long> categoryToTotalProfit;          for (auto& item : items) {             int profit = item[0];             int category = item[1];             categoryToProfits[category].push_back(profit);             categoryToTotalProfit[category] += profit;         }          std::vector<long long> maxProfits;         long long totalElegance = 0;          for (auto& pair : categoryToProfits) {             int category = pair.first;             std::vector<int>& profits = pair.second;              std::sort(profits.rbegin(), profits.rend());              long long categoryTotalProfit = categoryToTotalProfit[category];             int categoryDistinctCount = profits.size();              for (int i = 0; i < k && i < categoryDistinctCount; ++i) {                 totalElegance += profits[i] + static_cast<long long>(categoryDistinctCount) * categoryDistinctCount;                 maxProfits.push_back(profits[i]);             }         }          std::sort(maxProfits.rbegin(), maxProfits.rend());          for (int i = k; i < maxProfits.size(); ++i) {             totalElegance -= maxProfits[i];         }          return totalElegance;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |class Solution { public:     long long findMaximumElegance(vector<vector<int>>& A, int k) {         sort(A.begin(), A.end(), [](const vector<int>& a, const vector<int>& b) {             return a[0] > b[0];         });         long long res = 0, cur = 0;         vector<int> dup;         unordered_set<int> seen;         for (int i = 0; i < A.size(); ++i) {             if (i < k) {                 if (seen.count(A[i][1])) {                     dup.push_back(A[i][0]);                 }                 cur += A[i][0];             } else if (seen.find(A[i][1]) == seen.end()) {                 if (dup.empty()) break;                 cur += A[i][0] - dup.back();                 dup.pop_back();             }             seen.insert(A[i][1]);             res = fmax(res, cur + 1L * seen.size() * seen.size());         }         return res;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
|37 |1             |Java    |easy      |Code Llama     |IDE Extension    |You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.  Return the maximum sum or -1 if no such pair exists.  Example 1:  Input: nums = [51,71,17,24,42] Output: 88 Explanation:  For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88.  For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66. It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.  Example 2:  Input: nums = [1,2,3,4] Output: -1 Explanation: No pair exists in nums with equal maximum digits.  Constraints:  2 <= nums.length <= 100 1 <= nums[i] <= 10^4                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |class Solution {     public int maxSum(int[] nums) { /*You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.  Return the maximum sum or -1 if no such pair exists.  Example 1:  Input: nums = [51,71,17,24,42] Output: 88 Explanation:  For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88.  For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66. It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.  Example 2:  Input: nums = [1,2,3,4] Output: -1 Explanation: No pair exists in nums with equal maximum digits.  Constraints:  2 <= nums.length <= 100 1 <= nums[i] <= 10^4*/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |class Solution {     public int maxSum(int[] nums) {         int max = 0;         int maxDigit = 0;         for(int i = 0; i < nums.length; i++){             int digit = 0;             int num = nums[i];             while(num > 0){                 digit = Math.max(digit, num % 10);                 num /= 10;             }             if(digit > maxDigit){                 maxDigit = digit;                 max = nums[i];             }             else if(digit == maxDigit){                 max = Math.max(max, nums[i]);             }         }                  int maxSum = 0;         for(int i = 0; i < nums.length; i++){             int digit = 0;             int num = nums[i];             while(num > 0){                 digit = Math.max(digit, num % 10);                 num /= 10;             }             if(digit == maxDigit){                 maxSum = Math.max(maxSum, nums[i]);             }         }                  if(maxSum == 0){             return -1;         }                  int sum = 0;         for(int i = 0; i < nums.length; i++){             if(nums[i] == max){                 sum += nums[i];             }             else if(nums[i] == maxSum){                 sum += nums[i];             }         }                  return sum;     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |class Solution {     public int maxSum(int[] nums) {     int ans = -1;     Map<Integer,List<Integer>> ump = new HashMap<>();     for(int i = 0; i < nums.length; ++i){         int t = nums[i], maxDigit = 0;         while(t != 0){ //evaluate max digit in the number             maxDigit = Math.max(t%10, maxDigit);             t = t/10;         }         if(!ump.containsKey(maxDigit)) ump.put(maxDigit, new ArrayList<>());         ump.get(maxDigit).add(nums[i]); // add the number to the map      }     for(Map.Entry<Integer, List<Integer>> entry: ump.entrySet()){         entry.getValue().sort(Comparator.reverseOrder()); //to find max two number in each max digit          if(entry.getValue().size() >= 2) ans = Math.max(ans, entry.getValue().get(0) + entry.getValue().get(1)); //sum max two number and take max     }     return ans;     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
|38 |1             |Python  |easy      |Code Llama     |IDE Extension    |You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.  Return the maximum sum or -1 if no such pair exists.  Example 1:  Input: nums = [51,71,17,24,42] Output: 88 Explanation:  For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88.  For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66. It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.  Example 2:  Input: nums = [1,2,3,4] Output: -1 Explanation: No pair exists in nums with equal maximum digits.  Constraints:  2 <= nums.length <= 100 1 <= nums[i] <= 10^4                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |class Solution:     def maxSum(self, nums: List[int]) -> int: """You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.  Return the maximum sum or -1 if no such pair exists.  Example 1:  Input: nums = [51,71,17,24,42] Output: 88 Explanation:  For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88.  For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66. It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.  Example 2:  Input: nums = [1,2,3,4] Output: -1 Explanation: No pair exists in nums with equal maximum digits.  Constraints:  2 <= nums.length <= 100 1 <= nums[i] <= 10^4"""                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |class Solution:     def maxSum(self, nums: List[int]) -> int:         for i in range(len(nums)):             for j in range(i+1, len(nums)):                 if max(nums[i], nums[j]) % 10 == max(nums[i] // 10, nums[j] // 10):                     return max(nums[i], nums[j])         return -1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |class Solution:     def maxSum(self, nums: List[int]) -> int:         max_by_digit = defaultdict(int)         max_sum = -1          for num in nums:             digit = max(str(num))              if digit in max_by_digit:                 max_sum = max(max_sum, max_by_digit[digit] + num)              max_by_digit[digit] = max(max_by_digit[digit], num)          return max_sum                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
|39 |1             |C++     |easy      |Code Llama     |IDE Extension    |You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.  Return the maximum sum or -1 if no such pair exists.  Example 1:  Input: nums = [51,71,17,24,42] Output: 88 Explanation:  For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88.  For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66. It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.  Example 2:  Input: nums = [1,2,3,4] Output: -1 Explanation: No pair exists in nums with equal maximum digits.  Constraints:  2 <= nums.length <= 100 1 <= nums[i] <= 10^4                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |class Solution { public:     int maxSum(vector<int>& nums) { /*You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.  Return the maximum sum or -1 if no such pair exists.  Example 1:  Input: nums = [51,71,17,24,42] Output: 88 Explanation:  For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88.  For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66. It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.  Example 2:  Input: nums = [1,2,3,4] Output: -1 Explanation: No pair exists in nums with equal maximum digits.  Constraints:  2 <= nums.length <= 100 1 <= nums[i] <= 10^4*/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |class Solution { public:     int maxSum(vector<int>& nums) {        int n = nums.size();         int max_digit = 0;         for(int i = 0; i < n; i++){             int digit = 0;             int num = nums[i];             while(num){                 digit = max(digit, num % 10);                 num /= 10;             }             max_digit = max(max_digit, digit);         }                  int max_sum = -1;         for(int i = 0; i < n; i++){             for(int j = i + 1; j < n; j++){                 int digit = 0;                 int num = nums[i] + nums[j];                 while(num){                     digit = max(digit, num % 10);                     num /= 10;                 }                 if(digit == max_digit){                     max_sum = max(max_sum, nums[i] + nums[j]);                 }             }         }                  return max_sum;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |class Solution {     public:         int maxSum(vector<int>& nums) {         int res = -1, max_num[10] = {};         for (auto num : nums) {             int max_d = 0;             for (int v = num; v; v /= 10)                 max_d = max(max_d, v % 10);             if (max_num[max_d])                 res = max(res, max_num[max_d] + num);             max_num[max_d] = max(max_num[max_d], num);         }         return res;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|40 |2             |Java    |easy      |Code Llama     |IDE Extension    |Your laptop keyboard is faulty, and whenever you type a character 'i' on it, it reverses the string that you have written. Typing other characters works as expected.  You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.  Return the final string that will be present on your laptop screen.  Example 1:  Input: s = "string" Output: "rtsng" Explanation:  After typing first character, the text on the screen is "s". After the second character, the text is "st".  After the third character, the text is "str". Since the fourth character is an 'i', the text gets reversed and becomes "rts". After the fifth character, the text is "rtsn".  After the sixth character, the text is "rtsng".  Therefore, we return "rtsng".  Example 2:  Input: s = "poiinter" Output: "ponter" Explanation:  After the first character, the text on the screen is "p". After the second character, the text is "po".  Since the third character you type is an 'i', the text gets reversed and becomes "op".  Since the fourth character you type is an 'i', the text gets reversed and becomes "po". After the fifth character, the text is "pon". After the sixth character, the text is "pont".  After the seventh character, the text is "ponte".  After the eighth character, the text is "ponter".  Therefore, we return "ponter".   Constraints:  1 <= s.length <= 100 s consists of lowercase English letters. s[0] != 'i'                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |class Solution {     public String finalString(String s) { /*Your laptop keyboard is faulty, and whenever you type a character 'i' on it, it reverses the string that you have written. Typing other characters works as expected.  You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.  Return the final string that will be present on your laptop screen.  Example 1:  Input: s = "string" Output: "rtsng" Explanation:  After typing first character, the text on the screen is "s". After the second character, the text is "st".  After the third character, the text is "str". Since the fourth character is an 'i', the text gets reversed and becomes "rts". After the fifth character, the text is "rtsn".  After the sixth character, the text is "rtsng".  Therefore, we return "rtsng".  Example 2:  Input: s = "poiinter" Output: "ponter" Explanation:  After the first character, the text on the screen is "p". After the second character, the text is "po".  Since the third character you type is an 'i', the text gets reversed and becomes "op".  Since the fourth character you type is an 'i', the text gets reversed and becomes "po". After the fifth character, the text is "pon". After the sixth character, the text is "pont".  After the seventh character, the text is "ponte".  After the eighth character, the text is "ponter".  Therefore, we return "ponter".   Constraints:  1 <= s.length <= 100 s consists of lowercase English letters. s[0] != 'i'*/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |class Solution {     public String finalString(String s) {         StringBuilder sb = new StringBuilder();         for(int i = 0; i < s.length(); i++){             if(s.charAt(i) == 'i'){                 sb.reverse();             }             else{                 sb.append(s.charAt(i));             }         }         return sb.toString();     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |class Solution {     public String finalString(String s) {         StringBuilder nm=new StringBuilder();         for(char c:s.toCharArray())         {             if(c=='i')             {                 nm.reverse();             }             else             {                 nm.append(c);             }         }         return nm.toString();     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|41 |2             |Python  |easy      |Code Llama     |IDE Extension    |Your laptop keyboard is faulty, and whenever you type a character 'i' on it, it reverses the string that you have written. Typing other characters works as expected.  You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.  Return the final string that will be present on your laptop screen.  Example 1:  Input: s = "string" Output: "rtsng" Explanation:  After typing first character, the text on the screen is "s". After the second character, the text is "st".  After the third character, the text is "str". Since the fourth character is an 'i', the text gets reversed and becomes "rts". After the fifth character, the text is "rtsn".  After the sixth character, the text is "rtsng".  Therefore, we return "rtsng".  Example 2:  Input: s = "poiinter" Output: "ponter" Explanation:  After the first character, the text on the screen is "p". After the second character, the text is "po".  Since the third character you type is an 'i', the text gets reversed and becomes "op".  Since the fourth character you type is an 'i', the text gets reversed and becomes "po". After the fifth character, the text is "pon". After the sixth character, the text is "pont".  After the seventh character, the text is "ponte".  After the eighth character, the text is "ponter".  Therefore, we return "ponter".   Constraints:  1 <= s.length <= 100 s consists of lowercase English letters. s[0] != 'i'                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |class Solution:     def finalString(self, s: str) -> str: """Your laptop keyboard is faulty, and whenever you type a character 'i' on it, it reverses the string that you have written. Typing other characters works as expected.  You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.  Return the final string that will be present on your laptop screen.  Example 1:  Input: s = "string" Output: "rtsng" Explanation:  After typing first character, the text on the screen is "s". After the second character, the text is "st".  After the third character, the text is "str". Since the fourth character is an 'i', the text gets reversed and becomes "rts". After the fifth character, the text is "rtsn".  After the sixth character, the text is "rtsng".  Therefore, we return "rtsng".  Example 2:  Input: s = "poiinter" Output: "ponter" Explanation:  After the first character, the text on the screen is "p". After the second character, the text is "po".  Since the third character you type is an 'i', the text gets reversed and becomes "op".  Since the fourth character you type is an 'i', the text gets reversed and becomes "po". After the fifth character, the text is "pon". After the sixth character, the text is "pont".  After the seventh character, the text is "ponte".  After the eighth character, the text is "ponter".  Therefore, we return "ponter".   Constraints:  1 <= s.length <= 100 s consists of lowercase English letters. s[0] != 'i'"""                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |class Solution:     def finalString(self, s: str) -> str:         res = ""         for i in s:             if i == "i":                 res = res[::-1]             else:                 res += i         return res                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |class Solution:     def finalString(self, s: str) -> str:         while "i" in s:             index=s.index("i")              #first half and second half             first=s[:index][::-1]             second=s[index+1:]              s="".join([first,second])         return s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|42 |2             |C++     |easy      |Code Llama     |IDE Extension    |Your laptop keyboard is faulty, and whenever you type a character 'i' on it, it reverses the string that you have written. Typing other characters works as expected.  You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.  Return the final string that will be present on your laptop screen.  Example 1:  Input: s = "string" Output: "rtsng" Explanation:  After typing first character, the text on the screen is "s". After the second character, the text is "st".  After the third character, the text is "str". Since the fourth character is an 'i', the text gets reversed and becomes "rts". After the fifth character, the text is "rtsn".  After the sixth character, the text is "rtsng".  Therefore, we return "rtsng".  Example 2:  Input: s = "poiinter" Output: "ponter" Explanation:  After the first character, the text on the screen is "p". After the second character, the text is "po".  Since the third character you type is an 'i', the text gets reversed and becomes "op".  Since the fourth character you type is an 'i', the text gets reversed and becomes "po". After the fifth character, the text is "pon". After the sixth character, the text is "pont".  After the seventh character, the text is "ponte".  After the eighth character, the text is "ponter".  Therefore, we return "ponter".   Constraints:  1 <= s.length <= 100 s consists of lowercase English letters. s[0] != 'i'                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |class Solution { public:     string finalString(string s) { /*Your laptop keyboard is faulty, and whenever you type a character 'i' on it, it reverses the string that you have written. Typing other characters works as expected.  You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.  Return the final string that will be present on your laptop screen.  Example 1:  Input: s = "string" Output: "rtsng" Explanation:  After typing first character, the text on the screen is "s". After the second character, the text is "st".  After the third character, the text is "str". Since the fourth character is an 'i', the text gets reversed and becomes "rts". After the fifth character, the text is "rtsn".  After the sixth character, the text is "rtsng".  Therefore, we return "rtsng".  Example 2:  Input: s = "poiinter" Output: "ponter" Explanation:  After the first character, the text on the screen is "p". After the second character, the text is "po".  Since the third character you type is an 'i', the text gets reversed and becomes "op".  Since the fourth character you type is an 'i', the text gets reversed and becomes "po". After the fifth character, the text is "pon". After the sixth character, the text is "pont".  After the seventh character, the text is "ponte".  After the eighth character, the text is "ponter".  Therefore, we return "ponter".   Constraints:  1 <= s.length <= 100 s consists of lowercase English letters. s[0] != 'i'*/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |class Solution { public:     string finalString(string s) {         string ans;         for(int i = 0; i < s.length(); i++){             if(s[i] == 'i'){                 reverse(ans.begin(), ans.end());             }             else{                 ans.push_back(s[i]);             }         }         return ans;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |class Solution { public:     string finalString(const string &s) {         string a, b;         for (char ch : s)             if (ch == 'i')                 swap(a, b);             else                 a += ch;         return string(rbegin(b), rend(b)) + a;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
|43 |3             |Java    |medium    |Code Llama     |IDE Extension    |You are given a 0-indexed integer array nums and an integer x.  Find the minimum absolute difference between two elements in the array that are at least x indices apart.  In other words, find two indices i and j such that abs(i - j) >= x and abs(nums[i] - nums[j]) is minimized.  Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.  Example 1:  Input: nums = [4,3,2,4], x = 2 Output: 0 Explanation: We can select nums[0] = 4 and nums[3] = 4.  They are at least 2 indices apart, and their absolute difference is the minimum, 0.  It can be shown that 0 is the optimal answer.  Example 2:  Input: nums = [5,3,2,10,15], x = 1 Output: 1 Explanation: We can select nums[1] = 3 and nums[2] = 2. They are at least 1 index apart, and their absolute difference is the minimum, 1. It can be shown that 1 is the optimal answer.  Example 3:  Input: nums = [1,2,3,4], x = 3 Output: 3 Explanation: We can select nums[0] = 1 and nums[3] = 4. They are at least 3 indices apart, and their absolute difference is the minimum, 3. It can be shown that 3 is the optimal answer.   Constraints:  1 <= nums.length <= 10^5 1 <= nums[i] <= 10^9 0 <= x < nums.length                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |class Solution {     public int minAbsoluteDifference(List<Integer> nums, int x) { /*You are given a 0-indexed integer array nums and an integer x.  Find the minimum absolute difference between two elements in the array that are at least x indices apart.  In other words, find two indices i and j such that abs(i - j) >= x and abs(nums[i] - nums[j]) is minimized.  Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.  Example 1:  Input: nums = [4,3,2,4], x = 2 Output: 0 Explanation: We can select nums[0] = 4 and nums[3] = 4.  They are at least 2 indices apart, and their absolute difference is the minimum, 0.  It can be shown that 0 is the optimal answer.  Example 2:  Input: nums = [5,3,2,10,15], x = 1 Output: 1 Explanation: We can select nums[1] = 3 and nums[2] = 2. They are at least 1 index apart, and their absolute difference is the minimum, 1. It can be shown that 1 is the optimal answer.  Example 3:  Input: nums = [1,2,3,4], x = 3 Output: 3 Explanation: We can select nums[0] = 1 and nums[3] = 4. They are at least 3 indices apart, and their absolute difference is the minimum, 3. It can be shown that 3 is the optimal answer.   Constraints:  1 <= nums.length <= 10^5 1 <= nums[i] <= 10^9 0 <= x < nums.length*/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |class Solution {     public int minAbsoluteDifference(List<Integer> nums, int x) {         int min = Integer.MAX_VALUE;         int n = nums.size();         for(int i = 0; i < n; i++){             for(int j = i + x; j < n; j++){                 min = Math.min(min, Math.abs(nums.get(i) - nums.get(j)));             }         }         return min;     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |class Solution {     int minAbsoluteDifference(List<Integer> nums, int x) {         int ans = Integer.MAX_VALUE;         TreeSet<Integer> s = new TreeSet<>();         for(int i = x; i < nums.size(); ++i){             s.add(nums.get(i-x));             Integer high = s.ceiling(nums.get(i)), low = s.floor(nums.get(i));             if(high != null) ans = Math.min(ans, Math.abs(nums.get(i) - high));             if(low != null) ans = Math.min(ans, Math.abs(nums.get(i) - low));         }         return ans;     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|44 |3             |Python  |medium    |Code Llama     |IDE Extension    |You are given a 0-indexed integer array nums and an integer x.  Find the minimum absolute difference between two elements in the array that are at least x indices apart.  In other words, find two indices i and j such that abs(i - j) >= x and abs(nums[i] - nums[j]) is minimized.  Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.  Example 1:  Input: nums = [4,3,2,4], x = 2 Output: 0 Explanation: We can select nums[0] = 4 and nums[3] = 4.  They are at least 2 indices apart, and their absolute difference is the minimum, 0.  It can be shown that 0 is the optimal answer.  Example 2:  Input: nums = [5,3,2,10,15], x = 1 Output: 1 Explanation: We can select nums[1] = 3 and nums[2] = 2. They are at least 1 index apart, and their absolute difference is the minimum, 1. It can be shown that 1 is the optimal answer.  Example 3:  Input: nums = [1,2,3,4], x = 3 Output: 3 Explanation: We can select nums[0] = 1 and nums[3] = 4. They are at least 3 indices apart, and their absolute difference is the minimum, 3. It can be shown that 3 is the optimal answer.   Constraints:  1 <= nums.length <= 10^5 1 <= nums[i] <= 10^9 0 <= x < nums.length                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |class Solution:     def minAbsoluteDifference(self, nums: List[int], x: int) -> int: """You are given a 0-indexed integer array nums and an integer x.  Find the minimum absolute difference between two elements in the array that are at least x indices apart.  In other words, find two indices i and j such that abs(i - j) >= x and abs(nums[i] - nums[j]) is minimized.  Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.  Example 1:  Input: nums = [4,3,2,4], x = 2 Output: 0 Explanation: We can select nums[0] = 4 and nums[3] = 4.  They are at least 2 indices apart, and their absolute difference is the minimum, 0.  It can be shown that 0 is the optimal answer.  Example 2:  Input: nums = [5,3,2,10,15], x = 1 Output: 1 Explanation: We can select nums[1] = 3 and nums[2] = 2. They are at least 1 index apart, and their absolute difference is the minimum, 1. It can be shown that 1 is the optimal answer.  Example 3:  Input: nums = [1,2,3,4], x = 3 Output: 3 Explanation: We can select nums[0] = 1 and nums[3] = 4. They are at least 3 indices apart, and their absolute difference is the minimum, 3. It can be shown that 3 is the optimal answer.   Constraints:  1 <= nums.length <= 10^5 1 <= nums[i] <= 10^9 0 <= x < nums.length"""                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |class Solution:     def minAbsoluteDifference(self, nums: List[int], x: int) -> int:         nums.sort()         min_diff = float('inf')         for i in range(len(nums)):             if i + x < len(nums):                 min_diff = min(min_diff, abs(nums[i] - nums[i + x]))         return min_diff                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |class Solution:   def minAbsoluteDifference(self, nums: List[int], x: int) -> int:     if x == 0:       return 0      arr, best_dist = SortedList([]), float('inf')     for i in range(x, len(nums)):       arr.add(nums[i - x])       v = nums[i]        pos = arr.bisect_left(v)       if pos < len(arr):         best_dist = min(best_dist, abs(arr[pos] - v))       if pos > 0:         best_dist = min(best_dist, abs(arr[pos - 1] - v))          return best_dist                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
|45 |3             |C++     |medium    |Code Llama     |IDE Extension    |You are given a 0-indexed integer array nums and an integer x.  Find the minimum absolute difference between two elements in the array that are at least x indices apart.  In other words, find two indices i and j such that abs(i - j) >= x and abs(nums[i] - nums[j]) is minimized.  Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.  Example 1:  Input: nums = [4,3,2,4], x = 2 Output: 0 Explanation: We can select nums[0] = 4 and nums[3] = 4.  They are at least 2 indices apart, and their absolute difference is the minimum, 0.  It can be shown that 0 is the optimal answer.  Example 2:  Input: nums = [5,3,2,10,15], x = 1 Output: 1 Explanation: We can select nums[1] = 3 and nums[2] = 2. They are at least 1 index apart, and their absolute difference is the minimum, 1. It can be shown that 1 is the optimal answer.  Example 3:  Input: nums = [1,2,3,4], x = 3 Output: 3 Explanation: We can select nums[0] = 1 and nums[3] = 4. They are at least 3 indices apart, and their absolute difference is the minimum, 3. It can be shown that 3 is the optimal answer.   Constraints:  1 <= nums.length <= 10^5 1 <= nums[i] <= 10^9 0 <= x < nums.length                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |class Solution { public:     int minAbsoluteDifference(vector<int>& nums, int x) { /*You are given a 0-indexed integer array nums and an integer x.  Find the minimum absolute difference between two elements in the array that are at least x indices apart.  In other words, find two indices i and j such that abs(i - j) >= x and abs(nums[i] - nums[j]) is minimized.  Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.   Constraints:  1 <= nums.length <= 10^5 1 <= nums[i] <= 10^9 0 <= x < nums.length*/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |class Solution { public:     int minAbsoluteDifference(vector<int>& nums, int x) {         int n=nums.size();         int min=INT_MAX;         int i=0;         int j=0;         for(i=0;i<n;i++){             for(j=i+1;j<n;j++){                 if(abs(nums[i]-nums[j])<min && abs(i-j)>=x){                     min=abs(nums[i]-nums[j]);                 }             }         }         return min;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |class Solution { public:     int minAbsoluteDifference(vector<int>& nums, int x) {         int ans = INT_MAX;         set<int> s;         for(int i = x; i < nums.size(); ++i){             s.insert(nums[i-x]);             auto it = s.upper_bound(nums[i]);             if(it != s.end()) ans = min(ans, abs(nums[i] - *it));             if(it != s.begin()) ans = min(ans, abs(nums[i] - *prev(it)));         }         return ans;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|46 |4             |Java    |medium    |Code Llama     |IDE Extension    |You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.  Return the head of the linked list after doubling it.  Example 1:  Input: head = [1,8,9] Output: [3,7,8] Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.  Example 2:  Input: head = [9,9,9] Output: [1,9,9,8] Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998.   Constraints:  The number of nodes in the list is in the range [1, 10^4] 0 <= Node.val <= 9 The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |/*You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.  Return the head of the linked list after doubling it.  Example 1:  Input: head = [1,8,9] Output: [3,7,8] Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.  Example 2:  Input: head = [9,9,9] Output: [1,9,9,8] Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998.   Constraints:  The number of nodes in the list is in the range [1, 10^4] 0 <= Node.val <= 9 The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.*/ class Solution {     public ListNode doubleIt(ListNode head) {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |class Solution {     public ListNode doubleIt(ListNode head) {         ListNode temp = head;         ListNode prev = null;         while(temp!=null){             int val = temp.val;             temp.val = val*2;             if(temp.val>9){                 temp.val = temp.val%10;                 if(prev!=null){                     prev.val+=1;                 }             }             prev = temp;             temp = temp.next;         }         return head;     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |class Solution {     public ListNode doubleIt(ListNode head) {         if (head.val > 4)             head = new ListNode(0, head);         for(ListNode node = head; node != null; node = node.next) {             node.val = (node.val * 2) % 10;             if (node.next != null && node.next.val > 4)                 node.val++;         }         return head;     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
|47 |4             |Python  |medium    |Code Llama     |IDE Extension    |You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.  Return the head of the linked list after doubling it.  Example 1:  Input: head = [1,8,9] Output: [3,7,8] Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.  Example 2:  Input: head = [9,9,9] Output: [1,9,9,8] Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998.   Constraints:  The number of nodes in the list is in the range [1, 10^4] 0 <= Node.val <= 9 The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |#You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes. # #Return the head of the linked list after doubling it. # #Example 1: # #Input: head = [1,8,9] #Output: [3,7,8] #Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378. # #Example 2: # #Input: head = [9,9,9] #Output: [1,9,9,8] #Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998.  # #Constraints: # #The number of nodes in the list is in the range [1, 10^4] #0 <= Node.val <= 9 #The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself. class Solution:     def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |class Solution:     def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:         if head is None:             return None                  head.val = head.val * 2                  if head.next is None:             return head                  head.next = self.doubleIt(head.next)                  if head.val > 9:             head.val = head.val - 10             head.next.val = head.next.val + 1                      return head                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |class Solution:     def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:         if head.val > 4:             head = ListNode(0, head)         node = head         while node:             node.val = (node.val * 2) % 10             if node.next and node.next.val > 4:                 node.val += 1             node = node.next         return head                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
|48 |4             |C++     |medium    |Code Llama     |IDE Extension    |You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.  Return the head of the linked list after doubling it.  Example 1:  Input: head = [1,8,9] Output: [3,7,8] Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.  Example 2:  Input: head = [9,9,9] Output: [1,9,9,8] Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998.   Constraints:  The number of nodes in the list is in the range [1, 10^4] 0 <= Node.val <= 9 The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |/*You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.  Return the head of the linked list after doubling it.  Example 1:  Input: head = [1,8,9] Output: [3,7,8] Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.  Example 2:  Input: head = [9,9,9] Output: [1,9,9,8] Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998.   Constraints:  The number of nodes in the list is in the range [1, 10^4] 0 <= Node.val <= 9 The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.*/ class Solution { public:     ListNode* doubleIt(ListNode* head) {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |class Solution { public:     ListNode* doubleIt(ListNode* head) {         ListNode* temp = head;          ListNode* temp2 = head;          while(temp->next!=NULL){              temp2 = temp2->next;              temp = temp->next;          }          temp2->next = head;          temp = temp2;          while(temp->next!=NULL){              temp->val = temp->val*2;              if(temp->val>9){                  temp->val = temp->val%10;                  temp->next->val = temp->next->val+1;              }              temp = temp->next;          }          if(temp->val>9){              temp->val = temp->val%10;              temp->next = new ListNode(1);          }          return head;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |class Solution { public:     ListNode* doubleIt(ListNode* head) {         if (head->val > 4)             head = new ListNode(0, head);         for(ListNode* node = head; node; node = node->next) {             node->val = (node->val * 2) % 10;             if (node->next && node->next->val > 4)                 node->val++;         }         return head;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
|49 |5             |Java    |hard      |Code Llama     |IDE Extension    |You are given an array nums of n positive integers and an integer k.  Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:  Choose any non-empty subarray nums[l, ..., r] that you haven't chosen previously. Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index. Multiply your score by x. Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.  The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.  Return the maximum possible score after applying at most k operations.  Since the answer may be large, return it modulo 10^9 + 7.  Example 1:  Input: nums = [8,3,9,3,8], k = 2 Output: 81 Explanation: To get a score of 81, we can apply the following operations: - Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81. It can be proven that 81 is the highest score one can obtain.  Example 2:  Input: nums = [19,12,14,6,10,18], k = 3 Output: 4788 Explanation: To get a score of 4788, we can apply the following operations:  - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19. - Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788. It can be proven that 4788 is the highest score one can obtain.   Constraints:  1 <= nums.length == n <= 10^5 1 <= nums[i] <= 10^5 1 <= k <= min(n * (n + 1) / 2, 10^9) |/*You are given an array nums of n positive integers and an integer k.  Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:  Choose any non-empty subarray nums[l, ..., r] that you haven't chosen previously. Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index. Multiply your score by x. Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.  The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.  Return the maximum possible score after applying at most k operations.  Since the answer may be large, return it modulo 10^9 + 7.  Example 1:  Input: nums = [8,3,9,3,8], k = 2 Output: 81 Explanation: To get a score of 81, we can apply the following operations: - Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81. It can be proven that 81 is the highest score one can obtain.  Example 2:  Input: nums = [19,12,14,6,10,18], k = 3 Output: 4788 Explanation: To get a score of 4788, we can apply the following operations:  - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19. - Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788. It can be proven that 4788 is the highest score one can obtain.   Constraints:  1 <= nums.length == n <= 10^5 1 <= nums[i] <= 10^5 1 <= k <= min(n * (n + 1) / 2, 10^9)*/ class Solution {     public int maximumScore(List<Integer> nums, int k) {                                                               |class Solution {     public int maximumScore(List<Integer> nums, int k) {         int n = nums.size();         int[][] dp = new int[n][k + 1];         for(int i = 0; i < n; i++)             Arrays.fill(dp[i], -1);         return dfs(nums, 0, k, dp);     }     public int dfs(List<Integer> nums, int i, int k, int[][] dp){         if(i == nums.size())             return 1;         if(k == 0)             return 0;         if(dp[i][k] != -1)             return dp[i][k];         int ans = 0;         for(int j = i; j < nums.size(); j++){             ans = Math.max(ans, nums.get(j) * dfs(nums, j + 1, k - 1, dp));         }         return dp[i][k] = ans;     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |class Solution {     static final int MOD = 1000000007;      public int maximumScore(List<Integer> nums, int k) {         int n = nums.size();          int upper = Collections.max(nums) + 1;          boolean[] prime = new boolean[upper];         int[] primeScore = new int[upper];         Arrays.fill(prime, true);         prime[0] = prime[1] = false;         for (int i = 2; i < upper; i++) {             if (prime[i]) {                 for (int j = i; j < upper; j += i) {                     primeScore[j]++;                     prime[j] = false;                 }             }         }          int[] nextGreaterElement = new int[n];         Arrays.fill(nextGreaterElement, n);         Stack<Integer> s = new Stack<>();         for (int i = n - 1; i >= 0; i--) {             while (!s.empty() && primeScore[nums.get(i)] >= primeScore[nums.get(s.peek())]) {                 s.pop();             }             nextGreaterElement[i] = s.empty() ? n : s.peek();             s.push(i);         }          int[] prevGreaterOrEqualElement = new int[n];         Arrays.fill(prevGreaterOrEqualElement, -1);         s = new Stack<>();         for (int i = 0; i < n; i++) {             while (!s.empty() && primeScore[nums.get(i)] > primeScore[nums.get(s.peek())]) {                 s.pop();             }             prevGreaterOrEqualElement[i] = s.empty() ? -1 : s.peek();             s.push(i);         }          int res = 1;         int[][] tuples = new int[n][2];         for (int i = 0; i < n; i++) {             tuples[i][0] = nums.get(i);             tuples[i][1] = i;         }         Arrays.sort(tuples, new Comparator<int[]>() {             public int compare(int[] a, int[] b) {                 return b[0] - a[0];             }         });         for (int i = 0; i < n; i++) {             int num = tuples[i][0];             int idx = tuples[i][1];             int operations = Math.min((idx - prevGreaterOrEqualElement[idx]) * (nextGreaterElement[idx] - idx), k);             res = (int)((1L * res * pow(num, operations)) % MOD);             k -= operations;             if (k == 0) {                 return res;             }         }          return res;     }      public int pow(int x, int n) {         int res = 1;         while (n > 0) {             if (n % 2 == 1) {                 res = (int)((1L * res * x) % MOD);             }             x = (int)((1L * x * x) % MOD);             n /= 2;         }         return res;     } }|
|50 |5             |Python  |hard      |Code Llama     |IDE Extension    |You are given an array nums of n positive integers and an integer k.  Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:  Choose any non-empty subarray nums[l, ..., r] that you haven't chosen previously. Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index. Multiply your score by x. Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.  The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.  Return the maximum possible score after applying at most k operations.  Since the answer may be large, return it modulo 10^9 + 7.  Example 1:  Input: nums = [8,3,9,3,8], k = 2 Output: 81 Explanation: To get a score of 81, we can apply the following operations: - Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81. It can be proven that 81 is the highest score one can obtain.  Example 2:  Input: nums = [19,12,14,6,10,18], k = 3 Output: 4788 Explanation: To get a score of 4788, we can apply the following operations:  - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19. - Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788. It can be proven that 4788 is the highest score one can obtain.   Constraints:  1 <= nums.length == n <= 10^5 1 <= nums[i] <= 10^5 1 <= k <= min(n * (n + 1) / 2, 10^9) |"""You are given an array nums of n positive integers and an integer k.  Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:  Choose any non-empty subarray nums[l, ..., r] that you haven't chosen previously. Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index. Multiply your score by x. Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.  The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.  Return the maximum possible score after applying at most k operations.  Since the answer may be large, return it modulo 10^9 + 7.  Example 1:  Input: nums = [8,3,9,3,8], k = 2 Output: 81 Explanation: To get a score of 81, we can apply the following operations: - Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81. It can be proven that 81 is the highest score one can obtain.  Example 2:  Input: nums = [19,12,14,6,10,18], k = 3 Output: 4788 Explanation: To get a score of 4788, we can apply the following operations:  - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19. - Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788. It can be proven that 4788 is the highest score one can obtain.   Constraints:  1 <= nums.length == n <= 10^5 1 <= nums[i] <= 10^5 1 <= k <= min(n * (n + 1) / 2, 10^9)""" class Solution:     def maximumScore(self, nums: List[int], k: int) -> int:                                                           |class Solution:     def maximumScore(self, nums: List[int], k: int) -> int:         def prime_score(num):             prime_factors = set()             while num > 1:                 for i in range(2, num + 1):                     if num % i == 0:                         prime_factors.add(i)                         num //= i                         break             return len(prime_factors)                  n = len(nums)         dp = [[0] * n for _ in range(k + 1)]         dp[0][0] = 1         for i in range(1, k + 1):             for j in range(1, n):                 for k in range(j):                     if prime_score(nums[k]) > prime_score(nums[j]):                         dp[i][j] = max(dp[i][j], dp[i - 1][k] * nums[j])                     else:                         dp[i][j] = max(dp[i][j], dp[i][k] * nums[j])         return dp[k][n - 1] % (10 ** 9 + 7)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |class Solution:      MOD = 1000000007      def maximumScore(self, nums: List[int], k: int) -> int:         n = len(nums)          upper = max(nums) + 1          prime = [True]*upper         prime[0] = prime[1] = False         primeScore = [0]*upper         for i in range(2, upper):             if prime[i]:                 for j in range(i, upper, i):                     primeScore[j] += 1                     prime[j] = False          nextGreaterElement = [n]*n         s = []         for i in range(n - 1, -1, -1):             while s and primeScore[nums[i]] >= primeScore[nums[s[-1]]]:                 s.pop()             nextGreaterElement[i] = s[-1] if s else n             s.append(i)          prevGreaterOrEqualElement = [-1]*n         s = []         for i in range(n):             while s and primeScore[nums[i]] > primeScore[nums[s[-1]]]:                 s.pop()             prevGreaterOrEqualElement[i] = s[-1] if s else -1             s.append(i)          res = 1         tuples = [[nums[i], i] for i in range(n)]         tuples.sort(reverse=True)         for num, idx in tuples:             operations = min((idx - prevGreaterOrEqualElement[idx]) * (nextGreaterElement[idx] - idx), k)             res = (res * self.pow(num, operations)) % self.MOD             k -= operations             if k == 0:                 return res          return res      def pow(self, x: int, n: int) -> int:         res = 1         while n > 0:             if n % 2 == 1:                 res = (res * x) % self.MOD             x = (x * x) % self.MOD             n //= 2         return res                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
|51 |5             |C++     |hard      |Code Llama     |IDE Extension    |You are given an array nums of n positive integers and an integer k.  Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:  Choose any non-empty subarray nums[l, ..., r] that you haven't chosen previously. Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index. Multiply your score by x. Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.  The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.  Return the maximum possible score after applying at most k operations.  Since the answer may be large, return it modulo 10^9 + 7.  Example 1:  Input: nums = [8,3,9,3,8], k = 2 Output: 81 Explanation: To get a score of 81, we can apply the following operations: - Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81. It can be proven that 81 is the highest score one can obtain.  Example 2:  Input: nums = [19,12,14,6,10,18], k = 3 Output: 4788 Explanation: To get a score of 4788, we can apply the following operations:  - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19. - Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788. It can be proven that 4788 is the highest score one can obtain.   Constraints:  1 <= nums.length == n <= 10^5 1 <= nums[i] <= 10^5 1 <= k <= min(n * (n + 1) / 2, 10^9) |class Solution { public:     int maximumScore(vector<int>& nums, int k) { /*You are given an array nums of n positive integers and an integer k.  Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:  Choose any non-empty subarray nums[l, ..., r] that you haven't chosen previously. Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index. Multiply your score by x. Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.  The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.  Return the maximum possible score after applying at most k operations.  Since the answer may be large, return it modulo 10^9 + 7.  Example 1:  Input: nums = [8,3,9,3,8], k = 2 Output: 81 Explanation: To get a score of 81, we can apply the following operations: - Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81. It can be proven that 81 is the highest score one can obtain.  Example 2:  Input: nums = [19,12,14,6,10,18], k = 3 Output: 4788 Explanation: To get a score of 4788, we can apply the following operations:  - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19. - Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788. It can be proven that 4788 is the highest score one can obtain.   Constraints:  1 <= nums.length == n <= 10^5 1 <= nums[i] <= 10^5 1 <= k <= min(n * (n + 1) / 2, 10^9)*/                                                               |class Solution { public:     int maximumScore(vector<int>& nums, int k) {         int n = nums.size();         vector<int> primes;         for(int i = 2; i <= n; i++){             bool isPrime = true;             for(int j = 2; j <= sqrt(i); j++){                 if(i % j == 0){                     isPrime = false;                     break;                 }             }             if(isPrime){                 primes.push_back(i);             }         }         vector<int> dp(n + 1, 0);         dp[0] = 1;         for(int i = 1; i <= n; i++){             for(int j = 0; j < primes.size(); j++){                 if(primes[j] <= nums[i - 1]){                     dp[i] = (dp[i] + dp[i - 1]) % MOD;                 }             }         }         int ans = 0;         for(int i = 0; i <= n; i++){             for(int j = 0; j <= n; j++){                 if(i + j <= n){                     ans = (ans + dp[i] * dp[n - i - j] % MOD) % MOD;                 }             }         }         return ans;     }          int MOD = 1e9 + 7; };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |class Solution { public:     const int MOD = 1000000007;      int maximumScore(vector<int>& nums, int k) {         int n = nums.size();          int upper = *max_element(nums.begin(), nums.end()) + 1;          vector<bool> prime(upper, true);         prime[0] = prime[1] = false;         vector<int> primeScore(upper, 0);         for (int i = 2; i < upper; i++) {             if (prime[i]) {                 for (int j = i; j < upper; j += i) {                     primeScore[j]++;                     prime[j] = false;                 }             }         }          vector<int> nextGreaterElement(n, n);         stack<int> s;         for (int i = n - 1; i >= 0; i--) {             while (!s.empty() && primeScore[nums[i]] >= primeScore[nums[s.top()]]) {                 s.pop();             }             nextGreaterElement[i] = s.empty() ? n : s.top();             s.push(i);         }          vector<int> prevGreaterOrEqualElement(n, -1);         s = stack<int>();         for (int i = 0; i < n; i++) {             while (!s.empty() && primeScore[nums[i]] > primeScore[nums[s.top()]]) {                 s.pop();             }             prevGreaterOrEqualElement[i] = s.empty() ? -1 : s.top();             s.push(i);         }          int res = 1;         vector<pair<int, int>> tuples(n);         for (int i = 0; i < n; i++) {             tuples[i].first = nums[i];             tuples[i].second = i;         }         sort(tuples.rbegin(), tuples.rend());         for (const auto& [num, i] : tuples) {             int operations = min((i - prevGreaterOrEqualElement[i]) * (nextGreaterElement[i] - i), k);             res = (int)((1L * res * pow(num, operations)) % MOD);             k -= operations;             if (k == 0) {                 return res;             }         }          return res;     }      int pow(int x, int n) {         int res = 1;         while (n > 0) {             if (n % 2 == 1) {                 res = (int)((1L * res * x) % MOD);             }             x = (int)((1L * x * x) % MOD);             n /= 2;         }         return res;     } };                                                                                                                                                                                                                                                                                                                                                                               |
|52 |6             |Java    |hard      |Code Llama     |IDE Extension    |You are given a 0-indexed 2D integer array items of length n and an integer k.  items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.  Let's define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.  Your task is to find the maximum elegance from all subsequences of size k in items.  Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.  Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order.  Example 1:  Input: items = [[3,2],[5,1],[10,1]], k = 2 Output: 17 Explanation: In this example, we have to select a subsequence of size 2. We can select items[0] = [3,2] and items[2] = [10,1]. The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1]. Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance.   Example 2:  Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3 Output: 19 Explanation: In this example, we have to select a subsequence of size 3.  We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3].  The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3].  Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.  Example 3:  Input: items = [[1,1],[2,1],[3,1]], k = 3 Output: 7 Explanation: In this example, we have to select a subsequence of size 3.  We should select all the items.  The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1].  Hence, the maximum elegance is 6 + 1^2 = 7.     Constraints:  1 <= items.length == n <= 10^5 items[i].length == 2 items[i][0] == profit_i items[i][1] == category_i 1 <= profit_i <= 10^9 1 <= category_i <= n  1 <= k <= n                                             |/*You are given a 0-indexed 2D integer array items of length n and an integer k.  items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.  Let's define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.  Your task is to find the maximum elegance from all subsequences of size k in items.  Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.  Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order.  Example 1:  Input: items = [[3,2],[5,1],[10,1]], k = 2 Output: 17 Explanation: In this example, we have to select a subsequence of size 2. We can select items[0] = [3,2] and items[2] = [10,1]. The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1]. Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance.   Example 2:  Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3 Output: 19 Explanation: In this example, we have to select a subsequence of size 3.  We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3].  The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3].  Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.  Example 3:  Input: items = [[1,1],[2,1],[3,1]], k = 3 Output: 7 Explanation: In this example, we have to select a subsequence of size 3.  We should select all the items.  The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1].  Hence, the maximum elegance is 6 + 1^2 = 7.     Constraints:  1 <= items.length == n <= 10^5 items[i].length == 2 items[i][0] == profit_i items[i][1] == category_i 1 <= profit_i <= 10^9 1 <= category_i <= n  1 <= k <= n*/ class Solution {     public long findMaximumElegance(int[][] items, int k) {                                                                                                        |class Solution {     public long findMaximumElegance(int[][] items, int k) {         int n = items.length;         long[][] dp = new long[n + 1][k + 1];         for (int i = 1; i <= n; i++) {             int profit = items[i - 1][0];             int category = items[i - 1][1];             for (int j = 1; j <= k; j++) {                 dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - 1] + profit);                 if (category != items[i - 1][1]) {                     dp[i][j] = Math.max(dp[i][j], dp[i - 1][j] + profit);                 }             }         }         long max = 0;         for (int i = 1; i <= k; i++) {             max = Math.max(max, dp[n][i]);         }         return max;     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |class Solution {     public long findMaximumElegance(int[][] A, int k) {         Arrays.sort(A, (a, b) -> b[0] - a[0]);         long res = 0, cur = 0;         List<Integer> dup = new ArrayList<>();         Set<Integer> seen = new HashSet<>();         for (int i = 0; i < A.length; ++i) {             if (i < k) {                 if (seen.contains(A[i][1])) {                     dup.add(A[i][0]);                 }                 cur += A[i][0];             } else if (!seen.contains(A[i][1])) {                 if (dup.isEmpty()) break;                 cur += A[i][0] - dup.remove(dup.size() - 1);             }             seen.add(A[i][1]);             res = Math.max(res, cur + 1L * seen.size() * seen.size());         }         return res;     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|53 |6             |Python  |hard      |Code Llama     |IDE Extension    |You are given a 0-indexed 2D integer array items of length n and an integer k.  items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.  Let's define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.  Your task is to find the maximum elegance from all subsequences of size k in items.  Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.  Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order.  Example 1:  Input: items = [[3,2],[5,1],[10,1]], k = 2 Output: 17 Explanation: In this example, we have to select a subsequence of size 2. We can select items[0] = [3,2] and items[2] = [10,1]. The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1]. Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance.   Example 2:  Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3 Output: 19 Explanation: In this example, we have to select a subsequence of size 3.  We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3].  The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3].  Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.  Example 3:  Input: items = [[1,1],[2,1],[3,1]], k = 3 Output: 7 Explanation: In this example, we have to select a subsequence of size 3.  We should select all the items.  The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1].  Hence, the maximum elegance is 6 + 1^2 = 7.     Constraints:  1 <= items.length == n <= 10^5 items[i].length == 2 items[i][0] == profit_i items[i][1] == category_i 1 <= profit_i <= 10^9 1 <= category_i <= n  1 <= k <= n                                             |"""You are given a 0-indexed 2D integer array items of length n and an integer k.  items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.  Let's define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.  Your task is to find the maximum elegance from all subsequences of size k in items.  Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.  Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order.  Example 1:  Input: items = [[3,2],[5,1],[10,1]], k = 2 Output: 17 Explanation: In this example, we have to select a subsequence of size 2. We can select items[0] = [3,2] and items[2] = [10,1]. The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1]. Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance.   Example 2:  Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3 Output: 19 Explanation: In this example, we have to select a subsequence of size 3.  We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3].  The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3].  Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.  Example 3:  Input: items = [[1,1],[2,1],[3,1]], k = 3 Output: 7 Explanation: In this example, we have to select a subsequence of size 3.  We should select all the items.  The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1].  Hence, the maximum elegance is 6 + 1^2 = 7.     Constraints:  1 <= items.length == n <= 10^5 items[i].length == 2 items[i][0] == profit_i items[i][1] == category_i 1 <= profit_i <= 10^9 1 <= category_i <= n  1 <= k <= n""" class Solution:     def findMaximumElegance(self, items: List[List[int]], k: int) -> int:                                                                                         |class Solution:     def findMaximumElegance(self, items: List[List[int]], k: int) -> int:         n = len(items)         profit = [0] * n         category = [0] * n         for i in range(n):             profit[i] = items[i][0]             category[i] = items[i][1]         profit.sort(reverse=True)         category.sort(reverse=True)         profit = profit[:k]         category = category[:k]                  profit_set = set(profit)         category_set = set(category)                  profit_sum = sum(profit)         category_sum = sum(category)                  return profit_sum + category_sum ** 2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |class Solution:     def findMaximumElegance(self, items: List[List[int]], k: int) -> int:         items = sorted(items, key=lambda v: -v[0])         res = cur = 0         A = []         seen = set()         for i, (p, c) in enumerate(items):             if i < k:                 if c in seen:                     A.append(p)                 cur += p             elif c not in seen:                 if not A: break                 cur += p - A.pop()             seen.add(c)             res = max(res, cur + len(seen) * len(seen))         return res                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
|54 |6             |C++     |hard      |Code Llama     |IDE Extension    |You are given a 0-indexed 2D integer array items of length n and an integer k.  items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.  Let's define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.  Your task is to find the maximum elegance from all subsequences of size k in items.  Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.  Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order.  Example 1:  Input: items = [[3,2],[5,1],[10,1]], k = 2 Output: 17 Explanation: In this example, we have to select a subsequence of size 2. We can select items[0] = [3,2] and items[2] = [10,1]. The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1]. Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance.   Example 2:  Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3 Output: 19 Explanation: In this example, we have to select a subsequence of size 3.  We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3].  The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3].  Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.  Example 3:  Input: items = [[1,1],[2,1],[3,1]], k = 3 Output: 7 Explanation: In this example, we have to select a subsequence of size 3.  We should select all the items.  The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1].  Hence, the maximum elegance is 6 + 1^2 = 7.     Constraints:  1 <= items.length == n <= 10^5 items[i].length == 2 items[i][0] == profit_i items[i][1] == category_i 1 <= profit_i <= 10^9 1 <= category_i <= n  1 <= k <= n                                             |class Solution { public:     long long findMaximumElegance(vector<vector<int>>& items, int k) { /*You are given a 0-indexed 2D integer array items of length n and an integer k.  items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.  Let's define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.  Your task is to find the maximum elegance from all subsequences of size k in items.  Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.  Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order.  Example 1:  Input: items = [[3,2],[5,1],[10,1]], k = 2 Output: 17 Explanation: In this example, we have to select a subsequence of size 2. We can select items[0] = [3,2] and items[2] = [10,1]. The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1]. Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance.   Example 2:  Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3 Output: 19 Explanation: In this example, we have to select a subsequence of size 3.  We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3].  The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3].  Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.  Example 3:  Input: items = [[1,1],[2,1],[3,1]], k = 3 Output: 7 Explanation: In this example, we have to select a subsequence of size 3.  We should select all the items.  The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1].  Hence, the maximum elegance is 6 + 1^2 = 7.     Constraints:  1 <= items.length == n <= 10^5 items[i].length == 2 items[i][0] == profit_i items[i][1] == category_i 1 <= profit_i <= 10^9 1 <= category_i <= n  1 <= k <= n*/                                                                                     |class Solution { public:     long long findMaximumElegance(vector<vector<int>>& items, int k) {         int n = items.size();         vector<int> profit(n);         vector<int> category(n);                  for(int i = 0; i < n; i++){             profit[i] = items[i][0];             category[i] = items[i][1];         }                  sort(profit.begin(), profit.end());         sort(category.begin(), category.end());                  int max_elegance = 0;                  for(int i = 0; i < n; i++){             int j = i + k - 1;             if(j >= n) break;                          int total_profit = profit[j] - profit[i];             int distinct_categories = upper_bound(category.begin(), category.end(), category[j]) - upper_bound(category.begin(), category.end(), category[i]);                          max_elegance = max(max_elegance, total_profit + distinct_categories * distinct_categories);         }                  return max_elegance;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |class Solution { public:     long long findMaximumElegance(vector<vector<int>>& A, int k) {         sort(A.begin(), A.end(), [](const vector<int>& a, const vector<int>& b) {             return a[0] > b[0];         });         long long res = 0, cur = 0;         vector<int> dup;         unordered_set<int> seen;         for (int i = 0; i < A.size(); ++i) {             if (i < k) {                 if (seen.count(A[i][1])) {                     dup.push_back(A[i][0]);                 }                 cur += A[i][0];             } else if (seen.find(A[i][1]) == seen.end()) {                 if (dup.empty()) break;                 cur += A[i][0] - dup.back();                 dup.pop_back();             }             seen.insert(A[i][1]);             res = fmax(res, cur + 1L * seen.size() * seen.size());         }         return res;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
|55 |1             |Java    |easy      |CodeWhisperer  |IDE Extension    |You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.  Return the maximum sum or -1 if no such pair exists.  Example 1:  Input: nums = [51,71,17,24,42] Output: 88 Explanation:  For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88.  For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66. It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.  Example 2:  Input: nums = [1,2,3,4] Output: -1 Explanation: No pair exists in nums with equal maximum digits.  Constraints:  2 <= nums.length <= 100 1 <= nums[i] <= 10^4                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |public class Solution{     public int maxSum(int[] nums) { /*You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.  Return the maximum sum or -1 if no such pair exists.  Example 1:  Input: nums = [51,71,17,24,42] Output: 88 Explanation:  For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88.  For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66. It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.  Example 2:  Input: nums = [1,2,3,4] Output: -1 Explanation: No pair exists in nums with equal maximum digits.   Constraints:  2 <= nums.length <= 100 1 <= nums[i] <= 10^4 */                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |public class Solution{     public int maxSum(int[] nums) {         int max = -1;         for(int i = 0; i < nums.length; i++) {             for(int j = i + 1; j < nums.length;                     j++) {                 if(nums[i] % 10 == nums[j] % 10) {                     max = Math.max(max, nums[i] + nums[j]);                 }             }                      }         return max;              }      }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |class Solution {     public int maxSum(int[] nums) {     int ans = -1;     Map<Integer,List<Integer>> ump = new HashMap<>();     for(int i = 0; i < nums.length; ++i){         int t = nums[i], maxDigit = 0;         while(t != 0){ //evaluate max digit in the number             maxDigit = Math.max(t%10, maxDigit);             t = t/10;         }         if(!ump.containsKey(maxDigit)) ump.put(maxDigit, new ArrayList<>());         ump.get(maxDigit).add(nums[i]); // add the number to the map      }     for(Map.Entry<Integer, List<Integer>> entry: ump.entrySet()){         entry.getValue().sort(Comparator.reverseOrder()); //to find max two number in each max digit          if(entry.getValue().size() >= 2) ans = Math.max(ans, entry.getValue().get(0) + entry.getValue().get(1)); //sum max two number and take max     }     return ans;     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
|56 |1             |Python  |easy      |CodeWhisperer  |IDE Extension    |You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.  Return the maximum sum or -1 if no such pair exists.  Example 1:  Input: nums = [51,71,17,24,42] Output: 88 Explanation:  For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88.  For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66. It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.  Example 2:  Input: nums = [1,2,3,4] Output: -1 Explanation: No pair exists in nums with equal maximum digits.  Constraints:  2 <= nums.length <= 100 1 <= nums[i] <= 10^4                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |class Solution:     def maxSum(self, nums: List[int]) -> int: """You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.  Return the maximum sum or -1 if no such pair exists.  Example 1:  Input: nums = [51,71,17,24,42] Output: 88 Explanation:  For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88.  For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66. It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.  Example 2:  Input: nums = [1,2,3,4] Output: -1 Explanation: No pair exists in nums with equal maximum digits.   Constraints:  2 <= nums.length <= 100 1 <= nums[i] <= 10^4"""                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |class Solution:     def maxSum(self, nums: List[int]) -> int:         nums.sort(reverse=True)         for i in range(len(nums)-1):             if nums[i]%10==nums[i+1]%10:                 return nums[i]+nums[i+1]         return -1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |class Solution:     def maxSum(self, nums: List[int]) -> int:         max_by_digit = defaultdict(int)         max_sum = -1          for num in nums:             digit = max(str(num))              if digit in max_by_digit:                 max_sum = max(max_sum, max_by_digit[digit] + num)              max_by_digit[digit] = max(max_by_digit[digit], num)          return max_sum                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
|57 |1             |C++     |easy      |CodeWhisperer  |IDE Extension    |You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.  Return the maximum sum or -1 if no such pair exists.  Example 1:  Input: nums = [51,71,17,24,42] Output: 88 Explanation:  For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88.  For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66. It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.  Example 2:  Input: nums = [1,2,3,4] Output: -1 Explanation: No pair exists in nums with equal maximum digits.  Constraints:  2 <= nums.length <= 100 1 <= nums[i] <= 10^4                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |/*You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.  Return the maximum sum or -1 if no such pair exists.  Example 1:  Input: nums = [51,71,17,24,42] Output: 88 Explanation:  For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88.  For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66. It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.  Example 2:  Input: nums = [1,2,3,4] Output: -1 Explanation: No pair exists in nums with equal maximum digits.  Constraints:  2 <= nums.length <= 100 1 <= nums[i] <= 10^4 */ class Solution { public:     int maxSum(vector<int>& nums) {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |class Solution { public:     int maxSum(vector<int>& nums) {         int ans = -1;         int n = nums.size();         for(int i = 0; i < n; i++){             for(int j = i + 1; j < n; j++){                 if(nums[i] % 10 == nums[j] % 10){                     ans = max(ans, nums[i] + nums[j]);                     break;                 }             }         }         return ans;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |class Solution {     public:         int maxSum(vector<int>& nums) {         int res = -1, max_num[10] = {};         for (auto num : nums) {             int max_d = 0;             for (int v = num; v; v /= 10)                 max_d = max(max_d, v % 10);             if (max_num[max_d])                 res = max(res, max_num[max_d] + num);             max_num[max_d] = max(max_num[max_d], num);         }         return res;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|58 |2             |Java    |easy      |CodeWhisperer  |IDE Extension    |Your laptop keyboard is faulty, and whenever you type a character 'i' on it, it reverses the string that you have written. Typing other characters works as expected.  You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.  Return the final string that will be present on your laptop screen.  Example 1:  Input: s = "string" Output: "rtsng" Explanation:  After typing first character, the text on the screen is "s". After the second character, the text is "st".  After the third character, the text is "str". Since the fourth character is an 'i', the text gets reversed and becomes "rts". After the fifth character, the text is "rtsn".  After the sixth character, the text is "rtsng".  Therefore, we return "rtsng".  Example 2:  Input: s = "poiinter" Output: "ponter" Explanation:  After the first character, the text on the screen is "p". After the second character, the text is "po".  Since the third character you type is an 'i', the text gets reversed and becomes "op".  Since the fourth character you type is an 'i', the text gets reversed and becomes "po". After the fifth character, the text is "pon". After the sixth character, the text is "pont".  After the seventh character, the text is "ponte".  After the eighth character, the text is "ponter".  Therefore, we return "ponter".   Constraints:  1 <= s.length <= 100 s consists of lowercase English letters. s[0] != 'i'                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |public class Solution {     public String finalString(String s) {         /*          * Your laptop keyboard is faulty, and whenever you type a character 'i' on it, it reverses the string that you have written. Typing other characters works as expected.  You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.  Return the final string that will be present on your laptop screen.  Example 1:  Input: s = "string" Output: "rtsng" Explanation:  After typing first character, the text on the screen is "s". After the second character, the text is "st".  After the third character, the text is "str". Since the fourth character is an 'i', the text gets reversed and becomes "rts". After the fifth character, the text is "rtsn".  After the sixth character, the text is "rtsng".  Therefore, we return "rtsng".  Example 2:  Input: s = "poiinter" Output: "ponter" Explanation:  After the first character, the text on the screen is "p". After the second character, the text is "po".  Since the third character you type is an 'i', the text gets reversed and becomes "op".  Since the fourth character you type is an 'i', the text gets reversed and becomes "po". After the fifth character, the text is "pon". After the sixth character, the text is "pont".  After the seventh character, the text is "ponte".  After the eighth character, the text is "ponter".  Therefore, we return "ponter".   Constraints:  1 <= s.length <= 100 s consists of lowercase English letters. s[0] != 'i'  */                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |public class Solution {     public String finalString(String s) {         StringBuilder sb = new StringBuilder();         for (int i = 0; i < s.length(); i++) {             char c = s.charAt(i);             if (c == 'i') {                 sb.append(s.substring(i));                 break;             }             sb.append(c);         }         return sb.toString();              }      }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |class Solution {     public String finalString(String s) {         StringBuilder nm=new StringBuilder();         for(char c:s.toCharArray())         {             if(c=='i')             {                 nm.reverse();             }             else             {                 nm.append(c);             }         }         return nm.toString();     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|59 |2             |Python  |easy      |CodeWhisperer  |IDE Extension    |Your laptop keyboard is faulty, and whenever you type a character 'i' on it, it reverses the string that you have written. Typing other characters works as expected.  You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.  Return the final string that will be present on your laptop screen.  Example 1:  Input: s = "string" Output: "rtsng" Explanation:  After typing first character, the text on the screen is "s". After the second character, the text is "st".  After the third character, the text is "str". Since the fourth character is an 'i', the text gets reversed and becomes "rts". After the fifth character, the text is "rtsn".  After the sixth character, the text is "rtsng".  Therefore, we return "rtsng".  Example 2:  Input: s = "poiinter" Output: "ponter" Explanation:  After the first character, the text on the screen is "p". After the second character, the text is "po".  Since the third character you type is an 'i', the text gets reversed and becomes "op".  Since the fourth character you type is an 'i', the text gets reversed and becomes "po". After the fifth character, the text is "pon". After the sixth character, the text is "pont".  After the seventh character, the text is "ponte".  After the eighth character, the text is "ponter".  Therefore, we return "ponter".   Constraints:  1 <= s.length <= 100 s consists of lowercase English letters. s[0] != 'i'                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |class Solution:     def finalString(self, s: str) -> str: """Your laptop keyboard is faulty, and whenever you type a character 'i' on it, it reverses the string that you have written. Typing other characters works as expected.  You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.  Return the final string that will be present on your laptop screen.  Example 1:  Input: s = "string" Output: "rtsng" Explanation:  After typing first character, the text on the screen is "s". After the second character, the text is "st".  After the third character, the text is "str". Since the fourth character is an 'i', the text gets reversed and becomes "rts". After the fifth character, the text is "rtsn".  After the sixth character, the text is "rtsng".  Therefore, we return "rtsng".  Example 2:  Input: s = "poiinter" Output: "ponter" Explanation:  After the first character, the text on the screen is "p". After the second character, the text is "po".  Since the third character you type is an 'i', the text gets reversed and becomes "op".  Since the fourth character you type is an 'i', the text gets reversed and becomes "po". After the fifth character, the text is "pon". After the sixth character, the text is "pont".  After the seventh character, the text is "ponte".  After the eighth character, the text is "ponter".  Therefore, we return "ponter".   Constraints:  1 <= s.length <= 100 s consists of lowercase English letters. s[0] != 'i'"""                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |class Solution:     def finalString(self, s: str) -> str:         ans = ""         for i in range(len(s)):             if s[i] == 'i':                 ans = ans[:-1]             else:                 ans += s[i]         return ans                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |class Solution:     def finalString(self, s: str) -> str:         while "i" in s:             index=s.index("i")              #first half and second half             first=s[:index][::-1]             second=s[index+1:]              s="".join([first,second])         return s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|60 |2             |C++     |easy      |CodeWhisperer  |IDE Extension    |Your laptop keyboard is faulty, and whenever you type a character 'i' on it, it reverses the string that you have written. Typing other characters works as expected.  You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.  Return the final string that will be present on your laptop screen.  Example 1:  Input: s = "string" Output: "rtsng" Explanation:  After typing first character, the text on the screen is "s". After the second character, the text is "st".  After the third character, the text is "str". Since the fourth character is an 'i', the text gets reversed and becomes "rts". After the fifth character, the text is "rtsn".  After the sixth character, the text is "rtsng".  Therefore, we return "rtsng".  Example 2:  Input: s = "poiinter" Output: "ponter" Explanation:  After the first character, the text on the screen is "p". After the second character, the text is "po".  Since the third character you type is an 'i', the text gets reversed and becomes "op".  Since the fourth character you type is an 'i', the text gets reversed and becomes "po". After the fifth character, the text is "pon". After the sixth character, the text is "pont".  After the seventh character, the text is "ponte".  After the eighth character, the text is "ponter".  Therefore, we return "ponter".   Constraints:  1 <= s.length <= 100 s consists of lowercase English letters. s[0] != 'i'                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |class Solution { public:     string finalString(string s) { /*Your laptop keyboard is faulty, and whenever you type a character 'i' on it, it reverses the string that you have written. Typing other characters works as expected.  You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.  Return the final string that will be present on your laptop screen.  Example 1:  Input: s = "string" Output: "rtsng" Explanation:  After typing first character, the text on the screen is "s". After the second character, the text is "st".  After the third character, the text is "str". Since the fourth character is an 'i', the text gets reversed and becomes "rts". After the fifth character, the text is "rtsn".  After the sixth character, the text is "rtsng".  Therefore, we return "rtsng".  Example 2:  Input: s = "poiinter" Output: "ponter" Explanation:  After the first character, the text on the screen is "p". After the second character, the text is "po".  Since the third character you type is an 'i', the text gets reversed and becomes "op".  Since the fourth character you type is an 'i', the text gets reversed and becomes "po". After the fifth character, the text is "pon". After the sixth character, the text is "pont".  After the seventh character, the text is "ponte".  After the eighth character, the text is "ponter".  Therefore, we return "ponter".   Constraints:  1 <= s.length <= 100 s consists of lowercase English letters. s[0] != 'i'*/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |class Solution { public:     string finalString(string s) {         string ans="";         for(int i=0;i<s.length();i++){             if(s[i]=='i'){                 reverse(ans.begin(),ans.end());                 ans="";                 continue;             }             ans+=s[i];         }         return ans;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |class Solution { public:     string finalString(const string &s) {         string a, b;         for (char ch : s)             if (ch == 'i')                 swap(a, b);             else                 a += ch;         return string(rbegin(b), rend(b)) + a;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
|61 |3             |Java    |medium    |CodeWhisperer  |IDE Extension    |You are given a 0-indexed integer array nums and an integer x.  Find the minimum absolute difference between two elements in the array that are at least x indices apart.  In other words, find two indices i and j such that abs(i - j) >= x and abs(nums[i] - nums[j]) is minimized.  Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.  Example 1:  Input: nums = [4,3,2,4], x = 2 Output: 0 Explanation: We can select nums[0] = 4 and nums[3] = 4.  They are at least 2 indices apart, and their absolute difference is the minimum, 0.  It can be shown that 0 is the optimal answer.  Example 2:  Input: nums = [5,3,2,10,15], x = 1 Output: 1 Explanation: We can select nums[1] = 3 and nums[2] = 2. They are at least 1 index apart, and their absolute difference is the minimum, 1. It can be shown that 1 is the optimal answer.  Example 3:  Input: nums = [1,2,3,4], x = 3 Output: 3 Explanation: We can select nums[0] = 1 and nums[3] = 4. They are at least 3 indices apart, and their absolute difference is the minimum, 3. It can be shown that 3 is the optimal answer.   Constraints:  1 <= nums.length <= 10^5 1 <= nums[i] <= 10^9 0 <= x < nums.length                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |class Solution {     public int minAbsoluteDifference(List<Integer> nums, int x) {         /*          * You are given a 0-indexed integer array nums and an integer x.  Find the minimum absolute difference between two elements in the array that are at least x indices apart.  In other words, find two indices i and j such that abs(i - j) >= x and abs(nums[i] - nums[j]) is minimized.  Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.  Example 1:  Input: nums = [4,3,2,4], x = 2 Output: 0 Explanation: We can select nums[0] = 4 and nums[3] = 4.  They are at least 2 indices apart, and their absolute difference is the minimum, 0.  It can be shown that 0 is the optimal answer.  Example 2:  Input: nums = [5,3,2,10,15], x = 1 Output: 1 Explanation: We can select nums[1] = 3 and nums[2] = 2. They are at least 1 index apart, and their absolute difference is the minimum, 1. It can be shown that 1 is the optimal answer.  Example 3:  Input: nums = [1,2,3,4], x = 3 Output: 3 Explanation: We can select nums[0] = 1 and nums[3] = 4. They are at least 3 indices apart, and their absolute difference is the minimum, 3. It can be shown that 3 is the optimal answer.   Constraints:  1 <= nums.length <= 10^5 1 <= nums[i] <= 10^9 0 <= x < nums.length  */                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |class Solution {     public int minAbsoluteDifference(List<Integer> nums, int x) {         int min = Integer.MAX_VALUE;         int n = nums.size();         for (int i = 0; i < n; i++) {             for (int j = i + 1; j < n; j++) {                 if (Math.abs(i - j) >= x) {                     min = Math.min(min, Math.abs(nums.get(i) - nums.get(j)));                 }             }         }         return min;              }      }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |class Solution {     int minAbsoluteDifference(List<Integer> nums, int x) {         int ans = Integer.MAX_VALUE;         TreeSet<Integer> s = new TreeSet<>();         for(int i = x; i < nums.size(); ++i){             s.add(nums.get(i-x));             Integer high = s.ceiling(nums.get(i)), low = s.floor(nums.get(i));             if(high != null) ans = Math.min(ans, Math.abs(nums.get(i) - high));             if(low != null) ans = Math.min(ans, Math.abs(nums.get(i) - low));         }         return ans;     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|62 |3             |Python  |medium    |CodeWhisperer  |IDE Extension    |You are given a 0-indexed integer array nums and an integer x.  Find the minimum absolute difference between two elements in the array that are at least x indices apart.  In other words, find two indices i and j such that abs(i - j) >= x and abs(nums[i] - nums[j]) is minimized.  Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.  Example 1:  Input: nums = [4,3,2,4], x = 2 Output: 0 Explanation: We can select nums[0] = 4 and nums[3] = 4.  They are at least 2 indices apart, and their absolute difference is the minimum, 0.  It can be shown that 0 is the optimal answer.  Example 2:  Input: nums = [5,3,2,10,15], x = 1 Output: 1 Explanation: We can select nums[1] = 3 and nums[2] = 2. They are at least 1 index apart, and their absolute difference is the minimum, 1. It can be shown that 1 is the optimal answer.  Example 3:  Input: nums = [1,2,3,4], x = 3 Output: 3 Explanation: We can select nums[0] = 1 and nums[3] = 4. They are at least 3 indices apart, and their absolute difference is the minimum, 3. It can be shown that 3 is the optimal answer.   Constraints:  1 <= nums.length <= 10^5 1 <= nums[i] <= 10^9 0 <= x < nums.length                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |class Solution:     def minAbsoluteDifference(self, nums: List[int], x: int) -> int: """You are given a 0-indexed integer array nums and an integer x.  Find the minimum absolute difference between two elements in the array that are at least x indices apart.  In other words, find two indices i and j such that abs(i - j) >= x and abs(nums[i] - nums[j]) is minimized.  Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.  Example 1:  Input: nums = [4,3,2,4], x = 2 Output: 0 Explanation: We can select nums[0] = 4 and nums[3] = 4.  They are at least 2 indices apart, and their absolute difference is the minimum, 0.  It can be shown that 0 is the optimal answer.  Example 2:  Input: nums = [5,3,2,10,15], x = 1 Output: 1 Explanation: We can select nums[1] = 3 and nums[2] = 2. They are at least 1 index apart, and their absolute difference is the minimum, 1. It can be shown that 1 is the optimal answer.  Example 3:  Input: nums = [1,2,3,4], x = 3 Output: 3 Explanation: We can select nums[0] = 1 and nums[3] = 4. They are at least 3 indices apart, and their absolute difference is the minimum, 3. It can be shown that 3 is the optimal answer.   Constraints:  1 <= nums.length <= 10^5 1 <= nums[i] <= 10^9 0 <= x < nums.length """                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |class Solution:     def minAbsoluteDifference(self, nums: List[int], x: int) -> int:         nums.sort()         ans = float('inf')         for i in range(len(nums)):             j = bisect_left(nums, nums[i] + x)             if j < len(nums):                 ans = min(ans, nums[j] - nums[i])             if i + 1 < len(nums):                 ans = min(ans, nums[i + 1] - nums[i])         return ans                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |class Solution:   def minAbsoluteDifference(self, nums: List[int], x: int) -> int:     if x == 0:       return 0      arr, best_dist = SortedList([]), float('inf')     for i in range(x, len(nums)):       arr.add(nums[i - x])       v = nums[i]        pos = arr.bisect_left(v)       if pos < len(arr):         best_dist = min(best_dist, abs(arr[pos] - v))       if pos > 0:         best_dist = min(best_dist, abs(arr[pos - 1] - v))          return best_dist                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
|63 |3             |C++     |medium    |CodeWhisperer  |IDE Extension    |You are given a 0-indexed integer array nums and an integer x.  Find the minimum absolute difference between two elements in the array that are at least x indices apart.  In other words, find two indices i and j such that abs(i - j) >= x and abs(nums[i] - nums[j]) is minimized.  Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.  Example 1:  Input: nums = [4,3,2,4], x = 2 Output: 0 Explanation: We can select nums[0] = 4 and nums[3] = 4.  They are at least 2 indices apart, and their absolute difference is the minimum, 0.  It can be shown that 0 is the optimal answer.  Example 2:  Input: nums = [5,3,2,10,15], x = 1 Output: 1 Explanation: We can select nums[1] = 3 and nums[2] = 2. They are at least 1 index apart, and their absolute difference is the minimum, 1. It can be shown that 1 is the optimal answer.  Example 3:  Input: nums = [1,2,3,4], x = 3 Output: 3 Explanation: We can select nums[0] = 1 and nums[3] = 4. They are at least 3 indices apart, and their absolute difference is the minimum, 3. It can be shown that 3 is the optimal answer.   Constraints:  1 <= nums.length <= 10^5 1 <= nums[i] <= 10^9 0 <= x < nums.length                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |class Solution { public:     int minAbsoluteDifference(vector<int>& nums, int x) { /*You are given a 0-indexed integer array nums and an integer x.  Find the minimum absolute difference between two elements in the array that are at least x indices apart.  In other words, find two indices i and j such that abs(i - j) >= x and abs(nums[i] - nums[j]) is minimized.  Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.  Example 1:  Input: nums = [4,3,2,4], x = 2 Output: 0 Explanation: We can select nums[0] = 4 and nums[3] = 4.  They are at least 2 indices apart, and their absolute difference is the minimum, 0.  It can be shown that 0 is the optimal answer.  Example 2:  Input: nums = [5,3,2,10,15], x = 1 Output: 1 Explanation: We can select nums[1] = 3 and nums[2] = 2. They are at least 1 index apart, and their absolute difference is the minimum, 1. It can be shown that 1 is the optimal answer.  Example 3:  Input: nums = [1,2,3,4], x = 3 Output: 3 Explanation: We can select nums[0] = 1 and nums[3] = 4. They are at least 3 indices apart, and their absolute difference is the minimum, 3. It can be shown that 3 is the optimal answer.   Constraints:  1 <= nums.length <= 10^5 1 <= nums[i] <= 10^9 0 <= x < nums.length */                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |class Solution { public:     int minAbsoluteDifference(vector<int>& nums, int x) {         int n = nums.size();         int ans = INT_MAX;         for(int i = 0; i < n; i++){             for(int j = i + 1; j < n; j++){                 if(abs(nums[i] - nums[j]) >= x){                     ans = min(ans, abs(nums[i] - nums[j]));                     break;                 }             }         }         return ans;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |class Solution { public:     int minAbsoluteDifference(vector<int>& nums, int x) {         int ans = INT_MAX;         set<int> s;         for(int i = x; i < nums.size(); ++i){             s.insert(nums[i-x]);             auto it = s.upper_bound(nums[i]);             if(it != s.end()) ans = min(ans, abs(nums[i] - *it));             if(it != s.begin()) ans = min(ans, abs(nums[i] - *prev(it)));         }         return ans;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|64 |4             |Java    |medium    |CodeWhisperer  |IDE Extension    |You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.  Return the head of the linked list after doubling it.  Example 1:  Input: head = [1,8,9] Output: [3,7,8] Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.  Example 2:  Input: head = [9,9,9] Output: [1,9,9,8] Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998.   Constraints:  The number of nodes in the list is in the range [1, 10^4] 0 <= Node.val <= 9 The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |class Solution {     public ListNode doubleIt(ListNode head) { /*  *You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.  Return the head of the linked list after doubling it.  Example 1:  Input: head = [1,8,9] Output: [3,7,8] Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.  Example 2:  Input: head = [9,9,9] Output: [1,9,9,8] Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998.   Constraints:  The number of nodes in the list is in the range [1, 10^4] 0 <= Node.val <= 9 The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself. */                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |class Solution {     public ListNode doubleIt(ListNode head) {         ListNode curr = head;         while (curr != null) {             curr.val *= 2;             curr = curr.next;         }         return head;              }      }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |class Solution {     public ListNode doubleIt(ListNode head) {         if (head.val > 4)             head = new ListNode(0, head);         for(ListNode node = head; node != null; node = node.next) {             node.val = (node.val * 2) % 10;             if (node.next != null && node.next.val > 4)                 node.val++;         }         return head;     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
|65 |4             |Python  |medium    |CodeWhisperer  |IDE Extension    |You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.  Return the head of the linked list after doubling it.  Example 1:  Input: head = [1,8,9] Output: [3,7,8] Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.  Example 2:  Input: head = [9,9,9] Output: [1,9,9,8] Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998.   Constraints:  The number of nodes in the list is in the range [1, 10^4] 0 <= Node.val <= 9 The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |class Solution:     def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]: """You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.  Return the head of the linked list after doubling it.  Example 1:  Input: head = [1,8,9] Output: [3,7,8] Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.  Example 2:  Input: head = [9,9,9] Output: [1,9,9,8] Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998.   Constraints:  The number of nodes in the list is in the range [1, 10^4] 0 <= Node.val <= 9 The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself."""                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |class Solution:     def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:         if not head:             return head         if not head.next:             head.val *= 2             return head         prev = head         curr = head.next         while curr:             curr.val *= 2             prev = curr             curr = curr.next         prev.val *= 2         return head                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |class Solution:     def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:         if head.val > 4:             head = ListNode(0, head)         node = head         while node:             node.val = (node.val * 2) % 10             if node.next and node.next.val > 4:                 node.val += 1             node = node.next         return head                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
|66 |4             |C++     |medium    |CodeWhisperer  |IDE Extension    |You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.  Return the head of the linked list after doubling it.  Example 1:  Input: head = [1,8,9] Output: [3,7,8] Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.  Example 2:  Input: head = [9,9,9] Output: [1,9,9,8] Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998.   Constraints:  The number of nodes in the list is in the range [1, 10^4] 0 <= Node.val <= 9 The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |/*You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.  Return the head of the linked list after doubling it.  Example 1:  Input: head = [1,8,9] Output: [3,7,8] Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.  Example 2:  Input: head = [9,9,9] Output: [1,9,9,8] Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998.   Constraints:  The number of nodes in the list is in the range [1, 10^4] 0 <= Node.val <= 9 The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself. */  /**  * Definition for singly-linked list.  * struct ListNode {  *     int val;  *     ListNode *next;  *     ListNode() : val(0), next(nullptr) {}  *     ListNode(int x) : val(x), next(nullptr) {}  *     ListNode(int x, ListNode *next) : val(x), next(next) {}  * };  */ class Solution { public:     ListNode* doubleIt(ListNode* head) {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |class Solution { public:     ListNode* doubleIt(ListNode* head) {         if(head == NULL)             return NULL;         ListNode* temp = head;         while(temp->next != NULL){             temp->val *= 2;             temp = temp->next;             if(temp->next != NULL) {                 temp->val *= 2;                 temp = temp->next;                 continue;             }             else {                 break;             }         }         return head;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |class Solution { public:     ListNode* doubleIt(ListNode* head) {         if (head->val > 4)             head = new ListNode(0, head);         for(ListNode* node = head; node; node = node->next) {             node->val = (node->val * 2) % 10;             if (node->next && node->next->val > 4)                 node->val++;         }         return head;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
|67 |5             |Java    |hard      |CodeWhisperer  |IDE Extension    |You are given an array nums of n positive integers and an integer k.  Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:  Choose any non-empty subarray nums[l, ..., r] that you haven't chosen previously. Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index. Multiply your score by x. Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.  The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.  Return the maximum possible score after applying at most k operations.  Since the answer may be large, return it modulo 10^9 + 7.  Example 1:  Input: nums = [8,3,9,3,8], k = 2 Output: 81 Explanation: To get a score of 81, we can apply the following operations: - Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81. It can be proven that 81 is the highest score one can obtain.  Example 2:  Input: nums = [19,12,14,6,10,18], k = 3 Output: 4788 Explanation: To get a score of 4788, we can apply the following operations:  - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19. - Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788. It can be proven that 4788 is the highest score one can obtain.   Constraints:  1 <= nums.length == n <= 10^5 1 <= nums[i] <= 10^5 1 <= k <= min(n * (n + 1) / 2, 10^9) |public class Solution {     public int maximumScore(List<Integer> nums, int k) { /*You are given an array nums of n positive integers and an integer k.  Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:  Choose any non-empty subarray nums[l, ..., r] that you haven't chosen previously. Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index. Multiply your score by x. Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.  The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.  Return the maximum possible score after applying at most k operations.  Since the answer may be large, return it modulo 10^9 + 7.  Example 1:  Input: nums = [8,3,9,3,8], k = 2 Output: 81 Explanation: To get a score of 81, we can apply the following operations: - Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81. It can be proven that 81 is the highest score one can obtain.  Example 2:  Input: nums = [19,12,14,6,10,18], k = 3 Output: 4788 Explanation: To get a score of 4788, we can apply the following operations:  - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19. - Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788. It can be proven that 4788 is the highest score one can obtain.   Constraints:  1 <= nums.length == n <= 10^5 1 <= nums[i] <= 10^5 1 <= k <= min(n * (n + 1) / 2, 10^9). */                                                      |public class Solution {     public int maximumScore(List<Integer> nums, int k) {         int n = nums.size();         int[] primes = new int[n];         for (int i = 0; i < n; i++) {             primes[i] = primeFactors(nums.get(i));             if (primes[i] == 0) primes[i] = 1;             //System.out.println(primes[i]);         }         int[][] dp = new int[n][k + 1];         for (int i = 0; i < n; i++) {             dp[i][0] = 1;         }         for (int i = 1; i <= k; i++) {             for (int j = 0; j < n; j++) {                 dp[j][i] = Math.max(dp[j][i - 1], dp[j - 1][i - 1] * primes[j]);             }         }         return dp[n - 1][k];              }          public int primeFactors(int n) {         int count = 0;         for (int i = 2; i <= n / i; i++) {             while (n % i == 0) {                 n /= i;                 count++;             }         }         if (n > 1) count++;         return count;     }      }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |class Solution {     static final int MOD = 1000000007;      public int maximumScore(List<Integer> nums, int k) {         int n = nums.size();          int upper = Collections.max(nums) + 1;          boolean[] prime = new boolean[upper];         int[] primeScore = new int[upper];         Arrays.fill(prime, true);         prime[0] = prime[1] = false;         for (int i = 2; i < upper; i++) {             if (prime[i]) {                 for (int j = i; j < upper; j += i) {                     primeScore[j]++;                     prime[j] = false;                 }             }         }          int[] nextGreaterElement = new int[n];         Arrays.fill(nextGreaterElement, n);         Stack<Integer> s = new Stack<>();         for (int i = n - 1; i >= 0; i--) {             while (!s.empty() && primeScore[nums.get(i)] >= primeScore[nums.get(s.peek())]) {                 s.pop();             }             nextGreaterElement[i] = s.empty() ? n : s.peek();             s.push(i);         }          int[] prevGreaterOrEqualElement = new int[n];         Arrays.fill(prevGreaterOrEqualElement, -1);         s = new Stack<>();         for (int i = 0; i < n; i++) {             while (!s.empty() && primeScore[nums.get(i)] > primeScore[nums.get(s.peek())]) {                 s.pop();             }             prevGreaterOrEqualElement[i] = s.empty() ? -1 : s.peek();             s.push(i);         }          int res = 1;         int[][] tuples = new int[n][2];         for (int i = 0; i < n; i++) {             tuples[i][0] = nums.get(i);             tuples[i][1] = i;         }         Arrays.sort(tuples, new Comparator<int[]>() {             public int compare(int[] a, int[] b) {                 return b[0] - a[0];             }         });         for (int i = 0; i < n; i++) {             int num = tuples[i][0];             int idx = tuples[i][1];             int operations = Math.min((idx - prevGreaterOrEqualElement[idx]) * (nextGreaterElement[idx] - idx), k);             res = (int)((1L * res * pow(num, operations)) % MOD);             k -= operations;             if (k == 0) {                 return res;             }         }          return res;     }      public int pow(int x, int n) {         int res = 1;         while (n > 0) {             if (n % 2 == 1) {                 res = (int)((1L * res * x) % MOD);             }             x = (int)((1L * x * x) % MOD);             n /= 2;         }         return res;     } }|
|68 |5             |Python  |hard      |CodeWhisperer  |IDE Extension    |You are given an array nums of n positive integers and an integer k.  Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:  Choose any non-empty subarray nums[l, ..., r] that you haven't chosen previously. Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index. Multiply your score by x. Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.  The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.  Return the maximum possible score after applying at most k operations.  Since the answer may be large, return it modulo 10^9 + 7.  Example 1:  Input: nums = [8,3,9,3,8], k = 2 Output: 81 Explanation: To get a score of 81, we can apply the following operations: - Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81. It can be proven that 81 is the highest score one can obtain.  Example 2:  Input: nums = [19,12,14,6,10,18], k = 3 Output: 4788 Explanation: To get a score of 4788, we can apply the following operations:  - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19. - Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788. It can be proven that 4788 is the highest score one can obtain.   Constraints:  1 <= nums.length == n <= 10^5 1 <= nums[i] <= 10^5 1 <= k <= min(n * (n + 1) / 2, 10^9) |class Solution:     def maximumScore(self, nums: List[int], k: int) -> int: """You are given an array nums of n positive integers and an integer k.  Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:  Choose any non-empty subarray nums[l, ..., r] that you haven't chosen previously. Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index. Multiply your score by x. Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.  The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.  Return the maximum possible score after applying at most k operations.  Since the answer may be large, return it modulo 10^9 + 7.  Example 1:  Input: nums = [8,3,9,3,8], k = 2 Output: 81 Explanation: To get a score of 81, we can apply the following operations: - Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81. It can be proven that 81 is the highest score one can obtain.  Example 2:  Input: nums = [19,12,14,6,10,18], k = 3 Output: 4788 Explanation: To get a score of 4788, we can apply the following operations:  - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19. - Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788. It can be proven that 4788 is the highest score one can obtain.   Constraints:  1 <= nums.length == n <= 10^5 1 <= nums[i] <= 10^5 1 <= k <= min(n * (n + 1) / 2, 10^9) """                                                          |class Solution:     def maximumScore(self, nums: List[int], k: int) -> int:         def prime(n):             if n == 1:                 return False             for i in range(2, int(n**0.5)+1):                 if n % i == 0:                     return False             return True         ans = 1         for i in range(k, -1, -1):             if prime(nums[i]):                 ans *= nums[i]         for i in range(k+1, len(nums)):             if prime(nums[i]):                 ans *= nums[i]         return ans % (10**9 + 7)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |class Solution:      MOD = 1000000007      def maximumScore(self, nums: List[int], k: int) -> int:         n = len(nums)          upper = max(nums) + 1          prime = [True]*upper         prime[0] = prime[1] = False         primeScore = [0]*upper         for i in range(2, upper):             if prime[i]:                 for j in range(i, upper, i):                     primeScore[j] += 1                     prime[j] = False          nextGreaterElement = [n]*n         s = []         for i in range(n - 1, -1, -1):             while s and primeScore[nums[i]] >= primeScore[nums[s[-1]]]:                 s.pop()             nextGreaterElement[i] = s[-1] if s else n             s.append(i)          prevGreaterOrEqualElement = [-1]*n         s = []         for i in range(n):             while s and primeScore[nums[i]] > primeScore[nums[s[-1]]]:                 s.pop()             prevGreaterOrEqualElement[i] = s[-1] if s else -1             s.append(i)          res = 1         tuples = [[nums[i], i] for i in range(n)]         tuples.sort(reverse=True)         for num, idx in tuples:             operations = min((idx - prevGreaterOrEqualElement[idx]) * (nextGreaterElement[idx] - idx), k)             res = (res * self.pow(num, operations)) % self.MOD             k -= operations             if k == 0:                 return res          return res      def pow(self, x: int, n: int) -> int:         res = 1         while n > 0:             if n % 2 == 1:                 res = (res * x) % self.MOD             x = (x * x) % self.MOD             n //= 2         return res                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
|69 |5             |C++     |hard      |CodeWhisperer  |IDE Extension    |You are given an array nums of n positive integers and an integer k.  Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:  Choose any non-empty subarray nums[l, ..., r] that you haven't chosen previously. Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index. Multiply your score by x. Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.  The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.  Return the maximum possible score after applying at most k operations.  Since the answer may be large, return it modulo 10^9 + 7.  Example 1:  Input: nums = [8,3,9,3,8], k = 2 Output: 81 Explanation: To get a score of 81, we can apply the following operations: - Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81. It can be proven that 81 is the highest score one can obtain.  Example 2:  Input: nums = [19,12,14,6,10,18], k = 3 Output: 4788 Explanation: To get a score of 4788, we can apply the following operations:  - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19. - Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788. It can be proven that 4788 is the highest score one can obtain.   Constraints:  1 <= nums.length == n <= 10^5 1 <= nums[i] <= 10^5 1 <= k <= min(n * (n + 1) / 2, 10^9) |class Solution { public:     int maximumScore(vector<int>& nums, int k) { /*You are given an array nums of n positive integers and an integer k.  Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:  Choose any non-empty subarray nums[l, ..., r] that you haven't chosen previously. Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index. Multiply your score by x. Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.  The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.  Return the maximum possible score after applying at most k operations.  Since the answer may be large, return it modulo 10^9 + 7.  Example 1:  Input: nums = [8,3,9,3,8], k = 2 Output: 81  Example 2:  Input: nums = [19,12,14,6,10,18], k = 3 Output: 4788   Constraints:  1 <= nums.length == n <= 10^5 1 <= nums[i] <= 10^5 1 <= k <= min(n * (n + 1) / 2, 10^9) */                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |class Solution { public:     int maximumScore(vector<int>& nums, int k) {         int n = nums.size();         int l = k, r = k;         int score = 1;         int ans = 0;         while(l >= 0 &#124;&#124; r < n){             if(l < 0){                 score *= nums[r++];                 ans = max(ans, score);                 continue;             }             if(r == n){                 score *= nums[l--];                 ans = max(ans, score);                 continue;             }             if(nums[l] < nums[r]){                 score *= nums[l--];                 ans = max(ans, score);             }             else{                 score *= nums[r++];                 ans = max(ans, score);             }         }         return ans;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |class Solution { public:     const int MOD = 1000000007;      int maximumScore(vector<int>& nums, int k) {         int n = nums.size();          int upper = *max_element(nums.begin(), nums.end()) + 1;          vector<bool> prime(upper, true);         prime[0] = prime[1] = false;         vector<int> primeScore(upper, 0);         for (int i = 2; i < upper; i++) {             if (prime[i]) {                 for (int j = i; j < upper; j += i) {                     primeScore[j]++;                     prime[j] = false;                 }             }         }          vector<int> nextGreaterElement(n, n);         stack<int> s;         for (int i = n - 1; i >= 0; i--) {             while (!s.empty() && primeScore[nums[i]] >= primeScore[nums[s.top()]]) {                 s.pop();             }             nextGreaterElement[i] = s.empty() ? n : s.top();             s.push(i);         }          vector<int> prevGreaterOrEqualElement(n, -1);         s = stack<int>();         for (int i = 0; i < n; i++) {             while (!s.empty() && primeScore[nums[i]] > primeScore[nums[s.top()]]) {                 s.pop();             }             prevGreaterOrEqualElement[i] = s.empty() ? -1 : s.top();             s.push(i);         }          int res = 1;         vector<pair<int, int>> tuples(n);         for (int i = 0; i < n; i++) {             tuples[i].first = nums[i];             tuples[i].second = i;         }         sort(tuples.rbegin(), tuples.rend());         for (const auto& [num, i] : tuples) {             int operations = min((i - prevGreaterOrEqualElement[i]) * (nextGreaterElement[i] - i), k);             res = (int)((1L * res * pow(num, operations)) % MOD);             k -= operations;             if (k == 0) {                 return res;             }         }          return res;     }      int pow(int x, int n) {         int res = 1;         while (n > 0) {             if (n % 2 == 1) {                 res = (int)((1L * res * x) % MOD);             }             x = (int)((1L * x * x) % MOD);             n /= 2;         }         return res;     } };                                                                                                                                                                                                                                                                                                                                                                               |
|70 |6             |Java    |hard      |CodeWhisperer  |IDE Extension    |You are given a 0-indexed 2D integer array items of length n and an integer k.  items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.  Let's define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.  Your task is to find the maximum elegance from all subsequences of size k in items.  Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.  Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order.  Example 1:  Input: items = [[3,2],[5,1],[10,1]], k = 2 Output: 17 Explanation: In this example, we have to select a subsequence of size 2. We can select items[0] = [3,2] and items[2] = [10,1]. The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1]. Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance.   Example 2:  Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3 Output: 19 Explanation: In this example, we have to select a subsequence of size 3.  We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3].  The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3].  Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.  Example 3:  Input: items = [[1,1],[2,1],[3,1]], k = 3 Output: 7 Explanation: In this example, we have to select a subsequence of size 3.  We should select all the items.  The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1].  Hence, the maximum elegance is 6 + 1^2 = 7.     Constraints:  1 <= items.length == n <= 10^5 items[i].length == 2 items[i][0] == profit_i items[i][1] == category_i 1 <= profit_i <= 10^9 1 <= category_i <= n  1 <= k <= n                                             |public class Solution {     public int findMaximumElegance(int[][] items, int k) { /*  * You are given a 0-indexed 2D integer array items of length n and an integer k.  items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.  Let's define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.  Your task is to find the maximum elegance from all subsequences of size k in items.  Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.  Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order.  Example 1:  Input: items = [[3,2],[5,1],[10,1]], k = 2 Output: 17 Explanation: In this example, we have to select a subsequence of size 2. We can select items[0] = [3,2] and items[2] = [10,1]. The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1]. Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance.   Example 2:  Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3 Output: 19 Explanation: In this example, we have to select a subsequence of size 3.  We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3].  The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3].  Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.  Example 3:  Input: items = [[1,1],[2,1],[3,1]], k = 3 Output: 7 Explanation: In this example, we have to select a subsequence of size 3.  We should select all the items.  The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1].  Hence, the maximum elegance is 6 + 1^2 = 7.     Constraints:  1 <= items.length == n <= 10^5 items[i].length == 2 items[i][0] == profit_i items[i][1] == category_i 1 <= profit_i <= 10^9 1 <= category_i <= n  1 <= k <= n */                                                                                             |public class Solution {     public int findMaximumElegance(int[][] items, int k) {         int n = items.length;         int[] category = new int[n];         for (int i = 0; i < n; i++) {             category[i] = items[i][1];         }         int[] count = new int[n + 1];         for (int i = 0; i < n; i++) {             count[category[i]]++;         }         for (int i = 1; i <= n; i++) {             count[i] += count[i - 1];         }         int[] dp = new int[n + 1];         for (int i = 0; i < n; i++) {             int index = count[category[i]];             dp[index] = Math.max(dp[index], dp[index - 1] + items[i][0]);         }         return dp[n];              }  }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |class Solution {     public long findMaximumElegance(int[][] A, int k) {         Arrays.sort(A, (a, b) -> b[0] - a[0]);         long res = 0, cur = 0;         List<Integer> dup = new ArrayList<>();         Set<Integer> seen = new HashSet<>();         for (int i = 0; i < A.length; ++i) {             if (i < k) {                 if (seen.contains(A[i][1])) {                     dup.add(A[i][0]);                 }                 cur += A[i][0];             } else if (!seen.contains(A[i][1])) {                 if (dup.isEmpty()) break;                 cur += A[i][0] - dup.remove(dup.size() - 1);             }             seen.add(A[i][1]);             res = Math.max(res, cur + 1L * seen.size() * seen.size());         }         return res;     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|71 |6             |Python  |hard      |CodeWhisperer  |IDE Extension    |You are given a 0-indexed 2D integer array items of length n and an integer k.  items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.  Let's define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.  Your task is to find the maximum elegance from all subsequences of size k in items.  Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.  Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order.  Example 1:  Input: items = [[3,2],[5,1],[10,1]], k = 2 Output: 17 Explanation: In this example, we have to select a subsequence of size 2. We can select items[0] = [3,2] and items[2] = [10,1]. The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1]. Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance.   Example 2:  Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3 Output: 19 Explanation: In this example, we have to select a subsequence of size 3.  We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3].  The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3].  Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.  Example 3:  Input: items = [[1,1],[2,1],[3,1]], k = 3 Output: 7 Explanation: In this example, we have to select a subsequence of size 3.  We should select all the items.  The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1].  Hence, the maximum elegance is 6 + 1^2 = 7.     Constraints:  1 <= items.length == n <= 10^5 items[i].length == 2 items[i][0] == profit_i items[i][1] == category_i 1 <= profit_i <= 10^9 1 <= category_i <= n  1 <= k <= n                                             |class Solution:     def findMaximumElegance(self, items: List[List[int]], k: int) -> int: """You are given a 0-indexed 2D integer array items of length n and an integer k.  items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.  Let's define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.  Your task is to find the maximum elegance from all subsequences of size k in items.  Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.  Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order.  Example 1:  Input: items = [[3,2],[5,1],[10,1]], k = 2 Output: 17 Explanation: In this example, we have to select a subsequence of size 2. We can select items[0] = [3,2] and items[2] = [10,1]. The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1]. Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance.   Example 2:  Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3 Output: 19 Explanation: In this example, we have to select a subsequence of size 3.  We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3].  The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3].  Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.  Example 3:  Input: items = [[1,1],[2,1],[3,1]], k = 3 Output: 7 Explanation: In this example, we have to select a subsequence of size 3.  We should select all the items.  The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1].  Hence, the maximum elegance is 6 + 1^2 = 7.     Constraints:  1 <= items.length == n <= 10^5 items[i].length == 2 items[i][0] == profit_i items[i][1] == category_i 1 <= profit_i <= 10^9 1 <= category_i <= n  1 <= k <= n """                                                                                        |class Solution:     def findMaximumElegance(self, items: List[List[int]], k: int) -> int:         items.sort(key = lambda x: x[1])         ans = 0         for i in range(k):             ans += items[i][0]         return ans + (k * (k - 1) // 2) * items[k - 1][1]                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |class Solution:     def findMaximumElegance(self, items: List[List[int]], k: int) -> int:         items = sorted(items, key=lambda v: -v[0])         res = cur = 0         A = []         seen = set()         for i, (p, c) in enumerate(items):             if i < k:                 if c in seen:                     A.append(p)                 cur += p             elif c not in seen:                 if not A: break                 cur += p - A.pop()             seen.add(c)             res = max(res, cur + len(seen) * len(seen))         return res                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
|72 |6             |C++     |hard      |CodeWhisperer  |IDE Extension    |You are given a 0-indexed 2D integer array items of length n and an integer k.  items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.  Let's define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.  Your task is to find the maximum elegance from all subsequences of size k in items.  Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.  Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order.  Example 1:  Input: items = [[3,2],[5,1],[10,1]], k = 2 Output: 17 Explanation: In this example, we have to select a subsequence of size 2. We can select items[0] = [3,2] and items[2] = [10,1]. The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1]. Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance.   Example 2:  Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3 Output: 19 Explanation: In this example, we have to select a subsequence of size 3.  We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3].  The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3].  Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.  Example 3:  Input: items = [[1,1],[2,1],[3,1]], k = 3 Output: 7 Explanation: In this example, we have to select a subsequence of size 3.  We should select all the items.  The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1].  Hence, the maximum elegance is 6 + 1^2 = 7.     Constraints:  1 <= items.length == n <= 10^5 items[i].length == 2 items[i][0] == profit_i items[i][1] == category_i 1 <= profit_i <= 10^9 1 <= category_i <= n  1 <= k <= n                                             |/*You are given a 0-indexed 2D integer array items of length n and an integer k.  items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.  Let's define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.  Your task is to find the maximum elegance from all subsequences of size k in items.  Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.  Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order.  Example 1:  Input: items = [[3,2],[5,1],[10,1]], k = 2 Output: 17 Explanation: In this example, we have to select a subsequence of size 2. We can select items[0] = [3,2] and items[2] = [10,1]. The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1]. Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance.   Example 2:  Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3 Output: 19 Explanation: In this example, we have to select a subsequence of size 3.  We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3].  The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3].  Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.  Example 3:  Input: items = [[1,1],[2,1],[3,1]], k = 3 Output: 7 Explanation: In this example, we have to select a subsequence of size 3.  We should select all the items.  The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1].  Hence, the maximum elegance is 6 + 1^2 = 7.    Constraints:  1 <= items.length == n <= 10^5 items[i].length == 2 items[i][0] == profit_i items[i][1] == category_i 1 <= profit_i <= 10^9 1 <= category_i <= n  1 <= k <= n*/ class Solution { public:     long long findMaximumElegance(vector<vector<int>>& items, int k) {                                                                                      |class Solution { public:     long long findMaximumElegance(vector<vector<int>>& items, int k) {         int n=items.size();         vector<long long>profit(n);         vector<long long>category(n);         for(int i=0;i<n;i++){             profit[i]=items[i][0];             category[i]=items[i][1];         }         sort(profit.begin(),profit.end());         sort(category.begin(),category.end());         long long ans=0;         long long max_profit=0;         long long max_category=0;         for(int i=0;i<n;i++){             if(i<k){                 max_profit+=profit[i];                 max_category+=category[i];                 ans=max(ans,max_profit+max_category*max_category);                 continue;             }             max_profit-=profit[i-k];             max_profit+=profit[i];             max_category-=category[i-k];             max_category+=category[i];             ans=max(ans,max_profit+max_category*max_category);         }         return ans;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |class Solution { public:     long long findMaximumElegance(vector<vector<int>>& A, int k) {         sort(A.begin(), A.end(), [](const vector<int>& a, const vector<int>& b) {             return a[0] > b[0];         });         long long res = 0, cur = 0;         vector<int> dup;         unordered_set<int> seen;         for (int i = 0; i < A.size(); ++i) {             if (i < k) {                 if (seen.count(A[i][1])) {                     dup.push_back(A[i][0]);                 }                 cur += A[i][0];             } else if (seen.find(A[i][1]) == seen.end()) {                 if (dup.empty()) break;                 cur += A[i][0] - dup.back();                 dup.pop_back();             }             seen.insert(A[i][1]);             res = fmax(res, cur + 1L * seen.size() * seen.size());         }         return res;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
|73 |1             |Java    |easy      |GitHub Copilot |IDE Extension    |You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.  Return the maximum sum or -1 if no such pair exists.  Example 1:  Input: nums = [51,71,17,24,42] Output: 88 Explanation:  For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88.  For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66. It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.  Example 2:  Input: nums = [1,2,3,4] Output: -1 Explanation: No pair exists in nums with equal maximum digits.  Constraints:  2 <= nums.length <= 100 1 <= nums[i] <= 10^4                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |public class Solution {     public int maxSum(int[] nums) {         /*          * You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.  Return the maximum sum or -1 if no such pair exists.  Example 1:  Input: nums = [51,71,17,24,42] Output: 88 Explanation:  For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88.  For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66. It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.  Example 2:  Input: nums = [1,2,3,4] Output: -1 Explanation: No pair exists in nums with equal maximum digits.  Constraints:  2 <= nums.length <= 100 1 <= nums[i] <= 10^4          */                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |public class Solution {     public int maxSum(int[] nums) {         int max = -1;         for(int i = 0; i < nums.length; i++){             for(int j = i+1; j < nums.length;j++){                 if(max < nums[i] + nums[j] && maxDigit(nums[i]) == maxDigit(nums[j])){                     max = nums[i] + nums[j];                 }             }         }         return max;     }     public int maxDigit(int num){         int max = 0;         while(num > 0){             max = Math.max(max, num % 10);             num /= 10;         }         return max;     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |class Solution {     public int maxSum(int[] nums) {     int ans = -1;     Map<Integer,List<Integer>> ump = new HashMap<>();     for(int i = 0; i < nums.length; ++i){         int t = nums[i], maxDigit = 0;         while(t != 0){ //evaluate max digit in the number             maxDigit = Math.max(t%10, maxDigit);             t = t/10;         }         if(!ump.containsKey(maxDigit)) ump.put(maxDigit, new ArrayList<>());         ump.get(maxDigit).add(nums[i]); // add the number to the map      }     for(Map.Entry<Integer, List<Integer>> entry: ump.entrySet()){         entry.getValue().sort(Comparator.reverseOrder()); //to find max two number in each max digit          if(entry.getValue().size() >= 2) ans = Math.max(ans, entry.getValue().get(0) + entry.getValue().get(1)); //sum max two number and take max     }     return ans;     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
|74 |1             |Python  |easy      |GitHub Copilot |IDE Extension    |You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.  Return the maximum sum or -1 if no such pair exists.  Example 1:  Input: nums = [51,71,17,24,42] Output: 88 Explanation:  For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88.  For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66. It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.  Example 2:  Input: nums = [1,2,3,4] Output: -1 Explanation: No pair exists in nums with equal maximum digits.  Constraints:  2 <= nums.length <= 100 1 <= nums[i] <= 10^4                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |class Solution:     def maxSum(self, nums: List[int]) -> int: """You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.  Return the maximum sum or -1 if no such pair exists.  Example 1:  Input: nums = [51,71,17,24,42] Output: 88 Explanation:  For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88.  For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66. It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.  Example 2:  Input: nums = [1,2,3,4] Output: -1 Explanation: No pair exists in nums with equal maximum digits.  Constraints:  2 <= nums.length <= 100 1 <= nums[i] <= 10^4"""                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |class Solution:     def maxSum(self, nums: List[int]) -> int:         maxSum = -1         maxDigit = [0] * 10         for num in nums:             maxDigit[int(str(num)[0])] = max(maxDigit[int(str(num)[0])], num)         for i in range(10):                          for j in range(i, 10):                 if maxDigit[i] and maxDigit[j]:                     maxSum = max(maxSum, maxDigit[i] + maxDigit[j])         return maxSum                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |class Solution:     def maxSum(self, nums: List[int]) -> int:         max_by_digit = defaultdict(int)         max_sum = -1          for num in nums:             digit = max(str(num))              if digit in max_by_digit:                 max_sum = max(max_sum, max_by_digit[digit] + num)              max_by_digit[digit] = max(max_by_digit[digit], num)          return max_sum                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
|75 |1             |C++     |easy      |GitHub Copilot |IDE Extension    |You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.  Return the maximum sum or -1 if no such pair exists.  Example 1:  Input: nums = [51,71,17,24,42] Output: 88 Explanation:  For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88.  For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66. It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.  Example 2:  Input: nums = [1,2,3,4] Output: -1 Explanation: No pair exists in nums with equal maximum digits.  Constraints:  2 <= nums.length <= 100 1 <= nums[i] <= 10^4                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |class Solution { public:     int maxSum(vector<int>& nums) { /*You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.  Return the maximum sum or -1 if no such pair exists.  Example 1:  Input: nums = [51,71,17,24,42] Output: 88  Example 2:  Input: nums = [1,2,3,4] Output: -1  Constraints:  2 <= nums.length <= 100 1 <= nums[i] <= 10^4*/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |class Solution { public:     int maxSum(vector<int>& nums) {         int n = nums.size();         int maxSum = -1;         unordered_map<int, int> mp;         for(int i = 0; i < n; i++) {             int maxDigit = 0;             int temp = nums[i];             while(temp) {                 maxDigit = max(maxDigit, temp % 10);                 temp /= 10;             }             if(mp.find(maxDigit) != mp.end()) {                 maxSum = max(maxSum, mp[maxDigit] + nums[i]);                 mp[maxDigit] = max(mp[maxDigit], nums[i]);             } else {                 mp[maxDigit] = nums[i];             }         }         return maxSum;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |class Solution {     public:         int maxSum(vector<int>& nums) {         int res = -1, max_num[10] = {};         for (auto num : nums) {             int max_d = 0;             for (int v = num; v; v /= 10)                 max_d = max(max_d, v % 10);             if (max_num[max_d])                 res = max(res, max_num[max_d] + num);             max_num[max_d] = max(max_num[max_d], num);         }         return res;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|76 |2             |Java    |easy      |GitHub Copilot |IDE Extension    |Your laptop keyboard is faulty, and whenever you type a character 'i' on it, it reverses the string that you have written. Typing other characters works as expected.  You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.  Return the final string that will be present on your laptop screen.  Example 1:  Input: s = "string" Output: "rtsng" Explanation:  After typing first character, the text on the screen is "s". After the second character, the text is "st".  After the third character, the text is "str". Since the fourth character is an 'i', the text gets reversed and becomes "rts". After the fifth character, the text is "rtsn".  After the sixth character, the text is "rtsng".  Therefore, we return "rtsng".  Example 2:  Input: s = "poiinter" Output: "ponter" Explanation:  After the first character, the text on the screen is "p". After the second character, the text is "po".  Since the third character you type is an 'i', the text gets reversed and becomes "op".  Since the fourth character you type is an 'i', the text gets reversed and becomes "po". After the fifth character, the text is "pon". After the sixth character, the text is "pont".  After the seventh character, the text is "ponte".  After the eighth character, the text is "ponter".  Therefore, we return "ponter".   Constraints:  1 <= s.length <= 100 s consists of lowercase English letters. s[0] != 'i'                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |public class Solution {     public String finalString(String s) {         /*          * Your laptop keyboard is faulty, and whenever you type a character 'i' on it, it reverses the string that you have written. Typing other characters works as expected.  You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.  Return the final string that will be present on your laptop screen.  Constraints:  1 <= s.length <= 100 s consists of lowercase English letters. s[0] != 'i'  */                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |public class Solution {     public String finalString(String s) {         StringBuilder sb = new StringBuilder();         for (int i = 0; i < s.length(); i++) {             if (s.charAt(i) == 'i') {                 sb.reverse();             } else {                 sb.append(s.charAt(i));             }         }         return sb.toString();     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |class Solution {     public String finalString(String s) {         StringBuilder nm=new StringBuilder();         for(char c:s.toCharArray())         {             if(c=='i')             {                 nm.reverse();             }             else             {                 nm.append(c);             }         }         return nm.toString();     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|77 |2             |Python  |easy      |GitHub Copilot |IDE Extension    |Your laptop keyboard is faulty, and whenever you type a character 'i' on it, it reverses the string that you have written. Typing other characters works as expected.  You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.  Return the final string that will be present on your laptop screen.  Example 1:  Input: s = "string" Output: "rtsng" Explanation:  After typing first character, the text on the screen is "s". After the second character, the text is "st".  After the third character, the text is "str". Since the fourth character is an 'i', the text gets reversed and becomes "rts". After the fifth character, the text is "rtsn".  After the sixth character, the text is "rtsng".  Therefore, we return "rtsng".  Example 2:  Input: s = "poiinter" Output: "ponter" Explanation:  After the first character, the text on the screen is "p". After the second character, the text is "po".  Since the third character you type is an 'i', the text gets reversed and becomes "op".  Since the fourth character you type is an 'i', the text gets reversed and becomes "po". After the fifth character, the text is "pon". After the sixth character, the text is "pont".  After the seventh character, the text is "ponte".  After the eighth character, the text is "ponter".  Therefore, we return "ponter".   Constraints:  1 <= s.length <= 100 s consists of lowercase English letters. s[0] != 'i'                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |class Solution:     def finalString(self, s: str) -> str: """You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.  Return the final string that will be present on your laptop screen.  Example 1:  Input: s = "string" Output: "rtsng" Explanation:  After typing first character, the text on the screen is "s". After the second character, the text is "st".  After the third character, the text is "str". Since the fourth character is an 'i', the text gets reversed and becomes "rts". After the fifth character, the text is "rtsn".  After the sixth character, the text is "rtsng".  Therefore, we return "rtsng".  Example 2:  Input: s = "poiinter" Output: "ponter" Explanation:  After the first character, the text on the screen is "p". After the second character, the text is "po".  Since the third character you type is an 'i', the text gets reversed and becomes "op".  Since the fourth character you type is an 'i', the text gets reversed and becomes "po". After the fifth character, the text is "pon". After the sixth character, the text is "pont".  After the seventh character, the text is "ponte".  After the eighth character, the text is "ponter".  Therefore, we return "ponter".   Constraints:  1 <= s.length <= 100 s consists of lowercase English letters. s[0] != 'i' """                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |class Solution:     def finalString(self, s: str) -> str:         stack = []         for i in range(len(s)):             if s[i] == 'i':                 stack.reverse()             else:                 stack.append(s[i])         return "".join(stack)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |class Solution:     def finalString(self, s: str) -> str:         while "i" in s:             index=s.index("i")              #first half and second half             first=s[:index][::-1]             second=s[index+1:]              s="".join([first,second])         return s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|78 |2             |C++     |easy      |GitHub Copilot |IDE Extension    |Your laptop keyboard is faulty, and whenever you type a character 'i' on it, it reverses the string that you have written. Typing other characters works as expected.  You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.  Return the final string that will be present on your laptop screen.  Example 1:  Input: s = "string" Output: "rtsng" Explanation:  After typing first character, the text on the screen is "s". After the second character, the text is "st".  After the third character, the text is "str". Since the fourth character is an 'i', the text gets reversed and becomes "rts". After the fifth character, the text is "rtsn".  After the sixth character, the text is "rtsng".  Therefore, we return "rtsng".  Example 2:  Input: s = "poiinter" Output: "ponter" Explanation:  After the first character, the text on the screen is "p". After the second character, the text is "po".  Since the third character you type is an 'i', the text gets reversed and becomes "op".  Since the fourth character you type is an 'i', the text gets reversed and becomes "po". After the fifth character, the text is "pon". After the sixth character, the text is "pont".  After the seventh character, the text is "ponte".  After the eighth character, the text is "ponter".  Therefore, we return "ponter".   Constraints:  1 <= s.length <= 100 s consists of lowercase English letters. s[0] != 'i'                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |class Solution { public:     string finalString(string s) { /*You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.  Return the final string that will be present on your laptop screen.  Example 1:  Input: s = "string" Output: "rtsng" Explanation:  After typing first character, the text on the screen is "s". After the second character, the text is "st".  After the third character, the text is "str". Since the fourth character is an 'i', the text gets reversed and becomes "rts". After the fifth character, the text is "rtsn".  After the sixth character, the text is "rtsng".  Therefore, we return "rtsng".  Example 2:  Input: s = "poiinter" Output: "ponter" Explanation:  After the first character, the text on the screen is "p". After the second character, the text is "po".  Since the third character you type is an 'i', the text gets reversed and becomes "op".  Since the fourth character you type is an 'i', the text gets reversed and becomes "po". After the fifth character, the text is "pon". After the sixth character, the text is "pont".  After the seventh character, the text is "ponte".  After the eighth character, the text is "ponter".  Therefore, we return "ponter".   Constraints:  1 <= s.length <= 100 s consists of lowercase English letters. s[0] != 'i'*/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |class Solution { public:     string finalString(string s) {         string ans = "";         int n = s.length();         int i = 0;         while(i < n) {             if(s[i] == 'i') {                 reverse(ans.begin(), ans.end());             } else {                 ans += s[i];             }             i++;         }         return ans;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |class Solution { public:     string finalString(const string &s) {         string a, b;         for (char ch : s)             if (ch == 'i')                 swap(a, b);             else                 a += ch;         return string(rbegin(b), rend(b)) + a;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
|79 |3             |Java    |medium    |GitHub Copilot |IDE Extension    |You are given a 0-indexed integer array nums and an integer x.  Find the minimum absolute difference between two elements in the array that are at least x indices apart.  In other words, find two indices i and j such that abs(i - j) >= x and abs(nums[i] - nums[j]) is minimized.  Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.  Example 1:  Input: nums = [4,3,2,4], x = 2 Output: 0 Explanation: We can select nums[0] = 4 and nums[3] = 4.  They are at least 2 indices apart, and their absolute difference is the minimum, 0.  It can be shown that 0 is the optimal answer.  Example 2:  Input: nums = [5,3,2,10,15], x = 1 Output: 1 Explanation: We can select nums[1] = 3 and nums[2] = 2. They are at least 1 index apart, and their absolute difference is the minimum, 1. It can be shown that 1 is the optimal answer.  Example 3:  Input: nums = [1,2,3,4], x = 3 Output: 3 Explanation: We can select nums[0] = 1 and nums[3] = 4. They are at least 3 indices apart, and their absolute difference is the minimum, 3. It can be shown that 3 is the optimal answer.   Constraints:  1 <= nums.length <= 10^5 1 <= nums[i] <= 10^9 0 <= x < nums.length                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |class Solution {     public int minAbsoluteDifference(List<Integer> nums, int x) { /*You are given a 0-indexed integer array nums and an integer x.  Find the minimum absolute difference between two elements in the array that are at least x indices apart.  In other words, find two indices i and j such that abs(i - j) >= x and abs(nums[i] - nums[j]) is minimized.  Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.   Constraints:  1 <= nums.length <= 10^5 1 <= nums[i] <= 10^9 0 <= x < nums.length*/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |class Solution {     public int minAbsoluteDifference(List<Integer> nums, int x) {         int min = Integer.MAX_VALUE;         int n = nums.size();         for(int i = 0; i < n; i++){             for(int j = i + x; j < n; j++){                 min = Math.min(min, Math.abs(nums.get(i) - nums.get(j)));             }         }         return min;     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |class Solution {     int minAbsoluteDifference(List<Integer> nums, int x) {         int ans = Integer.MAX_VALUE;         TreeSet<Integer> s = new TreeSet<>();         for(int i = x; i < nums.size(); ++i){             s.add(nums.get(i-x));             Integer high = s.ceiling(nums.get(i)), low = s.floor(nums.get(i));             if(high != null) ans = Math.min(ans, Math.abs(nums.get(i) - high));             if(low != null) ans = Math.min(ans, Math.abs(nums.get(i) - low));         }         return ans;     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|80 |3             |Python  |medium    |GitHub Copilot |IDE Extension    |You are given a 0-indexed integer array nums and an integer x.  Find the minimum absolute difference between two elements in the array that are at least x indices apart.  In other words, find two indices i and j such that abs(i - j) >= x and abs(nums[i] - nums[j]) is minimized.  Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.  Example 1:  Input: nums = [4,3,2,4], x = 2 Output: 0 Explanation: We can select nums[0] = 4 and nums[3] = 4.  They are at least 2 indices apart, and their absolute difference is the minimum, 0.  It can be shown that 0 is the optimal answer.  Example 2:  Input: nums = [5,3,2,10,15], x = 1 Output: 1 Explanation: We can select nums[1] = 3 and nums[2] = 2. They are at least 1 index apart, and their absolute difference is the minimum, 1. It can be shown that 1 is the optimal answer.  Example 3:  Input: nums = [1,2,3,4], x = 3 Output: 3 Explanation: We can select nums[0] = 1 and nums[3] = 4. They are at least 3 indices apart, and their absolute difference is the minimum, 3. It can be shown that 3 is the optimal answer.   Constraints:  1 <= nums.length <= 10^5 1 <= nums[i] <= 10^9 0 <= x < nums.length                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |class Solution:     def minAbsoluteDifference(self, nums: List[int], x: int) -> int: """You are given a 0-indexed integer array nums and an integer x.  Find the minimum absolute difference between two elements in the array that are at least x indices apart.  In other words, find two indices i and j such that abs(i - j) >= x and abs(nums[i] - nums[j]) is minimized.  Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.  Example 1:  Input: nums = [4,3,2,4], x = 2 Output: 0 Explanation: We can select nums[0] = 4 and nums[3] = 4.  They are at least 2 indices apart, and their absolute difference is the minimum, 0.  It can be shown that 0 is the optimal answer.  Example 2:  Input: nums = [5,3,2,10,15], x = 1 Output: 1 Explanation: We can select nums[1] = 3 and nums[2] = 2. They are at least 1 index apart, and their absolute difference is the minimum, 1. It can be shown that 1 is the optimal answer.  Example 3:  Input: nums = [1,2,3,4], x = 3 Output: 3 Explanation: We can select nums[0] = 1 and nums[3] = 4. They are at least 3 indices apart, and their absolute difference is the minimum, 3. It can be shown that 3 is the optimal answer.   Constraints:  1 <= nums.length <= 10^5 1 <= nums[i] <= 10^9 0 <= x < nums.length """                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |class Solution:     def minAbsoluteDifference(self, nums: List[int], x: int) -> int:         nums.sort()         n = len(nums)         res = float('inf')         for i in range(n):             j = bisect_left(nums, nums[i] - x, i + 1)             if j < n:                 res = min(res, abs(nums[i] - nums[j] + x))             if j > i + 1:                 res = min(res, abs(nums[i] - nums[j - 1] + x))         return res                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |class Solution:   def minAbsoluteDifference(self, nums: List[int], x: int) -> int:     if x == 0:       return 0      arr, best_dist = SortedList([]), float('inf')     for i in range(x, len(nums)):       arr.add(nums[i - x])       v = nums[i]        pos = arr.bisect_left(v)       if pos < len(arr):         best_dist = min(best_dist, abs(arr[pos] - v))       if pos > 0:         best_dist = min(best_dist, abs(arr[pos - 1] - v))          return best_dist                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
|81 |3             |C++     |medium    |GitHub Copilot |IDE Extension    |You are given a 0-indexed integer array nums and an integer x.  Find the minimum absolute difference between two elements in the array that are at least x indices apart.  In other words, find two indices i and j such that abs(i - j) >= x and abs(nums[i] - nums[j]) is minimized.  Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.  Example 1:  Input: nums = [4,3,2,4], x = 2 Output: 0 Explanation: We can select nums[0] = 4 and nums[3] = 4.  They are at least 2 indices apart, and their absolute difference is the minimum, 0.  It can be shown that 0 is the optimal answer.  Example 2:  Input: nums = [5,3,2,10,15], x = 1 Output: 1 Explanation: We can select nums[1] = 3 and nums[2] = 2. They are at least 1 index apart, and their absolute difference is the minimum, 1. It can be shown that 1 is the optimal answer.  Example 3:  Input: nums = [1,2,3,4], x = 3 Output: 3 Explanation: We can select nums[0] = 1 and nums[3] = 4. They are at least 3 indices apart, and their absolute difference is the minimum, 3. It can be shown that 3 is the optimal answer.   Constraints:  1 <= nums.length <= 10^5 1 <= nums[i] <= 10^9 0 <= x < nums.length                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |class Solution { public:     int minAbsoluteDifference(vector<int>& nums, int x) { /*You are given a 0-indexed integer array nums and an integer x.  Find the minimum absolute difference between two elements in the array that are at least x indices apart.  In other words, find two indices i and j such that abs(i - j) >= x and abs(nums[i] - nums[j]) is minimized.  Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.  Example 1:  Input: nums = [4,3,2,4], x = 2 Output: 0 Explanation: We can select nums[0] = 4 and nums[3] = 4.  They are at least 2 indices apart, and their absolute difference is the minimum, 0.  It can be shown that 0 is the optimal answer.  Example 2:  Input: nums = [5,3,2,10,15], x = 1 Output: 1 Explanation: We can select nums[1] = 3 and nums[2] = 2. They are at least 1 index apart, and their absolute difference is the minimum, 1. It can be shown that 1 is the optimal answer.  Example 3:  Input: nums = [1,2,3,4], x = 3 Output: 3 Explanation: We can select nums[0] = 1 and nums[3] = 4. They are at least 3 indices apart, and their absolute difference is the minimum, 3. It can be shown that 3 is the optimal answer.   Constraints:  1 <= nums.length <= 10^5 1 <= nums[i] <= 10^9 0 <= x < nums.length*/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |class Solution { public:     int minAbsoluteDifference(vector<int>& nums, int x) {         int n = nums.size();         int ans = INT_MAX;         for(int i = 0; i < n; i++){             for(int j = i + x; j < n; j++){                 ans = min(ans, abs(nums[i] - nums[j]));             }         }         return ans;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |class Solution { public:     int minAbsoluteDifference(vector<int>& nums, int x) {         int ans = INT_MAX;         set<int> s;         for(int i = x; i < nums.size(); ++i){             s.insert(nums[i-x]);             auto it = s.upper_bound(nums[i]);             if(it != s.end()) ans = min(ans, abs(nums[i] - *it));             if(it != s.begin()) ans = min(ans, abs(nums[i] - *prev(it)));         }         return ans;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|82 |4             |Java    |medium    |GitHub Copilot |IDE Extension    |You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.  Return the head of the linked list after doubling it.  Example 1:  Input: head = [1,8,9] Output: [3,7,8] Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.  Example 2:  Input: head = [9,9,9] Output: [1,9,9,8] Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998.   Constraints:  The number of nodes in the list is in the range [1, 10^4] 0 <= Node.val <= 9 The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |class Solution {     public ListNode doubleIt(ListNode head) { /*  *You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.  Return the head of the linked list after doubling it.  Constraints:  The number of nodes in the list is in the range [1, 10^4] 0 <= Node.val <= 9 The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself. */                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |class Solution {     public ListNode doubleIt(ListNode head) {         ListNode curr = head;         ListNode prev = null;         while(curr != null) {             ListNode next = curr.next;             curr.next = prev;             prev = curr;             curr = next;         }                  ListNode newHead = prev;         ListNode newCurr = newHead;         ListNode carry = null;         while(newCurr != null) {             int sum = newCurr.val * 2;             if(carry != null) {                 sum += carry.val;                 carry = null;             }             if(sum > 9) {                 carry = new ListNode(sum / 10);                 sum = sum % 10;             }             newCurr.val = sum;             newCurr = newCurr.next;         }         if(carry != null) {             newCurr = newHead;             while(newCurr.next != null) {                 newCurr = newCurr.next;             }             newCurr.next = carry;         }         return reverse(newHead);     }          public ListNode reverse(ListNode head) {         ListNode curr = head;         ListNode prev = null;         while(curr != null) {             ListNode next = curr.next;             curr.next = prev;             prev = curr;             curr = next;         }                  return prev;     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |class Solution {     public ListNode doubleIt(ListNode head) {         if (head.val > 4)             head = new ListNode(0, head);         for(ListNode node = head; node != null; node = node.next) {             node.val = (node.val * 2) % 10;             if (node.next != null && node.next.val > 4)                 node.val++;         }         return head;     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
|83 |4             |Python  |medium    |GitHub Copilot |IDE Extension    |You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.  Return the head of the linked list after doubling it.  Example 1:  Input: head = [1,8,9] Output: [3,7,8] Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.  Example 2:  Input: head = [9,9,9] Output: [1,9,9,8] Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998.   Constraints:  The number of nodes in the list is in the range [1, 10^4] 0 <= Node.val <= 9 The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |class Solution:     def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]: """You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.  Return the head of the linked list after doubling it.  Example 1:  Input: head = [1,8,9] Output: [3,7,8] Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.  Example 2:  Input: head = [9,9,9] Output: [1,9,9,8] Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998.   Constraints:  The number of nodes in the list is in the range [1, 10^4] 0 <= Node.val <= 9 The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself."""                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |class Solution:     def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:         if head is None:             return None         if head.next is None:             head.val = head.val * 2             return head         node = head         while node:             node.val = node.val * 2             node = node.next         node = head         while node:             if node.val > 9:                 node.val = node.val % 10                 if node.next is None:                     node.next = ListNode(1)                 else:                     node.next.val += 1             node = node.next         return head                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |class Solution:     def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:         if head.val > 4:             head = ListNode(0, head)         node = head         while node:             node.val = (node.val * 2) % 10             if node.next and node.next.val > 4:                 node.val += 1             node = node.next         return head                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
|84 |4             |C++     |medium    |GitHub Copilot |IDE Extension    |You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.  Return the head of the linked list after doubling it.  Example 1:  Input: head = [1,8,9] Output: [3,7,8] Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.  Example 2:  Input: head = [9,9,9] Output: [1,9,9,8] Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998.   Constraints:  The number of nodes in the list is in the range [1, 10^4] 0 <= Node.val <= 9 The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |class Solution { public:     ListNode* doubleIt(ListNode* head) { /*You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.  Return the head of the linked list after doubling it.  Constraints:  The number of nodes in the list is in the range [1, 10^4] 0 <= Node.val <= 9 The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.*/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |class Solution { public:     ListNode* doubleIt(ListNode* head) {         ListNode* temp = head;         ListNode* prev = NULL;         while(temp != NULL) {             temp->val *= 2;             if(temp->val > 9) {                 if(prev == NULL) {                     ListNode* newHead = new ListNode(1);                     newHead->next = head;                     head = newHead;                     temp->val -= 10;                 } else {                     prev->val += 1;                     temp->val -= 10;                 }             }             prev = temp;             temp = temp->next;         }         return head;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |class Solution { public:     ListNode* doubleIt(ListNode* head) {         if (head->val > 4)             head = new ListNode(0, head);         for(ListNode* node = head; node; node = node->next) {             node->val = (node->val * 2) % 10;             if (node->next && node->next->val > 4)                 node->val++;         }         return head;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
|85 |5             |Java    |hard      |GitHub Copilot |IDE Extension    |You are given an array nums of n positive integers and an integer k.  Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:  Choose any non-empty subarray nums[l, ..., r] that you haven't chosen previously. Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index. Multiply your score by x. Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.  The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.  Return the maximum possible score after applying at most k operations.  Since the answer may be large, return it modulo 10^9 + 7.  Example 1:  Input: nums = [8,3,9,3,8], k = 2 Output: 81 Explanation: To get a score of 81, we can apply the following operations: - Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81. It can be proven that 81 is the highest score one can obtain.  Example 2:  Input: nums = [19,12,14,6,10,18], k = 3 Output: 4788 Explanation: To get a score of 4788, we can apply the following operations:  - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19. - Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788. It can be proven that 4788 is the highest score one can obtain.   Constraints:  1 <= nums.length == n <= 10^5 1 <= nums[i] <= 10^5 1 <= k <= min(n * (n + 1) / 2, 10^9) |public class Solution {     public int maximumScore(List<Integer> nums, int k) { /*  * You are given an array nums of n positive integers and an integer k.  Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:  Choose any non-empty subarray nums[l, ..., r] that you haven't chosen previously. Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index. Multiply your score by x. Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.  The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.  Return the maximum possible score after applying at most k operations.  Since the answer may be large, return it modulo 10^9 + 7.  Example 1:  Input: nums = [8,3,9,3,8], k = 2 Output: 81 Explanation: To get a score of 81, we can apply the following operations: - Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81. It can be proven that 81 is the highest score one can obtain.  Example 2:  Input: nums = [19,12,14,6,10,18], k = 3 Output: 4788 Explanation: To get a score of 4788, we can apply the following operations:  - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19. - Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788. It can be proven that 4788 is the highest score one can obtain.   Constraints:  1 <= nums.length == n <= 10^5 1 <= nums[i] <= 10^5 1 <= k <= min(n * (n + 1) / 2, 10^9). */                                                  |public class Solution {     public int maximumScore(List<Integer> nums, int k) {         int n = nums.size();         int[] left = new int[n];         int[] right = new int[n];         Stack<Integer> stack = new Stack<>();         for (int i = 0; i < n; i++) {             while (!stack.isEmpty() && nums.get(stack.peek()) >= nums.get(i)) {                 stack.pop();             }             left[i] = stack.isEmpty() ? -1 : stack.peek();             stack.push(i);         }         stack.clear();         for (int i = n - 1; i >= 0; i--) {             while (!stack.isEmpty() && nums.get(stack.peek()) >= nums.get(i)) {                 stack.pop();             }             right[i] = stack.isEmpty() ? n : stack.peek();             stack.push(i);         }         int ans = 0;         for (int i = 0; i < n; i++) {             if (left[i] < k && right[i] > k) {                 ans = Math.max(ans, nums.get(i) * (right[i] - left[i] - 1));             }         }         return ans;     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |class Solution {     static final int MOD = 1000000007;      public int maximumScore(List<Integer> nums, int k) {         int n = nums.size();          int upper = Collections.max(nums) + 1;          boolean[] prime = new boolean[upper];         int[] primeScore = new int[upper];         Arrays.fill(prime, true);         prime[0] = prime[1] = false;         for (int i = 2; i < upper; i++) {             if (prime[i]) {                 for (int j = i; j < upper; j += i) {                     primeScore[j]++;                     prime[j] = false;                 }             }         }          int[] nextGreaterElement = new int[n];         Arrays.fill(nextGreaterElement, n);         Stack<Integer> s = new Stack<>();         for (int i = n - 1; i >= 0; i--) {             while (!s.empty() && primeScore[nums.get(i)] >= primeScore[nums.get(s.peek())]) {                 s.pop();             }             nextGreaterElement[i] = s.empty() ? n : s.peek();             s.push(i);         }          int[] prevGreaterOrEqualElement = new int[n];         Arrays.fill(prevGreaterOrEqualElement, -1);         s = new Stack<>();         for (int i = 0; i < n; i++) {             while (!s.empty() && primeScore[nums.get(i)] > primeScore[nums.get(s.peek())]) {                 s.pop();             }             prevGreaterOrEqualElement[i] = s.empty() ? -1 : s.peek();             s.push(i);         }          int res = 1;         int[][] tuples = new int[n][2];         for (int i = 0; i < n; i++) {             tuples[i][0] = nums.get(i);             tuples[i][1] = i;         }         Arrays.sort(tuples, new Comparator<int[]>() {             public int compare(int[] a, int[] b) {                 return b[0] - a[0];             }         });         for (int i = 0; i < n; i++) {             int num = tuples[i][0];             int idx = tuples[i][1];             int operations = Math.min((idx - prevGreaterOrEqualElement[idx]) * (nextGreaterElement[idx] - idx), k);             res = (int)((1L * res * pow(num, operations)) % MOD);             k -= operations;             if (k == 0) {                 return res;             }         }          return res;     }      public int pow(int x, int n) {         int res = 1;         while (n > 0) {             if (n % 2 == 1) {                 res = (int)((1L * res * x) % MOD);             }             x = (int)((1L * x * x) % MOD);             n /= 2;         }         return res;     } }|
|86 |5             |Python  |hard      |GitHub Copilot |IDE Extension    |You are given an array nums of n positive integers and an integer k.  Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:  Choose any non-empty subarray nums[l, ..., r] that you haven't chosen previously. Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index. Multiply your score by x. Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.  The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.  Return the maximum possible score after applying at most k operations.  Since the answer may be large, return it modulo 10^9 + 7.  Example 1:  Input: nums = [8,3,9,3,8], k = 2 Output: 81 Explanation: To get a score of 81, we can apply the following operations: - Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81. It can be proven that 81 is the highest score one can obtain.  Example 2:  Input: nums = [19,12,14,6,10,18], k = 3 Output: 4788 Explanation: To get a score of 4788, we can apply the following operations:  - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19. - Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788. It can be proven that 4788 is the highest score one can obtain.   Constraints:  1 <= nums.length == n <= 10^5 1 <= nums[i] <= 10^5 1 <= k <= min(n * (n + 1) / 2, 10^9) |class Solution:     def maximumScore(self, nums: List[int], k: int) -> int: """You are given an array nums of n positive integers and an integer k.  Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:  Choose any non-empty subarray nums[l, ..., r] that you haven't chosen previously. Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index. Multiply your score by x. Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.  The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.  Return the maximum possible score after applying at most k operations.  Since the answer may be large, return it modulo 10^9 + 7.  Example 1:  Input: nums = [8,3,9,3,8], k = 2 Output: 81 Explanation: To get a score of 81, we can apply the following operations: - Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81. It can be proven that 81 is the highest score one can obtain.  Example 2:  Input: nums = [19,12,14,6,10,18], k = 3 Output: 4788 Explanation: To get a score of 4788, we can apply the following operations:  - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19. - Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788. It can be proven that 4788 is the highest score one can obtain.   Constraints:  1 <= nums.length == n <= 10^5 1 <= nums[i] <= 10^5 1 <= k <= min(n * (n + 1) / 2, 10^9)."""                                                          |class Solution:     def maximumScore(self, nums: List[int], k: int) -> int:         n = len(nums)         left, right = k, k         res = nums[k]         min_val = nums[k]         while left > 0 or right < n - 1:             if left == 0:                 right += 1             elif right == n - 1:                 left -= 1             elif nums[left - 1] < nums[right + 1]:                 right += 1             else:                 left -= 1             min_val = min(min_val, nums[left], nums[right])             res = max(res, min_val * (right - left + 1))         return res                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |class Solution:      MOD = 1000000007      def maximumScore(self, nums: List[int], k: int) -> int:         n = len(nums)          upper = max(nums) + 1          prime = [True]*upper         prime[0] = prime[1] = False         primeScore = [0]*upper         for i in range(2, upper):             if prime[i]:                 for j in range(i, upper, i):                     primeScore[j] += 1                     prime[j] = False          nextGreaterElement = [n]*n         s = []         for i in range(n - 1, -1, -1):             while s and primeScore[nums[i]] >= primeScore[nums[s[-1]]]:                 s.pop()             nextGreaterElement[i] = s[-1] if s else n             s.append(i)          prevGreaterOrEqualElement = [-1]*n         s = []         for i in range(n):             while s and primeScore[nums[i]] > primeScore[nums[s[-1]]]:                 s.pop()             prevGreaterOrEqualElement[i] = s[-1] if s else -1             s.append(i)          res = 1         tuples = [[nums[i], i] for i in range(n)]         tuples.sort(reverse=True)         for num, idx in tuples:             operations = min((idx - prevGreaterOrEqualElement[idx]) * (nextGreaterElement[idx] - idx), k)             res = (res * self.pow(num, operations)) % self.MOD             k -= operations             if k == 0:                 return res          return res      def pow(self, x: int, n: int) -> int:         res = 1         while n > 0:             if n % 2 == 1:                 res = (res * x) % self.MOD             x = (x * x) % self.MOD             n //= 2         return res                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
|87 |5             |C++     |hard      |GitHub Copilot |IDE Extension    |You are given an array nums of n positive integers and an integer k.  Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:  Choose any non-empty subarray nums[l, ..., r] that you haven't chosen previously. Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index. Multiply your score by x. Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.  The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.  Return the maximum possible score after applying at most k operations.  Since the answer may be large, return it modulo 10^9 + 7.  Example 1:  Input: nums = [8,3,9,3,8], k = 2 Output: 81 Explanation: To get a score of 81, we can apply the following operations: - Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81. It can be proven that 81 is the highest score one can obtain.  Example 2:  Input: nums = [19,12,14,6,10,18], k = 3 Output: 4788 Explanation: To get a score of 4788, we can apply the following operations:  - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19. - Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788. It can be proven that 4788 is the highest score one can obtain.   Constraints:  1 <= nums.length == n <= 10^5 1 <= nums[i] <= 10^5 1 <= k <= min(n * (n + 1) / 2, 10^9) |class Solution { public:     int maximumScore(vector<int>& nums, int k) { /*You are given an array nums of n positive integers and an integer k.  Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:  Choose any non-empty subarray nums[l, ..., r] that you haven't chosen previously. Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index. Multiply your score by x. Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.  The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.  Return the maximum possible score after applying at most k operations.  Since the answer may be large, return it modulo 10^9 + 7.  Example 1:  Input: nums = [8,3,9,3,8], k = 2 Output: 81 Explanation: To get a score of 81, we can apply the following operations: - Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81. It can be proven that 81 is the highest score one can obtain.  Example 2:  Input: nums = [19,12,14,6,10,18], k = 3 Output: 4788 Explanation: To get a score of 4788, we can apply the following operations:  - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19. - Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788. It can be proven that 4788 is the highest score one can obtain.   Constraints:  1 <= nums.length == n <= 10^5 1 <= nums[i] <= 10^5 1 <= k <= min(n * (n + 1) / 2, 10^9).*/                                                              |class Solution { public:     int maximumScore(vector<int>& nums, int k) {         int n = nums.size();         vector<int> left(n, -1), right(n, n);         stack<int> st;         for(int i = 0; i < n; i++) {             while(!st.empty() && nums[st.top()] >= nums[i]) {                 st.pop();             }             if(!st.empty()) {                 left[i] = st.top();             }             st.push(i);         }         while(!st.empty()) {             st.pop();         }         for(int i = n - 1; i >= 0; i--) {             while(!st.empty() && nums[st.top()] >= nums[i]) {                 st.pop();             }             if(!st.empty()) {                 right[i] = st.top();             }             st.push(i);         }         vector<int> primes(100001, 0);         for(int i = 2; i <= 100000; i++) {             if(primes[i] == 0) {                 for(int j = i; j <= 100000; j += i) {                     primes[j]++;                 }             }         }         vector<int> dp(n, 0);         for(int i = 0; i < n; i++) {             dp[i] = nums[i] * (primes[nums[i]] + 1);         }         for(int i = 1; i < n; i++) {             dp[i] = max(dp[i], dp[i - 1]);         }         int ans = 0;         for(int i = 0; i < n; i++) {             int l = left[i] + 1, r = right[i] - 1;             if(l <= k && k <= r) {                 ans = max(ans, nums[i] * dp[r]);             }             if(l <= k - 1 && k - 1 <= r) {                 ans = max(ans, nums[i] * dp[r]);             }             if(l <= k && k <= r + 1) {                 ans = max(ans, nums[i] * dp[r]);             }             if(l <= k - 1 && k - 1 <= r + 1) {                 ans = max(ans, nums[i] * dp[r]);             }         }         return ans;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |class Solution { public:     const int MOD = 1000000007;      int maximumScore(vector<int>& nums, int k) {         int n = nums.size();          int upper = *max_element(nums.begin(), nums.end()) + 1;          vector<bool> prime(upper, true);         prime[0] = prime[1] = false;         vector<int> primeScore(upper, 0);         for (int i = 2; i < upper; i++) {             if (prime[i]) {                 for (int j = i; j < upper; j += i) {                     primeScore[j]++;                     prime[j] = false;                 }             }         }          vector<int> nextGreaterElement(n, n);         stack<int> s;         for (int i = n - 1; i >= 0; i--) {             while (!s.empty() && primeScore[nums[i]] >= primeScore[nums[s.top()]]) {                 s.pop();             }             nextGreaterElement[i] = s.empty() ? n : s.top();             s.push(i);         }          vector<int> prevGreaterOrEqualElement(n, -1);         s = stack<int>();         for (int i = 0; i < n; i++) {             while (!s.empty() && primeScore[nums[i]] > primeScore[nums[s.top()]]) {                 s.pop();             }             prevGreaterOrEqualElement[i] = s.empty() ? -1 : s.top();             s.push(i);         }          int res = 1;         vector<pair<int, int>> tuples(n);         for (int i = 0; i < n; i++) {             tuples[i].first = nums[i];             tuples[i].second = i;         }         sort(tuples.rbegin(), tuples.rend());         for (const auto& [num, i] : tuples) {             int operations = min((i - prevGreaterOrEqualElement[i]) * (nextGreaterElement[i] - i), k);             res = (int)((1L * res * pow(num, operations)) % MOD);             k -= operations;             if (k == 0) {                 return res;             }         }          return res;     }      int pow(int x, int n) {         int res = 1;         while (n > 0) {             if (n % 2 == 1) {                 res = (int)((1L * res * x) % MOD);             }             x = (int)((1L * x * x) % MOD);             n /= 2;         }         return res;     } };                                                                                                                                                                                                                                                                                                                                                                               |
|88 |6             |Java    |hard      |GitHub Copilot |IDE Extension    |You are given a 0-indexed 2D integer array items of length n and an integer k.  items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.  Let's define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.  Your task is to find the maximum elegance from all subsequences of size k in items.  Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.  Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order.  Example 1:  Input: items = [[3,2],[5,1],[10,1]], k = 2 Output: 17 Explanation: In this example, we have to select a subsequence of size 2. We can select items[0] = [3,2] and items[2] = [10,1]. The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1]. Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance.   Example 2:  Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3 Output: 19 Explanation: In this example, we have to select a subsequence of size 3.  We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3].  The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3].  Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.  Example 3:  Input: items = [[1,1],[2,1],[3,1]], k = 3 Output: 7 Explanation: In this example, we have to select a subsequence of size 3.  We should select all the items.  The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1].  Hence, the maximum elegance is 6 + 1^2 = 7.     Constraints:  1 <= items.length == n <= 10^5 items[i].length == 2 items[i][0] == profit_i items[i][1] == category_i 1 <= profit_i <= 10^9 1 <= category_i <= n  1 <= k <= n                                             |public class Solution {     public int findMaximumElegance(int[][] items, int k) { /*  * You are given a 0-indexed 2D integer array items of length n and an integer k.  items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.  Let's define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.  Your task is to find the maximum elegance from all subsequences of size k in items.  Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.  Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order.  Example 1:  Input: items = [[3,2],[5,1],[10,1]], k = 2 Output: 17 Explanation: In this example, we have to select a subsequence of size 2. We can select items[0] = [3,2] and items[2] = [10,1]. The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1]. Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance.   Example 2:  Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3 Output: 19 Explanation: In this example, we have to select a subsequence of size 3.  We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3].  The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3].  Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.  Example 3:  Input: items = [[1,1],[2,1],[3,1]], k = 3 Output: 7 Explanation: In this example, we have to select a subsequence of size 3.  We should select all the items.  The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1].  Hence, the maximum elegance is 6 + 1^2 = 7.     Constraints:  1 <= items.length == n <= 10^5 items[i].length == 2 items[i][0] == profit_i items[i][1] == category_i 1 <= profit_i <= 10^9 1 <= category_i <= n  1 <= k <= n */                                                                                             |public class Solution {     public int findMaximumElegance(int[][] items, int k) {         int n = items.length;         int[] dp = new int[n];         Arrays.sort(items, (a, b) -> a[0] - b[0]);         int max = 0;         for (int i = 0; i < n; i++) {             int profit = items[i][0];             int category = items[i][1];             dp[i] = profit + category * category;             for (int j = 0; j < i; j++) {                 if (items[j][1] != category) {                     dp[i] = Math.max(dp[i], dp[j] + profit + category * category);                 }             }             if (i >= k - 1) {                 max = Math.max(max, dp[i]);             }         }         return max;     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |class Solution {     public long findMaximumElegance(int[][] A, int k) {         Arrays.sort(A, (a, b) -> b[0] - a[0]);         long res = 0, cur = 0;         List<Integer> dup = new ArrayList<>();         Set<Integer> seen = new HashSet<>();         for (int i = 0; i < A.length; ++i) {             if (i < k) {                 if (seen.contains(A[i][1])) {                     dup.add(A[i][0]);                 }                 cur += A[i][0];             } else if (!seen.contains(A[i][1])) {                 if (dup.isEmpty()) break;                 cur += A[i][0] - dup.remove(dup.size() - 1);             }             seen.add(A[i][1]);             res = Math.max(res, cur + 1L * seen.size() * seen.size());         }         return res;     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|89 |6             |Python  |hard      |GitHub Copilot |IDE Extension    |You are given a 0-indexed 2D integer array items of length n and an integer k.  items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.  Let's define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.  Your task is to find the maximum elegance from all subsequences of size k in items.  Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.  Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order.  Example 1:  Input: items = [[3,2],[5,1],[10,1]], k = 2 Output: 17 Explanation: In this example, we have to select a subsequence of size 2. We can select items[0] = [3,2] and items[2] = [10,1]. The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1]. Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance.   Example 2:  Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3 Output: 19 Explanation: In this example, we have to select a subsequence of size 3.  We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3].  The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3].  Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.  Example 3:  Input: items = [[1,1],[2,1],[3,1]], k = 3 Output: 7 Explanation: In this example, we have to select a subsequence of size 3.  We should select all the items.  The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1].  Hence, the maximum elegance is 6 + 1^2 = 7.     Constraints:  1 <= items.length == n <= 10^5 items[i].length == 2 items[i][0] == profit_i items[i][1] == category_i 1 <= profit_i <= 10^9 1 <= category_i <= n  1 <= k <= n                                             |class Solution:     def findMaximumElegance(self, items: List[List[int]], k: int) -> int: """You are given a 0-indexed 2D integer array items of length n and an integer k.  items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.  Let's define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.  Your task is to find the maximum elegance from all subsequences of size k in items.  Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.  Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order.  Example 1:  Input: items = [[3,2],[5,1],[10,1]], k = 2 Output: 17 Explanation: In this example, we have to select a subsequence of size 2. We can select items[0] = [3,2] and items[2] = [10,1]. The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1]. Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance.   Example 2:  Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3 Output: 19 Explanation: In this example, we have to select a subsequence of size 3.  We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3].  The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3].  Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.  Example 3:  Input: items = [[1,1],[2,1],[3,1]], k = 3 Output: 7 Explanation: In this example, we have to select a subsequence of size 3.  We should select all the items.  The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1].  Hence, the maximum elegance is 6 + 1^2 = 7.     Constraints:  1 <= items.length == n <= 10^5 items[i].length == 2 items[i][0] == profit_i items[i][1] == category_i 1 <= profit_i <= 10^9 1 <= category_i <= n  1 <= k <= n"""                                                                                         |class Solution:     def findMaximumElegance(self, items: List[List[int]], k: int) -> int:         items.sort(key = lambda x: x[0], reverse = True)         category = {}         for i in range(len(items)):             if items[i][1] not in category:                 category[items[i][1]] = 1             else:                 category[items[i][1]] += 1         category = sorted(category.items(), key = lambda x: x[1], reverse = True)         ans = 0         for i in range(k):             ans += items[i][0]         ans += len(category) ** 2         return ans                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |class Solution:     def findMaximumElegance(self, items: List[List[int]], k: int) -> int:         items = sorted(items, key=lambda v: -v[0])         res = cur = 0         A = []         seen = set()         for i, (p, c) in enumerate(items):             if i < k:                 if c in seen:                     A.append(p)                 cur += p             elif c not in seen:                 if not A: break                 cur += p - A.pop()             seen.add(c)             res = max(res, cur + len(seen) * len(seen))         return res                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
|90 |6             |C++     |hard      |GitHub Copilot |IDE Extension    |You are given a 0-indexed 2D integer array items of length n and an integer k.  items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.  Let's define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.  Your task is to find the maximum elegance from all subsequences of size k in items.  Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.  Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order.  Example 1:  Input: items = [[3,2],[5,1],[10,1]], k = 2 Output: 17 Explanation: In this example, we have to select a subsequence of size 2. We can select items[0] = [3,2] and items[2] = [10,1]. The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1]. Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance.   Example 2:  Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3 Output: 19 Explanation: In this example, we have to select a subsequence of size 3.  We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3].  The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3].  Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.  Example 3:  Input: items = [[1,1],[2,1],[3,1]], k = 3 Output: 7 Explanation: In this example, we have to select a subsequence of size 3.  We should select all the items.  The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1].  Hence, the maximum elegance is 6 + 1^2 = 7.     Constraints:  1 <= items.length == n <= 10^5 items[i].length == 2 items[i][0] == profit_i items[i][1] == category_i 1 <= profit_i <= 10^9 1 <= category_i <= n  1 <= k <= n                                             |class Solution { public:     long long findMaximumElegance(vector<vector<int>>& items, int k) { /*You are given a 0-indexed 2D integer array items of length n and an integer k.  items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.  Let's define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.  Your task is to find the maximum elegance from all subsequences of size k in items.  Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.  Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order.  Example 1:  Input: items = [[3,2],[5,1],[10,1]], k = 2 Output: 17 Explanation: In this example, we have to select a subsequence of size 2. We can select items[0] = [3,2] and items[2] = [10,1]. The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1]. Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance.   Example 2:  Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3 Output: 19 Explanation: In this example, we have to select a subsequence of size 3.  We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3].  The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3].  Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.  Example 3:  Input: items = [[1,1],[2,1],[3,1]], k = 3 Output: 7 Explanation: In this example, we have to select a subsequence of size 3.  We should select all the items.  The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1].  Hence, the maximum elegance is 6 + 1^2 = 7.     Constraints:  1 <= items.length == n <= 10^5 items[i].length == 2 items[i][0] == profit_i items[i][1] == category_i 1 <= profit_i <= 10^9 1 <= category_i <= n  1 <= k <= n*/                                                                                     |class Solution { public:     long long findMaximumElegance(vector<vector<int>>& items, int k) {         int n = items.size();         vector<pair<int,int>> v;         for(int i=0;i<n;i++){             v.push_back({items[i][0],items[i][1]});         }         sort(v.begin(),v.end(),greater<pair<int,int>>());         int i=0;         long long ans = 0;         unordered_map<int,int> mp;         while(i<n && k>0){             if(mp[v[i].second]==0){                 ans += v[i].first;                 mp[v[i].second]++;                 k--;             }             i++;         }         return ans + (k*k);     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |class Solution { public:     long long findMaximumElegance(vector<vector<int>>& A, int k) {         sort(A.begin(), A.end(), [](const vector<int>& a, const vector<int>& b) {             return a[0] > b[0];         });         long long res = 0, cur = 0;         vector<int> dup;         unordered_set<int> seen;         for (int i = 0; i < A.size(); ++i) {             if (i < k) {                 if (seen.count(A[i][1])) {                     dup.push_back(A[i][0]);                 }                 cur += A[i][0];             } else if (seen.find(A[i][1]) == seen.end()) {                 if (dup.empty()) break;                 cur += A[i][0] - dup.back();                 dup.pop_back();             }             seen.insert(A[i][1]);             res = fmax(res, cur + 1L * seen.size() * seen.size());         }         return res;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
|91 |1             |Java    |easy      |InstructCodeT5+|HuggingFace Model|You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.  Return the maximum sum or -1 if no such pair exists.  Example 1:  Input: nums = [51,71,17,24,42] Output: 88 Explanation:  For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88.  For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66. It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.  Example 2:  Input: nums = [1,2,3,4] Output: -1 Explanation: No pair exists in nums with equal maximum digits.  Constraints:  2 <= nums.length <= 100 1 <= nums[i] <= 10^4                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |prompt = """ You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.  Return the maximum sum or -1 if no such pair exists.  Example 1:  Input: nums = [51,71,17,24,42] Output: 88 Explanation:  For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88.  For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66. It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.  Example 2:  Input: nums = [1,2,3,4] Output: -1 Explanation: No pair exists in nums with equal maximum digits.  Constraints:  2 <= nums.length <= 100 1 <= nums[i] <= 10^4  class Solution {     public int maxSum(int[] nums) { """                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |class Solution {         public int maxSum(int[] nums) {         int max = Integer.MIN_VALUE;         int sum = 0;         for (int i = 0; i < nums.length; i++) {             sum += nums[i];             if (nums[i] > max) {                 max = nums[i];             }             if (max > 0 && nums[i] % max == 0) {                 sum -= nums[i];             }         }         return sum;     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |class Solution {     public int maxSum(int[] nums) {     int ans = -1;     Map<Integer,List<Integer>> ump = new HashMap<>();     for(int i = 0; i < nums.length; ++i){         int t = nums[i], maxDigit = 0;         while(t != 0){ //evaluate max digit in the number             maxDigit = Math.max(t%10, maxDigit);             t = t/10;         }         if(!ump.containsKey(maxDigit)) ump.put(maxDigit, new ArrayList<>());         ump.get(maxDigit).add(nums[i]); // add the number to the map      }     for(Map.Entry<Integer, List<Integer>> entry: ump.entrySet()){         entry.getValue().sort(Comparator.reverseOrder()); //to find max two number in each max digit          if(entry.getValue().size() >= 2) ans = Math.max(ans, entry.getValue().get(0) + entry.getValue().get(1)); //sum max two number and take max     }     return ans;     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
|92 |1             |Python  |easy      |InstructCodeT5+|HuggingFace Model|You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.  Return the maximum sum or -1 if no such pair exists.  Example 1:  Input: nums = [51,71,17,24,42] Output: 88 Explanation:  For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88.  For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66. It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.  Example 2:  Input: nums = [1,2,3,4] Output: -1 Explanation: No pair exists in nums with equal maximum digits.  Constraints:  2 <= nums.length <= 100 1 <= nums[i] <= 10^4                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |prompt = """ You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.  Return the maximum sum or -1 if no such pair exists.  Example 1:  Input: nums = [51,71,17,24,42] Output: 88 Explanation:  For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88.  For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66. It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.  Example 2:  Input: nums = [1,2,3,4] Output: -1 Explanation: No pair exists in nums with equal maximum digits.  Constraints:  2 <= nums.length <= 100 1 <= nums[i] <= 10^4  class Solution:     def maxSum (self, nums: List[int]) -> int: """                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |class Solution:         def maxSum (self, nums: List[int]) -> int:                  nums.sort()                  max_sum = 0                  for i in range(len(nums)-1):             if nums[i] == nums[i+1]:                 max_sum = max(max_sum, nums[i]*(len(nums)-i-1))                          return max_sum                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |class Solution:     def maxSum(self, nums: List[int]) -> int:         max_by_digit = defaultdict(int)         max_sum = -1          for num in nums:             digit = max(str(num))              if digit in max_by_digit:                 max_sum = max(max_sum, max_by_digit[digit] + num)              max_by_digit[digit] = max(max_by_digit[digit], num)          return max_sum                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
|93 |1             |C++     |easy      |InstructCodeT5+|HuggingFace Model|You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.  Return the maximum sum or -1 if no such pair exists.  Example 1:  Input: nums = [51,71,17,24,42] Output: 88 Explanation:  For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88.  For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66. It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.  Example 2:  Input: nums = [1,2,3,4] Output: -1 Explanation: No pair exists in nums with equal maximum digits.  Constraints:  2 <= nums.length <= 100 1 <= nums[i] <= 10^4                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |prompt = """ You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.  Return the maximum sum or -1 if no such pair exists.  Example 1:  Input: nums = [51,71,17,24,42] Output: 88 Explanation:  For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88.  For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66. It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.  Example 2:  Input: nums = [1,2,3,4] Output: -1 Explanation: No pair exists in nums with equal maximum digits.  Constraints:  2 <= nums.length <= 100 1 <= nums[i] <= 10^4  class Solution { public:     int maxSum(vector<int>& nums) { """                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |class Solution { public:    int maxSum(vector<int>& nums) {         int n = nums.size();         int max_sum = -1;         unordered_map<int, int> mp;         for (int i = 0; i < n; i++) {             for (int j = i + 1; j < n; j++) {                 int sum = nums[i] + nums[j];                 int max_digit = 0;                 for (int k = 0; k < 10; k++) {                     if (sum % 10 == k) {                         max_digit = max(max_digit, k);                     }                     sum /= 10;                 }                 if (mp.find(max_digit)!= mp.end()) {                     max_sum = max(max_sum, sum + mp[max_digit]);                 }                 mp[max_digit] = sum;             }         }         return max_sum;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |class Solution {     public:         int maxSum(vector<int>& nums) {         int res = -1, max_num[10] = {};         for (auto num : nums) {             int max_d = 0;             for (int v = num; v; v /= 10)                 max_d = max(max_d, v % 10);             if (max_num[max_d])                 res = max(res, max_num[max_d] + num);             max_num[max_d] = max(max_num[max_d], num);         }         return res;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|94 |2             |Java    |easy      |InstructCodeT5+|HuggingFace Model|Your laptop keyboard is faulty, and whenever you type a character 'i' on it, it reverses the string that you have written. Typing other characters works as expected.  You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.  Return the final string that will be present on your laptop screen.  Example 1:  Input: s = "string" Output: "rtsng" Explanation:  After typing first character, the text on the screen is "s". After the second character, the text is "st".  After the third character, the text is "str". Since the fourth character is an 'i', the text gets reversed and becomes "rts". After the fifth character, the text is "rtsn".  After the sixth character, the text is "rtsng".  Therefore, we return "rtsng".  Example 2:  Input: s = "poiinter" Output: "ponter" Explanation:  After the first character, the text on the screen is "p". After the second character, the text is "po".  Since the third character you type is an 'i', the text gets reversed and becomes "op".  Since the fourth character you type is an 'i', the text gets reversed and becomes "po". After the fifth character, the text is "pon". After the sixth character, the text is "pont".  After the seventh character, the text is "ponte".  After the eighth character, the text is "ponter".  Therefore, we return "ponter".   Constraints:  1 <= s.length <= 100 s consists of lowercase English letters. s[0] != 'i'                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |prompt = """ Your laptop keyboard is faulty, and whenever you type a character 'i' on it, it reverses the string that you have written. Typing other characters works as expected.  You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.  Return the final string that will be present on your laptop screen.  Example 1:  Input: s = "string" Output: "rtsng" Explanation:  After typing first character, the text on the screen is "s". After the second character, the text is "st".  After the third character, the text is "str". Since the fourth character is an 'i', the text gets reversed and becomes "rts". After the fifth character, the text is "rtsn".  After the sixth character, the text is "rtsng".  Therefore, we return "rtsng".  Example 2:  Input: s = "poiinter" Output: "ponter" Explanation:  After the first character, the text on the screen is "p". After the second character, the text is "po".  Since the third character you type is an 'i', the text gets reversed and becomes "op".  Since the fourth character you type is an 'i', the text gets reversed and becomes "po". After the fifth character, the text is "pon". After the sixth character, the text is "pont".  After the seventh character, the text is "ponte".  After the eighth character, the text is "ponter".  Therefore, we return "ponter".   Constraints:  1 <= s.length <= 100 s consists of lowercase English letters. s[0] != 'i'  public class Solution {     public String finalString(String s) { """                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |public class Solution {         public String finalString(String s) {         StringBuilder sb = new StringBuilder();         for (int i = 0; i < s.length(); i++) {             char c = s.charAt(i);             if (c == 'i') {                 sb.append(c);             } else {                 sb.append(c);                 sb.append(c);             }         }         return sb.toString();     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |class Solution {     public String finalString(String s) {         StringBuilder nm=new StringBuilder();         for(char c:s.toCharArray())         {             if(c=='i')             {                 nm.reverse();             }             else             {                 nm.append(c);             }         }         return nm.toString();     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|95 |2             |Python  |easy      |InstructCodeT5+|HuggingFace Model|Your laptop keyboard is faulty, and whenever you type a character 'i' on it, it reverses the string that you have written. Typing other characters works as expected.  You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.  Return the final string that will be present on your laptop screen.  Example 1:  Input: s = "string" Output: "rtsng" Explanation:  After typing first character, the text on the screen is "s". After the second character, the text is "st".  After the third character, the text is "str". Since the fourth character is an 'i', the text gets reversed and becomes "rts". After the fifth character, the text is "rtsn".  After the sixth character, the text is "rtsng".  Therefore, we return "rtsng".  Example 2:  Input: s = "poiinter" Output: "ponter" Explanation:  After the first character, the text on the screen is "p". After the second character, the text is "po".  Since the third character you type is an 'i', the text gets reversed and becomes "op".  Since the fourth character you type is an 'i', the text gets reversed and becomes "po". After the fifth character, the text is "pon". After the sixth character, the text is "pont".  After the seventh character, the text is "ponte".  After the eighth character, the text is "ponter".  Therefore, we return "ponter".   Constraints:  1 <= s.length <= 100 s consists of lowercase English letters. s[0] != 'i'                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |prompt = """ class Solution:     def finalString(self, s: str) -> str:  Your laptop keyboard is faulty, and whenever you type a character 'i' on it, it reverses the string that you have written. Typing other characters works as expected.  You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.  Return the final string that will be present on your laptop screen.  Example 1:  Input: s = "string" Output: "rtsng"  Example 2:  Input: s = "poiinter" Output: "ponter"   Constraints:  1 <= s.length <= 100 s consists of lowercase English letters. s[0] != 'i' """                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |class Solution:     def finalString(self, s: str) -> str:         res = ""         for i in s:             if i!= 'i':                 res += i             else:                 res = res[::-1]         return res                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |class Solution:     def finalString(self, s: str) -> str:         while "i" in s:             index=s.index("i")              #first half and second half             first=s[:index][::-1]             second=s[index+1:]              s="".join([first,second])         return s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|96 |2             |C++     |easy      |InstructCodeT5+|HuggingFace Model|Your laptop keyboard is faulty, and whenever you type a character 'i' on it, it reverses the string that you have written. Typing other characters works as expected.  You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.  Return the final string that will be present on your laptop screen.  Example 1:  Input: s = "string" Output: "rtsng" Explanation:  After typing first character, the text on the screen is "s". After the second character, the text is "st".  After the third character, the text is "str". Since the fourth character is an 'i', the text gets reversed and becomes "rts". After the fifth character, the text is "rtsn".  After the sixth character, the text is "rtsng".  Therefore, we return "rtsng".  Example 2:  Input: s = "poiinter" Output: "ponter" Explanation:  After the first character, the text on the screen is "p". After the second character, the text is "po".  Since the third character you type is an 'i', the text gets reversed and becomes "op".  Since the fourth character you type is an 'i', the text gets reversed and becomes "po". After the fifth character, the text is "pon". After the sixth character, the text is "pont".  After the seventh character, the text is "ponte".  After the eighth character, the text is "ponter".  Therefore, we return "ponter".   Constraints:  1 <= s.length <= 100 s consists of lowercase English letters. s[0] != 'i'                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |prompt = """ class Solution { public:     string finalString(string s) { /*Your laptop keyboard is faulty, and whenever you type a character 'i' on it, it reverses the string that you have written. Typing other characters works as expected.  You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.  Return the final string that will be present on your laptop screen.  Example 1:  Input: s = "string" Output: "rtsng" Explanation:  After typing first character, the text on the screen is "s". After the second character, the text is "st".  After the third character, the text is "str". Since the fourth character is an 'i', the text gets reversed and becomes "rts". After the fifth character, the text is "rtsn".  After the sixth character, the text is "rtsng".  Therefore, we return "rtsng".  Example 2:  Input: s = "poiinter" Output: "ponter" Explanation:  After the first character, the text on the screen is "p". After the second character, the text is "po".  Since the third character you type is an 'i', the text gets reversed and becomes "op".  Since the fourth character you type is an 'i', the text gets reversed and becomes "po". After the fifth character, the text is "pon". After the sixth character, the text is "pont".  After the seventh character, the text is "ponte".  After the eighth character, the text is "ponter".  Therefore, we return "ponter".   Constraints:  1 <= s.length <= 100 s consists of lowercase English letters. s[0] != 'i'*/ """                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |class Solution { public:         string finalString(string s) {         string res = "";         for (int i = 0; i < s.length(); i++) {             res += s[s.length() - i - 1];         }         return res;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |class Solution { public:     string finalString(const string &s) {         string a, b;         for (char ch : s)             if (ch == 'i')                 swap(a, b);             else                 a += ch;         return string(rbegin(b), rend(b)) + a;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
|97 |3             |Java    |medium    |InstructCodeT5+|HuggingFace Model|You are given a 0-indexed integer array nums and an integer x.  Find the minimum absolute difference between two elements in the array that are at least x indices apart.  In other words, find two indices i and j such that abs(i - j) >= x and abs(nums[i] - nums[j]) is minimized.  Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.  Example 1:  Input: nums = [4,3,2,4], x = 2 Output: 0 Explanation: We can select nums[0] = 4 and nums[3] = 4.  They are at least 2 indices apart, and their absolute difference is the minimum, 0.  It can be shown that 0 is the optimal answer.  Example 2:  Input: nums = [5,3,2,10,15], x = 1 Output: 1 Explanation: We can select nums[1] = 3 and nums[2] = 2. They are at least 1 index apart, and their absolute difference is the minimum, 1. It can be shown that 1 is the optimal answer.  Example 3:  Input: nums = [1,2,3,4], x = 3 Output: 3 Explanation: We can select nums[0] = 1 and nums[3] = 4. They are at least 3 indices apart, and their absolute difference is the minimum, 3. It can be shown that 3 is the optimal answer.   Constraints:  1 <= nums.length <= 10^5 1 <= nums[i] <= 10^9 0 <= x < nums.length                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |prompt = """  class Solution {     public int minAbsoluteDifference(List<Integer> nums, int x) {  /*You are given a 0-indexed integer List<> nums and an integer x.  Find the minimum absolute difference between two elements in the List that are at least x indices apart.  In other words, find two indices i and j such that abs(i - j) >= x and abs(nums.get(i) - nums.get(i)) is minimized. Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.   Constraints:  1 <= nums.size() <= 10^5 1 <= nums.get(i) <= 10^9 0 <= x < nums.size() */ """                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |class Solution {     int minAbsoluteDifference(List<Integer> nums, int x) {         int min = Integer.MAX_VALUE;         int max = Integer.MIN_VALUE;         for (int i = 0; i < nums.size(); i++) {             if (nums.get(i) < min) {                 min = nums.get(i);             }             if (nums.get(i) > max) {                 max = nums.get(i);             }         }         int diff = Integer.MAX_VALUE;         for (int i = 0; i < nums.size(); i++) {             if (Math.abs(nums.get(i) - min) >= x) {                 diff = Math.min(diff, Math.abs(nums.get(i) - min));             }             if (Math.abs(nums.get(i) - max) >= x) {                 diff = Math.min(diff, Math.abs(nums.get(i) - max));             }         }         return diff;     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |class Solution {     int minAbsoluteDifference(List<Integer> nums, int x) {         int ans = Integer.MAX_VALUE;         TreeSet<Integer> s = new TreeSet<>();         for(int i = x; i < nums.size(); ++i){             s.add(nums.get(i-x));             Integer high = s.ceiling(nums.get(i)), low = s.floor(nums.get(i));             if(high != null) ans = Math.min(ans, Math.abs(nums.get(i) - high));             if(low != null) ans = Math.min(ans, Math.abs(nums.get(i) - low));         }         return ans;     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|98 |3             |Python  |medium    |InstructCodeT5+|HuggingFace Model|You are given a 0-indexed integer array nums and an integer x.  Find the minimum absolute difference between two elements in the array that are at least x indices apart.  In other words, find two indices i and j such that abs(i - j) >= x and abs(nums[i] - nums[j]) is minimized.  Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.  Example 1:  Input: nums = [4,3,2,4], x = 2 Output: 0 Explanation: We can select nums[0] = 4 and nums[3] = 4.  They are at least 2 indices apart, and their absolute difference is the minimum, 0.  It can be shown that 0 is the optimal answer.  Example 2:  Input: nums = [5,3,2,10,15], x = 1 Output: 1 Explanation: We can select nums[1] = 3 and nums[2] = 2. They are at least 1 index apart, and their absolute difference is the minimum, 1. It can be shown that 1 is the optimal answer.  Example 3:  Input: nums = [1,2,3,4], x = 3 Output: 3 Explanation: We can select nums[0] = 1 and nums[3] = 4. They are at least 3 indices apart, and their absolute difference is the minimum, 3. It can be shown that 3 is the optimal answer.   Constraints:  1 <= nums.length <= 10^5 1 <= nums[i] <= 10^9 0 <= x < nums.length                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |prompt = """ class Solution:     def minAbsoluteDifference(self, nums: List[int], x: int) -> int: You are given a 0-indexed integer array nums and an integer x.  Find the minimum absolute difference between two elements in the array that are at least x indices apart.  In other words, find two indices i and j such that abs(i - j) >= x and abs(nums[i] - nums[j]) is minimized.  Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.  Example 1:  Input: nums = [4,3,2,4], x = 2 Output: 0 Explanation: We can select nums[0] = 4 and nums[3] = 4.  They are at least 2 indices apart, and their absolute difference is the minimum, 0.  It can be shown that 0 is the optimal answer.  Example 2:  Input: nums = [5,3,2,10,15], x = 1 Output: 1 Explanation: We can select nums[1] = 3 and nums[2] = 2. They are at least 1 index apart, and their absolute difference is the minimum, 1. It can be shown that 1 is the optimal answer.  Example 3:  Input: nums = [1,2,3,4], x = 3 Output: 3 Explanation: We can select nums[0] = 1 and nums[3] = 4. They are at least 3 indices apart, and their absolute difference is the minimum, 3. It can be shown that 3 is the optimal answer.   Constraints:  1 <= nums.length <= 10^5 1 <= nums[i] <= 10^9 0 <= x < nums.length  """                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |class Solution:     def minAbsoluteDifference(self, nums: List[int], x: int) -> int:         nums.sort()         res = float('inf')         for i in range(len(nums)-1):             res = min(res, abs(nums[i]-nums[i+1]))         return res                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |class Solution:   def minAbsoluteDifference(self, nums: List[int], x: int) -> int:     if x == 0:       return 0      arr, best_dist = SortedList([]), float('inf')     for i in range(x, len(nums)):       arr.add(nums[i - x])       v = nums[i]        pos = arr.bisect_left(v)       if pos < len(arr):         best_dist = min(best_dist, abs(arr[pos] - v))       if pos > 0:         best_dist = min(best_dist, abs(arr[pos - 1] - v))          return best_dist                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
|99 |3             |C++     |medium    |InstructCodeT5+|HuggingFace Model|You are given a 0-indexed integer array nums and an integer x.  Find the minimum absolute difference between two elements in the array that are at least x indices apart.  In other words, find two indices i and j such that abs(i - j) >= x and abs(nums[i] - nums[j]) is minimized.  Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.  Example 1:  Input: nums = [4,3,2,4], x = 2 Output: 0 Explanation: We can select nums[0] = 4 and nums[3] = 4.  They are at least 2 indices apart, and their absolute difference is the minimum, 0.  It can be shown that 0 is the optimal answer.  Example 2:  Input: nums = [5,3,2,10,15], x = 1 Output: 1 Explanation: We can select nums[1] = 3 and nums[2] = 2. They are at least 1 index apart, and their absolute difference is the minimum, 1. It can be shown that 1 is the optimal answer.  Example 3:  Input: nums = [1,2,3,4], x = 3 Output: 3 Explanation: We can select nums[0] = 1 and nums[3] = 4. They are at least 3 indices apart, and their absolute difference is the minimum, 3. It can be shown that 3 is the optimal answer.   Constraints:  1 <= nums.length <= 10^5 1 <= nums[i] <= 10^9 0 <= x < nums.length                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |prompt = """ /*You are given a 0-indexed integer List<> nums and an integer x.  Find the minimum absolute difference between two elements in the List that are at least x indices apart.  In other words, find two indices i and j such that abs(i - j) >= x and abs(nums.get(i) - nums.get(i)) is minimized.  Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.   Constraints:  1 <= nums.size() <= 10^5 1 <= nums.get(i) <= 10^9 0 <= x < nums.size() */  class Solution { public:     int minAbsoluteDifference(vector<int>& nums, int x) { """                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |class Solution { public:         int minAbsoluteDifference(vector<int>& nums, int x) {         int min = INT_MAX;         int n = nums.size();         for (int i = 0; i < n; i++) {             for (int j = i + 1; j < n; j++) {                 if (abs(nums[i] - nums[j]) >= x)                     continue;                 min = min < abs(nums[i] - nums[j])? abs(nums[i] - nums[j]) : min;             }         }         return min;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |class Solution { public:     int minAbsoluteDifference(vector<int>& nums, int x) {         int ans = INT_MAX;         set<int> s;         for(int i = x; i < nums.size(); ++i){             s.insert(nums[i-x]);             auto it = s.upper_bound(nums[i]);             if(it != s.end()) ans = min(ans, abs(nums[i] - *it));             if(it != s.begin()) ans = min(ans, abs(nums[i] - *prev(it)));         }         return ans;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|100|4             |Java    |medium    |InstructCodeT5+|HuggingFace Model|You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.  Return the head of the linked list after doubling it.  Example 1:  Input: head = [1,8,9] Output: [3,7,8] Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.  Example 2:  Input: head = [9,9,9] Output: [1,9,9,8] Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998.   Constraints:  The number of nodes in the list is in the range [1, 10^4] 0 <= Node.val <= 9 The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |prompt = """ class Solution {     public ListNode doubleIt(ListNode head) { /*You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.  Return the head of the linked list after doubling it.  Example 1:  Input: head = [1,8,9] Output: [3,7,8]  Example 2:  Input: head = [9,9,9] Output: [1,9,9,8]  Constraints:  The number of nodes in the list is in the range [1, 10^4] 0 <= Node.val <= 9 The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.*/ """                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |class Solution {     public ListNode doubleIt(ListNode head) {         ListNode curr = head;         int currVal = 0;         while (curr!= null) {             currVal += curr.val;             curr.val = currVal;             curr = curr.next;         }         curr = head;         while (curr!= null) {             curr.val = curr.val * 2;             curr = curr.next;         }         return head;     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |class Solution {     public ListNode doubleIt(ListNode head) {         if (head.val > 4)             head = new ListNode(0, head);         for(ListNode node = head; node != null; node = node.next) {             node.val = (node.val * 2) % 10;             if (node.next != null && node.next.val > 4)                 node.val++;         }         return head;     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
|101|4             |Python  |medium    |InstructCodeT5+|HuggingFace Model|You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.  Return the head of the linked list after doubling it.  Example 1:  Input: head = [1,8,9] Output: [3,7,8] Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.  Example 2:  Input: head = [9,9,9] Output: [1,9,9,8] Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998.   Constraints:  The number of nodes in the list is in the range [1, 10^4] 0 <= Node.val <= 9 The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |prompt = """ class Solution:     def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]: You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.  Return the head of the linked list after doubling it.  Example 1:  Input: head = [1,8,9] Output: [3,7,8] Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.  Example 2:  Input: head = [9,9,9] Output: [1,9,9,8] Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998.   Constraints:  The number of nodes in the list is in the range [1, 10^4] 0 <= Node.val <= 9 The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself. """                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |class Solution:     def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:         if not head:             return head                  curr = head         while curr:             curr.val *= 2             curr = curr.next         return head                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |class Solution:     def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:         if head.val > 4:             head = ListNode(0, head)         node = head         while node:             node.val = (node.val * 2) % 10             if node.next and node.next.val > 4:                 node.val += 1             node = node.next         return head                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
|102|4             |C++     |medium    |InstructCodeT5+|HuggingFace Model|You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.  Return the head of the linked list after doubling it.  Example 1:  Input: head = [1,8,9] Output: [3,7,8] Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.  Example 2:  Input: head = [9,9,9] Output: [1,9,9,8] Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998.   Constraints:  The number of nodes in the list is in the range [1, 10^4] 0 <= Node.val <= 9 The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |prompt = """ /*You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.  Return the head of the linked list after doubling it.  Example 1:  Input: head = [1,8,9] Output: [3,7,8] Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.  Example 2:  Input: head = [9,9,9] Output: [1,9,9,8] Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998.   Constraints:  The number of nodes in the list is in the range [1, 10^4] 0 <= Node.val <= 9 The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.  */  class Solution { public:     ListNode* doubleIt(ListNode* head) { """                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |class Solution { public:         ListNode* doubleIt(ListNode* head) {         if(head == NULL) return NULL;         ListNode* cur = head;         ListNode* pre = NULL;         ListNode* next = NULL;         while(cur!= NULL) {             next = cur->next;             cur->next = pre;             pre = cur;             cur = next;         }         cur = pre;         while(cur!= NULL) {             cur->val *= 2;             cur = cur->next;         }         return pre;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |class Solution { public:     ListNode* doubleIt(ListNode* head) {         if (head->val > 4)             head = new ListNode(0, head);         for(ListNode* node = head; node; node = node->next) {             node->val = (node->val * 2) % 10;             if (node->next && node->next->val > 4)                 node->val++;         }         return head;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
|103|5             |Java    |hard      |InstructCodeT5+|HuggingFace Model|You are given an array nums of n positive integers and an integer k.  Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:  Choose any non-empty subarray nums[l, ..., r] that you haven't chosen previously. Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index. Multiply your score by x. Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.  The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.  Return the maximum possible score after applying at most k operations.  Since the answer may be large, return it modulo 10^9 + 7.  Example 1:  Input: nums = [8,3,9,3,8], k = 2 Output: 81 Explanation: To get a score of 81, we can apply the following operations: - Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81. It can be proven that 81 is the highest score one can obtain.  Example 2:  Input: nums = [19,12,14,6,10,18], k = 3 Output: 4788 Explanation: To get a score of 4788, we can apply the following operations:  - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19. - Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788. It can be proven that 4788 is the highest score one can obtain.   Constraints:  1 <= nums.length == n <= 10^5 1 <= nums[i] <= 10^5 1 <= k <= min(n * (n + 1) / 2, 10^9) |prompt = """ You are given an array nums of n positive integers and an integer k.  Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:  Choose any non-empty subarray nums[l, ..., r] that you haven't chosen previously. Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index. Multiply your score by x. Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.  The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.  Return the maximum possible score after applying at most k operations.  Since the answer may be large, return it modulo 10^9 + 7.  Example 1:  Input: nums = [8,3,9,3,8], k = 2 Output: 81  Example 2:  Input: nums = [19,12,14,6,10,18], k = 3 Output: 4788   Constraints:  1 <= nums.length == n <= 10^5 1 <= nums[i] <= 10^5 1 <= k <= min(n * (n + 1) / 2, 10^9)  class Solution {     public int maximumScore(List<Integer> nums, int k) { """                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |class Solution {    public int maximumScore(List<Integer> nums, int k) {         int n = nums.size();         int[] primes = new int[n];         int[] scores = new int[n];         Arrays.fill(primes, -1);         Arrays.fill(scores, 1);                  for (int i = 0; i < n; i++) {             primes[i] = getPrime(nums.get(i));         }                  int maxScore = 0;         for (int i = 0; i < n; i++) {             for (int j = i + 1; j < n; j++) {                 int l = Math.max(i, primes[i] - 1);                 int r = Math.min(j, primes[j] - 1);                 int score = (r - l + 1) * scores[j];                 if (score > maxScore) {                     maxScore = score;                 }             }         }                  return (int) (maxScore % (1e9 + 7));     }          private int getPrime(int num) {         int res = num;         for (int i = 2; i * i <= num; i++) {             if (num % i == 0) {                 res = i;                 break;             }         }         return res;     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |class Solution {     static final int MOD = 1000000007;      public int maximumScore(List<Integer> nums, int k) {         int n = nums.size();          int upper = Collections.max(nums) + 1;          boolean[] prime = new boolean[upper];         int[] primeScore = new int[upper];         Arrays.fill(prime, true);         prime[0] = prime[1] = false;         for (int i = 2; i < upper; i++) {             if (prime[i]) {                 for (int j = i; j < upper; j += i) {                     primeScore[j]++;                     prime[j] = false;                 }             }         }          int[] nextGreaterElement = new int[n];         Arrays.fill(nextGreaterElement, n);         Stack<Integer> s = new Stack<>();         for (int i = n - 1; i >= 0; i--) {             while (!s.empty() && primeScore[nums.get(i)] >= primeScore[nums.get(s.peek())]) {                 s.pop();             }             nextGreaterElement[i] = s.empty() ? n : s.peek();             s.push(i);         }          int[] prevGreaterOrEqualElement = new int[n];         Arrays.fill(prevGreaterOrEqualElement, -1);         s = new Stack<>();         for (int i = 0; i < n; i++) {             while (!s.empty() && primeScore[nums.get(i)] > primeScore[nums.get(s.peek())]) {                 s.pop();             }             prevGreaterOrEqualElement[i] = s.empty() ? -1 : s.peek();             s.push(i);         }          int res = 1;         int[][] tuples = new int[n][2];         for (int i = 0; i < n; i++) {             tuples[i][0] = nums.get(i);             tuples[i][1] = i;         }         Arrays.sort(tuples, new Comparator<int[]>() {             public int compare(int[] a, int[] b) {                 return b[0] - a[0];             }         });         for (int i = 0; i < n; i++) {             int num = tuples[i][0];             int idx = tuples[i][1];             int operations = Math.min((idx - prevGreaterOrEqualElement[idx]) * (nextGreaterElement[idx] - idx), k);             res = (int)((1L * res * pow(num, operations)) % MOD);             k -= operations;             if (k == 0) {                 return res;             }         }          return res;     }      public int pow(int x, int n) {         int res = 1;         while (n > 0) {             if (n % 2 == 1) {                 res = (int)((1L * res * x) % MOD);             }             x = (int)((1L * x * x) % MOD);             n /= 2;         }         return res;     } }|
|104|5             |Python  |hard      |InstructCodeT5+|HuggingFace Model|You are given an array nums of n positive integers and an integer k.  Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:  Choose any non-empty subarray nums[l, ..., r] that you haven't chosen previously. Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index. Multiply your score by x. Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.  The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.  Return the maximum possible score after applying at most k operations.  Since the answer may be large, return it modulo 10^9 + 7.  Example 1:  Input: nums = [8,3,9,3,8], k = 2 Output: 81 Explanation: To get a score of 81, we can apply the following operations: - Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81. It can be proven that 81 is the highest score one can obtain.  Example 2:  Input: nums = [19,12,14,6,10,18], k = 3 Output: 4788 Explanation: To get a score of 4788, we can apply the following operations:  - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19. - Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788. It can be proven that 4788 is the highest score one can obtain.   Constraints:  1 <= nums.length == n <= 10^5 1 <= nums[i] <= 10^5 1 <= k <= min(n * (n + 1) / 2, 10^9) |prompt = """ You are given an array nums of n positive integers and an integer k.  Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:  Choose any non-empty subarray nums[l, ..., r] that you haven't chosen previously. Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index. Multiply your score by x. Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.  The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.  Return the maximum possible score after applying at most k operations.  Since the answer may be large, return it modulo 10^9 + 7.  Example 1:  Input: nums = [8,3,9,3,8], k = 2 Output: 81 Explanation: To get a score of 81, we can apply the following operations: - Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81. It can be proven that 81 is the highest score one can obtain.  Example 2:  Input: nums = [19,12,14,6,10,18], k = 3 Output: 4788 Explanation: To get a score of 4788, we can apply the following operations:  - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19. - Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788. It can be proven that 4788 is the highest score one can obtain.   Constraints:  1 <= nums.length == n <= 10^5 1 <= nums[i] <= 10^5 1 <= k <= min(n * (n + 1) / 2, 10^9)  class Solution:     def maximumScore(self, nums: List[int], k: int) -> int: """                                               |class Solution:         def maximumScore(self, nums: List[int], k: int) -> int:                  n = len(nums)                  @lru_cache(None)         def dp(l, r, k):             if k == 0:                 return 0             if l > r:                 return 0             if l == r:                 return nums[l]                          res = 0             for i in range(l, r + 1):                 if i == l:                     res = max(res, dp(l + 1, r, k - 1))                 elif i == r:                     res = max(res, dp(l, r - 1, k - 1))                 else:                     res = max(res, dp(l + 1, r, k - 1) + nums[i] * nums[i])                     res = max(res, dp(l, r - 1, k - 1) + nums[i] * nums[i])             return res % (10**9 + 7)                  return dp(0, n - 1, k)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |class Solution:      MOD = 1000000007      def maximumScore(self, nums: List[int], k: int) -> int:         n = len(nums)          upper = max(nums) + 1          prime = [True]*upper         prime[0] = prime[1] = False         primeScore = [0]*upper         for i in range(2, upper):             if prime[i]:                 for j in range(i, upper, i):                     primeScore[j] += 1                     prime[j] = False          nextGreaterElement = [n]*n         s = []         for i in range(n - 1, -1, -1):             while s and primeScore[nums[i]] >= primeScore[nums[s[-1]]]:                 s.pop()             nextGreaterElement[i] = s[-1] if s else n             s.append(i)          prevGreaterOrEqualElement = [-1]*n         s = []         for i in range(n):             while s and primeScore[nums[i]] > primeScore[nums[s[-1]]]:                 s.pop()             prevGreaterOrEqualElement[i] = s[-1] if s else -1             s.append(i)          res = 1         tuples = [[nums[i], i] for i in range(n)]         tuples.sort(reverse=True)         for num, idx in tuples:             operations = min((idx - prevGreaterOrEqualElement[idx]) * (nextGreaterElement[idx] - idx), k)             res = (res * self.pow(num, operations)) % self.MOD             k -= operations             if k == 0:                 return res          return res      def pow(self, x: int, n: int) -> int:         res = 1         while n > 0:             if n % 2 == 1:                 res = (res * x) % self.MOD             x = (x * x) % self.MOD             n //= 2         return res                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
|105|5             |C++     |hard      |InstructCodeT5+|HuggingFace Model|You are given an array nums of n positive integers and an integer k.  Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:  Choose any non-empty subarray nums[l, ..., r] that you haven't chosen previously. Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index. Multiply your score by x. Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.  The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.  Return the maximum possible score after applying at most k operations.  Since the answer may be large, return it modulo 10^9 + 7.  Example 1:  Input: nums = [8,3,9,3,8], k = 2 Output: 81 Explanation: To get a score of 81, we can apply the following operations: - Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81. It can be proven that 81 is the highest score one can obtain.  Example 2:  Input: nums = [19,12,14,6,10,18], k = 3 Output: 4788 Explanation: To get a score of 4788, we can apply the following operations:  - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19. - Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788. It can be proven that 4788 is the highest score one can obtain.   Constraints:  1 <= nums.length == n <= 10^5 1 <= nums[i] <= 10^5 1 <= k <= min(n * (n + 1) / 2, 10^9) |prompt = """ class Solution { public:     int maximumScore(vector<int>& nums, int k) {  /*You are given an array nums of n positive integers and an integer k.  Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:  Choose any non-empty subarray nums[l, ..., r] that you haven't chosen previously. Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index. Multiply your score by x. Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.  The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.  Return the maximum possible score after applying at most k operations.  Since the answer may be large, return it modulo 10^9 + 7.  Example 1:  Input: nums = [8,3,9,3,8], k = 2 Output: 81  Example 2:  Input: nums = [19,12,14,6,10,18], k = 3 Output: 4788   Constraints:  1 <= nums.length == n <= 10^5 1 <= nums[i] <= 10^5 1 <= k <= min(n * (n + 1) / 2, 10^9)  */ """                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |class Solution { public:         int getPrimeScore(int num) {         int count = 0;         for (int i = 2; i * i <= num; i++) {             while (num % i == 0) {                 num /= i;                 count++;             }         }         return count;     }      int getMaxPrimeScore(vector<int>& nums, int l, int r) {         int maxPrimeScore = 0;         for (int i = l; i <= r; i++) {             maxPrimeScore = max(maxPrimeScore, getPrimeScore(nums[i]));         }         return maxPrimeScore;     }      int getMaxScore(vector<int>& nums, int l, int r) {         int maxScore = 0;         for (int i = l; i <= r; i++) {             maxScore = max(maxScore, nums[i]);         }         return maxScore;     }      int maximumScore(vector<int>& nums, int k) {         int score = 1;         int maxScore = 0;          int l = 0;         int r = nums.size() - 1;                  for (int i = 0; i < k; i++) {             int temp = getMaxScore(nums, l, r);             maxScore = max(maxScore, temp);             int tempPrimeScore = getMaxPrimeScore(nums, l, r);             int tempScore = temp * tempPrimeScore;             l = l + 1;             r = r - 1;         }                  return maxScore;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |class Solution { public:     const int MOD = 1000000007;      int maximumScore(vector<int>& nums, int k) {         int n = nums.size();          int upper = *max_element(nums.begin(), nums.end()) + 1;          vector<bool> prime(upper, true);         prime[0] = prime[1] = false;         vector<int> primeScore(upper, 0);         for (int i = 2; i < upper; i++) {             if (prime[i]) {                 for (int j = i; j < upper; j += i) {                     primeScore[j]++;                     prime[j] = false;                 }             }         }          vector<int> nextGreaterElement(n, n);         stack<int> s;         for (int i = n - 1; i >= 0; i--) {             while (!s.empty() && primeScore[nums[i]] >= primeScore[nums[s.top()]]) {                 s.pop();             }             nextGreaterElement[i] = s.empty() ? n : s.top();             s.push(i);         }          vector<int> prevGreaterOrEqualElement(n, -1);         s = stack<int>();         for (int i = 0; i < n; i++) {             while (!s.empty() && primeScore[nums[i]] > primeScore[nums[s.top()]]) {                 s.pop();             }             prevGreaterOrEqualElement[i] = s.empty() ? -1 : s.top();             s.push(i);         }          int res = 1;         vector<pair<int, int>> tuples(n);         for (int i = 0; i < n; i++) {             tuples[i].first = nums[i];             tuples[i].second = i;         }         sort(tuples.rbegin(), tuples.rend());         for (const auto& [num, i] : tuples) {             int operations = min((i - prevGreaterOrEqualElement[i]) * (nextGreaterElement[i] - i), k);             res = (int)((1L * res * pow(num, operations)) % MOD);             k -= operations;             if (k == 0) {                 return res;             }         }          return res;     }      int pow(int x, int n) {         int res = 1;         while (n > 0) {             if (n % 2 == 1) {                 res = (int)((1L * res * x) % MOD);             }             x = (int)((1L * x * x) % MOD);             n /= 2;         }         return res;     } };                                                                                                                                                                                                                                                                                                                                                                               |
|106|6             |Java    |hard      |InstructCodeT5+|HuggingFace Model|You are given a 0-indexed 2D integer array items of length n and an integer k.  items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.  Let's define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.  Your task is to find the maximum elegance from all subsequences of size k in items.  Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.  Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order.  Example 1:  Input: items = [[3,2],[5,1],[10,1]], k = 2 Output: 17 Explanation: In this example, we have to select a subsequence of size 2. We can select items[0] = [3,2] and items[2] = [10,1]. The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1]. Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance.   Example 2:  Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3 Output: 19 Explanation: In this example, we have to select a subsequence of size 3.  We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3].  The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3].  Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.  Example 3:  Input: items = [[1,1],[2,1],[3,1]], k = 3 Output: 7 Explanation: In this example, we have to select a subsequence of size 3.  We should select all the items.  The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1].  Hence, the maximum elegance is 6 + 1^2 = 7.     Constraints:  1 <= items.length == n <= 10^5 items[i].length == 2 items[i][0] == profit_i items[i][1] == category_i 1 <= profit_i <= 10^9 1 <= category_i <= n  1 <= k <= n                                             |prompt = """ /*You are given a 0-indexed 2D integer array items of length n and an integer k.  items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.  Let's define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.  Your task is to find the maximum elegance from all subsequences of size k in items.  Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.  Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order.  Example 1:  Input: items = [[3,2],[5,1],[10,1]], k = 2 Output: 17 Explanation: In this example, we have to select a subsequence of size 2. We can select items[0] = [3,2] and items[2] = [10,1]. The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1]. Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance.   Example 2:  Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3 Output: 19 Explanation: In this example, we have to select a subsequence of size 3.  We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3].  The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3].  Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.  Example 3:  Input: items = [[1,1],[2,1],[3,1]], k = 3 Output: 7 Explanation: In this example, we have to select a subsequence of size 3.  We should select all the items.  The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1].  Hence, the maximum elegance is 6 + 1^2 = 7.     Constraints:  1 <= items.length == n <= 10^5 items[i].length == 2 items[i][0] == profit_i items[i][1] == category_i 1 <= profit_i <= 10^9 1 <= category_i <= n  1 <= k <= n*/  class Solution {     public long findMaximumElegance(int[][] items, int k) { """                                                                                      |class Solution {         public long findMaximumElegance(int[][] items, int k) {         int n = items.length;         int[][] dp = new int[n + 1][k + 1];         for (int i = 0; i <= n; i++) {             for (int j = 0; j <= k; j++) {                 if (i == 0) {                     dp[i][j] = 0;                 } else if (j == 0) {                     dp[i][j] = 0;                 } else if (j == 1) {                     dp[i][j] = items[i - 1][0];                 } else {                     dp[i][j] = Math.max(dp[i - 1][j], items[i - 1][0] + dp[i - 1][j - 1]);                 }             }         }         return dp[n][k];     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |class Solution {     public long findMaximumElegance(int[][] A, int k) {         Arrays.sort(A, (a, b) -> b[0] - a[0]);         long res = 0, cur = 0;         List<Integer> dup = new ArrayList<>();         Set<Integer> seen = new HashSet<>();         for (int i = 0; i < A.length; ++i) {             if (i < k) {                 if (seen.contains(A[i][1])) {                     dup.add(A[i][0]);                 }                 cur += A[i][0];             } else if (!seen.contains(A[i][1])) {                 if (dup.isEmpty()) break;                 cur += A[i][0] - dup.remove(dup.size() - 1);             }             seen.add(A[i][1]);             res = Math.max(res, cur + 1L * seen.size() * seen.size());         }         return res;     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|107|6             |Python  |hard      |InstructCodeT5+|HuggingFace Model|You are given a 0-indexed 2D integer array items of length n and an integer k.  items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.  Let's define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.  Your task is to find the maximum elegance from all subsequences of size k in items.  Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.  Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order.  Example 1:  Input: items = [[3,2],[5,1],[10,1]], k = 2 Output: 17 Explanation: In this example, we have to select a subsequence of size 2. We can select items[0] = [3,2] and items[2] = [10,1]. The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1]. Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance.   Example 2:  Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3 Output: 19 Explanation: In this example, we have to select a subsequence of size 3.  We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3].  The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3].  Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.  Example 3:  Input: items = [[1,1],[2,1],[3,1]], k = 3 Output: 7 Explanation: In this example, we have to select a subsequence of size 3.  We should select all the items.  The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1].  Hence, the maximum elegance is 6 + 1^2 = 7.     Constraints:  1 <= items.length == n <= 10^5 items[i].length == 2 items[i][0] == profit_i items[i][1] == category_i 1 <= profit_i <= 10^9 1 <= category_i <= n  1 <= k <= n                                             |prompt = """ You are given a 0-indexed 2D integer array items of length n and an integer k.  items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.  Let's define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.  Your task is to find the maximum elegance from all subsequences of size k in items.  Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.  Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order.  Example 1:  Input: items = [[3,2],[5,1],[10,1]], k = 2 Output: 17 Explanation: In this example, we have to select a subsequence of size 2. We can select items[0] = [3,2] and items[2] = [10,1]. The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1]. Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance.   Example 2:  Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3 Output: 19 Explanation: In this example, we have to select a subsequence of size 3.  We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3].  The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3].  Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.  Example 3:  Input: items = [[1,1],[2,1],[3,1]], k = 3 Output: 7 Explanation: In this example, we have to select a subsequence of size 3.  We should select all the items.  The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1].  Hence, the maximum elegance is 6 + 1^2 = 7.     Constraints:  1 <= items.length == n <= 10^5 items[i].length == 2 items[i][0] == profit_i items[i][1] == category_i 1 <= profit_i <= 10^9 1 <= category_i <= n  1 <= k <= n  class Solution:     def findMaximumElegance(self, items: List[List[int]], k: int) -> int: """                                                                             |class Solution:         def findMaximumElegance(self, items: List[List[int]], k: int) -> int:                  @lru_cache(None)         def dp(i, k):             if k == 0:                 return 0             if i == len(items):                 return float('-inf')             return max(dp(i + 1, k), items[i][0] + dp(i + 1, k - 1))                  return dp(0, k)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |class Solution:     def findMaximumElegance(self, items: List[List[int]], k: int) -> int:         items = sorted(items, key=lambda v: -v[0])         res = cur = 0         A = []         seen = set()         for i, (p, c) in enumerate(items):             if i < k:                 if c in seen:                     A.append(p)                 cur += p             elif c not in seen:                 if not A: break                 cur += p - A.pop()             seen.add(c)             res = max(res, cur + len(seen) * len(seen))         return res                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
|108|6             |C++     |hard      |InstructCodeT5+|HuggingFace Model|You are given a 0-indexed 2D integer array items of length n and an integer k.  items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.  Let's define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.  Your task is to find the maximum elegance from all subsequences of size k in items.  Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.  Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order.  Example 1:  Input: items = [[3,2],[5,1],[10,1]], k = 2 Output: 17 Explanation: In this example, we have to select a subsequence of size 2. We can select items[0] = [3,2] and items[2] = [10,1]. The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1]. Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance.   Example 2:  Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3 Output: 19 Explanation: In this example, we have to select a subsequence of size 3.  We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3].  The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3].  Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.  Example 3:  Input: items = [[1,1],[2,1],[3,1]], k = 3 Output: 7 Explanation: In this example, we have to select a subsequence of size 3.  We should select all the items.  The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1].  Hence, the maximum elegance is 6 + 1^2 = 7.     Constraints:  1 <= items.length == n <= 10^5 items[i].length == 2 items[i][0] == profit_i items[i][1] == category_i 1 <= profit_i <= 10^9 1 <= category_i <= n  1 <= k <= n                                             |prompt = """ You are given a 0-indexed 2D integer array items of length n and an integer k.  items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.  Let's define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.  Your task is to find the maximum elegance from all subsequences of size k in items.  Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.  Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order.  Constraints:  1 <= items.length == n <= 10^5 items[i].length == 2 items[i][0] == profit_i items[i][1] == category_i 1 <= profit_i <= 10^9 1 <= category_i <= n  1 <= k <= n   class Solution { public:     long long findMaximumElegance(vector<vector<int>>& items, int k) { """                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |class Solution { public:    long long findMaximumElegance(vector<vector<int>>& items, int k) {         int n = items.size();         vector<vector<int>> dp(n, vector<int>(2, 0));         dp[0][0] = items[0][0];         dp[0][1] = 1;         for (int i = 1; i < n; i++) {             dp[i][0] = max(dp[i - 1][0], items[i][0]);             dp[i][1] = dp[i - 1][1] + 1;         }         long long res = 0;         for (int i = 0; i < n - k + 1; i++) {             res = max(res, static_cast<long long>(dp[i][0] + dp[i + k - 1][0] + dp[i][1] * dp[i + k - 1][1]));         }         return res;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |class Solution { public:     long long findMaximumElegance(vector<vector<int>>& A, int k) {         sort(A.begin(), A.end(), [](const vector<int>& a, const vector<int>& b) {             return a[0] > b[0];         });         long long res = 0, cur = 0;         vector<int> dup;         unordered_set<int> seen;         for (int i = 0; i < A.size(); ++i) {             if (i < k) {                 if (seen.count(A[i][1])) {                     dup.push_back(A[i][0]);                 }                 cur += A[i][0];             } else if (seen.find(A[i][1]) == seen.end()) {                 if (dup.empty()) break;                 cur += A[i][0] - dup.back();                 dup.pop_back();             }             seen.insert(A[i][1]);             res = fmax(res, cur + 1L * seen.size() * seen.size());         }         return res;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
|109|1             |Java    |easy      |StarCoder      |IDE Extension    |You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.  Return the maximum sum or -1 if no such pair exists.  Example 1:  Input: nums = [51,71,17,24,42] Output: 88 Explanation:  For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88.  For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66. It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.  Example 2:  Input: nums = [1,2,3,4] Output: -1 Explanation: No pair exists in nums with equal maximum digits.  Constraints:  2 <= nums.length <= 100 1 <= nums[i] <= 10^4                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |public class Solution{     public int maxSum(int[] nums){         /*          * You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.  Return the maximum sum or -1 if no such pair exists.  Example 1:  Input: nums = [51,71,17,24,42] Output: 88 Explanation:  For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88.  For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66. It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.  Example 2:  Input: nums = [1,2,3,4] Output: -1 Explanation: No pair exists in nums with equal maximum digits.  Constraints:  2 <= nums.length <= 100 1 <= nums[i] <= 10^4 */                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |public class Solution{     public int maxSum(int[] nums){         int maxSum = Integer.MIN_VALUE;         for (int i = 0; i < nums.length; i++) {             for (int j = i + 1; j < nums.length; j++) {                 if (nums[i] % 10 == nums[j] % 10) {                     maxSum = Math.max(maxSum, nums[i] + nums[j]);                 }             }         }         return maxSum == Integer.MIN_VALUE? -1 : maxSum;      }      }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |class Solution {     public int maxSum(int[] nums) {     int ans = -1;     Map<Integer,List<Integer>> ump = new HashMap<>();     for(int i = 0; i < nums.length; ++i){         int t = nums[i], maxDigit = 0;         while(t != 0){ //evaluate max digit in the number             maxDigit = Math.max(t%10, maxDigit);             t = t/10;         }         if(!ump.containsKey(maxDigit)) ump.put(maxDigit, new ArrayList<>());         ump.get(maxDigit).add(nums[i]); // add the number to the map      }     for(Map.Entry<Integer, List<Integer>> entry: ump.entrySet()){         entry.getValue().sort(Comparator.reverseOrder()); //to find max two number in each max digit          if(entry.getValue().size() >= 2) ans = Math.max(ans, entry.getValue().get(0) + entry.getValue().get(1)); //sum max two number and take max     }     return ans;     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
|110|1             |Python  |easy      |StarCoder      |IDE Extension    |You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.  Return the maximum sum or -1 if no such pair exists.  Example 1:  Input: nums = [51,71,17,24,42] Output: 88 Explanation:  For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88.  For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66. It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.  Example 2:  Input: nums = [1,2,3,4] Output: -1 Explanation: No pair exists in nums with equal maximum digits.  Constraints:  2 <= nums.length <= 100 1 <= nums[i] <= 10^4                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |"""You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.  Return the maximum sum or -1 if no such pair exists.  Example 1:  Input: nums = [51,71,17,24,42] Output: 88 Explanation:  For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88.  For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66. It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.  Example 2:  Input: nums = [1,2,3,4] Output: -1 Explanation: No pair exists in nums with equal maximum digits.   Constraints:  2 <= nums.length <= 100 1 <= nums[i] <= 10^4"""  class Solution:     def maxSum(self, nums: List[int]) -> int:                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |class Solution:     def maxSum(self, nums: List[int]) -> int:         if len(nums) == 1:             return nums[0]         if len(nums) == 2:             return max(nums)         max_sum = 0         for i in range(len(nums)):             for j in range(i+1, len(nums)):                 if nums[i] % 10 == nums[j] % 10:                     max_sum = max(max_sum, nums[i] + nums[j])         return max_sum if max_sum > 0 else -1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |class Solution:     def maxSum(self, nums: List[int]) -> int:         max_by_digit = defaultdict(int)         max_sum = -1          for num in nums:             digit = max(str(num))              if digit in max_by_digit:                 max_sum = max(max_sum, max_by_digit[digit] + num)              max_by_digit[digit] = max(max_by_digit[digit], num)          return max_sum                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
|111|1             |C++     |easy      |StarCoder      |IDE Extension    |You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.  Return the maximum sum or -1 if no such pair exists.  Example 1:  Input: nums = [51,71,17,24,42] Output: 88 Explanation:  For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88.  For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66. It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.  Example 2:  Input: nums = [1,2,3,4] Output: -1 Explanation: No pair exists in nums with equal maximum digits.  Constraints:  2 <= nums.length <= 100 1 <= nums[i] <= 10^4                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |class Solution { public:     int maxSum(vector<int>& nums) { /*You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.  Return the maximum sum or -1 if no such pair exists.  Example 1:  Input: nums = [51,71,17,24,42] Output: 88 Explanation:  For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88.  For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66. It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.  Example 2:  Input: nums = [1,2,3,4] Output: -1 Explanation: No pair exists in nums with equal maximum digits.  Constraints:  2 <= nums.length <= 100 1 <= nums[i] <= 10^4*/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |class Solution { public:     int maxSum(vector<int>& nums) {     int n=nums.size();     int maxi=0;     int maxj=0;     int maxsum=0;     for(int i=0;i<n;i++){         for(int j=i+1;j<n;j++){             if(nums[i]>maxi){                 maxi=nums[i];             }             if(nums[j]>maxj){                 maxj=nums[j];             }             if(maxi==maxj){                 maxsum=max(maxsum,maxi+maxj);             }         }     }     if(maxsum==0){         return -1;     }     return maxsum;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |class Solution {     public:         int maxSum(vector<int>& nums) {         int res = -1, max_num[10] = {};         for (auto num : nums) {             int max_d = 0;             for (int v = num; v; v /= 10)                 max_d = max(max_d, v % 10);             if (max_num[max_d])                 res = max(res, max_num[max_d] + num);             max_num[max_d] = max(max_num[max_d], num);         }         return res;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|112|2             |Java    |easy      |StarCoder      |IDE Extension    |Your laptop keyboard is faulty, and whenever you type a character 'i' on it, it reverses the string that you have written. Typing other characters works as expected.  You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.  Return the final string that will be present on your laptop screen.  Example 1:  Input: s = "string" Output: "rtsng" Explanation:  After typing first character, the text on the screen is "s". After the second character, the text is "st".  After the third character, the text is "str". Since the fourth character is an 'i', the text gets reversed and becomes "rts". After the fifth character, the text is "rtsn".  After the sixth character, the text is "rtsng".  Therefore, we return "rtsng".  Example 2:  Input: s = "poiinter" Output: "ponter" Explanation:  After the first character, the text on the screen is "p". After the second character, the text is "po".  Since the third character you type is an 'i', the text gets reversed and becomes "op".  Since the fourth character you type is an 'i', the text gets reversed and becomes "po". After the fifth character, the text is "pon". After the sixth character, the text is "pont".  After the seventh character, the text is "ponte".  After the eighth character, the text is "ponter".  Therefore, we return "ponter".   Constraints:  1 <= s.length <= 100 s consists of lowercase English letters. s[0] != 'i'                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |public class Solution {     public String finalString(String s) {         /*          * Your laptop keyboard is faulty, and whenever you type a character 'i' on it, it reverses the string that you have written. Typing other characters works as expected.  You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.  Return the final string that will be present on your laptop screen.  Example 1:  Input: s = "string" Output: "rtsng" Explanation:  After typing first character, the text on the screen is "s". After the second character, the text is "st".  After the third character, the text is "str". Since the fourth character is an 'i', the text gets reversed and becomes "rts". After the fifth character, the text is "rtsn".  After the sixth character, the text is "rtsng".  Therefore, we return "rtsng".  Example 2:  Input: s = "poiinter" Output: "ponter" Explanation:  After the first character, the text on the screen is "p". After the second character, the text is "po".  Since the third character you type is an 'i', the text gets reversed and becomes "op".  Since the fourth character you type is an 'i', the text gets reversed and becomes "po". After the fifth character, the text is "pon". After the sixth character, the text is "pont".  After the seventh character, the text is "ponte".  After the eighth character, the text is "ponter".  Therefore, we return "ponter".   Constraints:  1 <= s.length <= 100 s consists of lowercase English letters. s[0] != 'i'  */                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |public class Solution {     public String finalString(String s) {         String result = "";         for (int i = 0; i < s.length(); i++) {             char c = s.charAt(i);             if (c == 'i') {                 result = new StringBuilder(result).reverse().toString();             } else {                 result += c;             }         }         return result;     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |class Solution {     public String finalString(String s) {         StringBuilder nm=new StringBuilder();         for(char c:s.toCharArray())         {             if(c=='i')             {                 nm.reverse();             }             else             {                 nm.append(c);             }         }         return nm.toString();     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|113|2             |Python  |easy      |StarCoder      |IDE Extension    |Your laptop keyboard is faulty, and whenever you type a character 'i' on it, it reverses the string that you have written. Typing other characters works as expected.  You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.  Return the final string that will be present on your laptop screen.  Example 1:  Input: s = "string" Output: "rtsng" Explanation:  After typing first character, the text on the screen is "s". After the second character, the text is "st".  After the third character, the text is "str". Since the fourth character is an 'i', the text gets reversed and becomes "rts". After the fifth character, the text is "rtsn".  After the sixth character, the text is "rtsng".  Therefore, we return "rtsng".  Example 2:  Input: s = "poiinter" Output: "ponter" Explanation:  After the first character, the text on the screen is "p". After the second character, the text is "po".  Since the third character you type is an 'i', the text gets reversed and becomes "op".  Since the fourth character you type is an 'i', the text gets reversed and becomes "po". After the fifth character, the text is "pon". After the sixth character, the text is "pont".  After the seventh character, the text is "ponte".  After the eighth character, the text is "ponter".  Therefore, we return "ponter".   Constraints:  1 <= s.length <= 100 s consists of lowercase English letters. s[0] != 'i'                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |"""Your laptop keyboard is faulty, and whenever you type a character 'i' on it, it reverses the string that you have written. Typing other characters works as expected.  You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.  Return the final string that will be present on your laptop screen.  Example 1:  Input: s = "string" Output: "rtsng" Explanation:  After typing first character, the text on the screen is "s". After the second character, the text is "st".  After the third character, the text is "str". Since the fourth character is an 'i', the text gets reversed and becomes "rts". After the fifth character, the text is "rtsn".  After the sixth character, the text is "rtsng".  Therefore, we return "rtsng".  Example 2:  Input: s = "poiinter" Output: "ponter" Explanation:  After the first character, the text on the screen is "p". After the second character, the text is "po".  Since the third character you type is an 'i', the text gets reversed and becomes "op".  Since the fourth character you type is an 'i', the text gets reversed and becomes "po". After the fifth character, the text is "pon". After the sixth character, the text is "pont".  After the seventh character, the text is "ponte".  After the eighth character, the text is "ponter".  Therefore, we return "ponter".   Constraints:  1 <= s.length <= 100 s consists of lowercase English letters. s[0] != 'i'""" class Solution:     def finalString(self, s: str) -> str:                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |class Solution:     def finalString(self, s: str) -> str:         s = list(s)         for i in range(len(s)):             if s[i] == 'i':                 s[i] = 'o'             else:                 s[i] = 'i'         return ''.join(s)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |class Solution:     def finalString(self, s: str) -> str:         while "i" in s:             index=s.index("i")              #first half and second half             first=s[:index][::-1]             second=s[index+1:]              s="".join([first,second])         return s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|114|2             |C++     |easy      |StarCoder      |IDE Extension    |Your laptop keyboard is faulty, and whenever you type a character 'i' on it, it reverses the string that you have written. Typing other characters works as expected.  You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.  Return the final string that will be present on your laptop screen.  Example 1:  Input: s = "string" Output: "rtsng" Explanation:  After typing first character, the text on the screen is "s". After the second character, the text is "st".  After the third character, the text is "str". Since the fourth character is an 'i', the text gets reversed and becomes "rts". After the fifth character, the text is "rtsn".  After the sixth character, the text is "rtsng".  Therefore, we return "rtsng".  Example 2:  Input: s = "poiinter" Output: "ponter" Explanation:  After the first character, the text on the screen is "p". After the second character, the text is "po".  Since the third character you type is an 'i', the text gets reversed and becomes "op".  Since the fourth character you type is an 'i', the text gets reversed and becomes "po". After the fifth character, the text is "pon". After the sixth character, the text is "pont".  After the seventh character, the text is "ponte".  After the eighth character, the text is "ponter".  Therefore, we return "ponter".   Constraints:  1 <= s.length <= 100 s consists of lowercase English letters. s[0] != 'i'                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |class Solution { public:     string finalString(string s) { /*Your laptop keyboard is faulty, and whenever you type a character 'i' on it, it reverses the string that you have written. Typing other characters works as expected.  You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.  Return the final string that will be present on your laptop screen.  Example 1:  Input: s = "string" Output: "rtsng" Explanation:  After typing first character, the text on the screen is "s". After the second character, the text is "st".  After the third character, the text is "str". Since the fourth character is an 'i', the text gets reversed and becomes "rts". After the fifth character, the text is "rtsn".  After the sixth character, the text is "rtsng".  Therefore, we return "rtsng".  Example 2:  Input: s = "poiinter" Output: "ponter" Explanation:  After the first character, the text on the screen is "p". After the second character, the text is "po".  Since the third character you type is an 'i', the text gets reversed and becomes "op".  Since the fourth character you type is an 'i', the text gets reversed and becomes "po". After the fifth character, the text is "pon". After the sixth character, the text is "pont".  After the seventh character, the text is "ponte".  After the eighth character, the text is "ponter".  Therefore, we return "ponter".   Constraints:  1 <= s.length <= 100 s consists of lowercase English letters. s[0] != 'i'*/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |class Solution { public:     string finalString(string s) {     int n=s.length();     string ans="";     for(int i=0;i<n;i++){         if(s[i]=='i'){             ans=ans.substr(0,ans.length()-1);         }         else{             ans+=s[i];         }     }     return ans;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |class Solution { public:     string finalString(const string &s) {         string a, b;         for (char ch : s)             if (ch == 'i')                 swap(a, b);             else                 a += ch;         return string(rbegin(b), rend(b)) + a;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
|115|3             |Java    |medium    |StarCoder      |IDE Extension    |You are given a 0-indexed integer array nums and an integer x.  Find the minimum absolute difference between two elements in the array that are at least x indices apart.  In other words, find two indices i and j such that abs(i - j) >= x and abs(nums[i] - nums[j]) is minimized.  Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.  Example 1:  Input: nums = [4,3,2,4], x = 2 Output: 0 Explanation: We can select nums[0] = 4 and nums[3] = 4.  They are at least 2 indices apart, and their absolute difference is the minimum, 0.  It can be shown that 0 is the optimal answer.  Example 2:  Input: nums = [5,3,2,10,15], x = 1 Output: 1 Explanation: We can select nums[1] = 3 and nums[2] = 2. They are at least 1 index apart, and their absolute difference is the minimum, 1. It can be shown that 1 is the optimal answer.  Example 3:  Input: nums = [1,2,3,4], x = 3 Output: 3 Explanation: We can select nums[0] = 1 and nums[3] = 4. They are at least 3 indices apart, and their absolute difference is the minimum, 3. It can be shown that 3 is the optimal answer.   Constraints:  1 <= nums.length <= 10^5 1 <= nums[i] <= 10^9 0 <= x < nums.length                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |class Solution {         /*          * You are given a 0-indexed integer array nums and an integer x.  Find the minimum absolute difference between two elements in the array that are at least x indices apart.  In other words, find two indices i and j such that abs(i - j) >= x and abs(nums[i] - nums[j]) is minimized.  Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.  Example 1:  Input: nums = [4,3,2,4], x = 2 Output: 0 Explanation: We can select nums[0] = 4 and nums[3] = 4.  They are at least 2 indices apart, and their absolute difference is the minimum, 0.  It can be shown that 0 is the optimal answer.  Example 2:  Input: nums = [5,3,2,10,15], x = 1 Output: 1 Explanation: We can select nums[1] = 3 and nums[2] = 2. They are at least 1 index apart, and their absolute difference is the minimum, 1. It can be shown that 1 is the optimal answer.  Example 3:  Input: nums = [1,2,3,4], x = 3 Output: 3 Explanation: We can select nums[0] = 1 and nums[3] = 4. They are at least 3 indices apart, and their absolute difference is the minimum, 3. It can be shown that 3 is the optimal answer.   Constraints:  1 <= nums.length <= 10^5 1 <= nums[i] <= 10^9 0 <= x < nums.length  */     public int minAbsoluteDifference(List<Integer> nums, int x) {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |class Solution {     public int minAbsoluteDifference(List<Integer> nums, int x) {         int n = nums.size();         int[] arr  = new int[n];         for(int i = 0; i < n; i++) {             arr[i] = nums.get(i);         }         Arrays.sort(arr);         int res = Integer.MAX_VALUE;         for(int i =  0; i < n; i++) {             int left = i + 1;             int right = n - 1;             while(left <= right) {                 int mid = left + (right - left) / 2;                 if(arr[mid] - arr[  i] >= x) {                     right = mid - 1;                 } else {                     left = mid + 1;                 }             }             if(left < n) {                 res = Math.min(res, arr[left] - arr[i]);             }             left  = 0;             right = i - 1;             while(left <= right) {                 int mid = left + (right - left) / 2;                 if(arr[i] - arr[mid] >= x) {                     left = mid + 1;                  } else {                     right = mid - 1;                 }             }             if(right >= 0) {                 res = Math.min(res, arr[i] - arr[right]);             }         }         return res;     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |class Solution {     int minAbsoluteDifference(List<Integer> nums, int x) {         int ans = Integer.MAX_VALUE;         TreeSet<Integer> s = new TreeSet<>();         for(int i = x; i < nums.size(); ++i){             s.add(nums.get(i-x));             Integer high = s.ceiling(nums.get(i)), low = s.floor(nums.get(i));             if(high != null) ans = Math.min(ans, Math.abs(nums.get(i) - high));             if(low != null) ans = Math.min(ans, Math.abs(nums.get(i) - low));         }         return ans;     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|116|3             |Python  |medium    |StarCoder      |IDE Extension    |You are given a 0-indexed integer array nums and an integer x.  Find the minimum absolute difference between two elements in the array that are at least x indices apart.  In other words, find two indices i and j such that abs(i - j) >= x and abs(nums[i] - nums[j]) is minimized.  Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.  Example 1:  Input: nums = [4,3,2,4], x = 2 Output: 0 Explanation: We can select nums[0] = 4 and nums[3] = 4.  They are at least 2 indices apart, and their absolute difference is the minimum, 0.  It can be shown that 0 is the optimal answer.  Example 2:  Input: nums = [5,3,2,10,15], x = 1 Output: 1 Explanation: We can select nums[1] = 3 and nums[2] = 2. They are at least 1 index apart, and their absolute difference is the minimum, 1. It can be shown that 1 is the optimal answer.  Example 3:  Input: nums = [1,2,3,4], x = 3 Output: 3 Explanation: We can select nums[0] = 1 and nums[3] = 4. They are at least 3 indices apart, and their absolute difference is the minimum, 3. It can be shown that 3 is the optimal answer.   Constraints:  1 <= nums.length <= 10^5 1 <= nums[i] <= 10^9 0 <= x < nums.length                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |class Solution:     def minAbsoluteDifference(self, nums: List[int], x: int) -> int: """You are given a 0-indexed integer array nums and an integer x.  Find the minimum absolute difference between two elements in the array that are at least x indices apart.  In other words, find two indices i and j such that abs(i - j) >= x and abs(nums[i] - nums[j]) is minimized.  Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.  Example 1:  Input: nums = [4,3,2,4], x = 2 Output: 0 Explanation: We can select nums[0] = 4 and nums[3] = 4.  They are at least 2 indices apart, and their absolute difference is the minimum, 0.  It can be shown that 0 is the optimal answer.  Example 2:  Input: nums = [5,3,2,10,15], x = 1 Output: 1 Explanation: We can select nums[1] = 3 and nums[2] = 2. They are at least 1 index apart, and their absolute difference is the minimum, 1. It can be shown that 1 is the optimal answer.  Example 3:  Input: nums = [1,2,3,4], x = 3 Output: 3 Explanation: We can select nums[0] = 1 and nums[3] = 4. They are at least 3 indices apart, and their absolute difference is the minimum, 3. It can be shown that 3 is the optimal answer.   Constraints:  1 <= nums.length <= 10^5 1 <= nums[i] <= 10^9 0 <= x < nums.length """                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |class Solution:     def minAbsoluteDifference(self, nums: List[int], x: int) -> int:         nums.sort()         n = len(nums)         ans = float('inf')         for i in range(n):             for j in range(i+1, n):                 if abs(nums[i] - nums[j]) < ans:                     ans = abs(nums[i] - nums[j])                 if abs(nums[i] - nums[j]) == ans and abs(nums[i] - x) < abs(nums[j] - x):                     ans = abs(nums[i] - x)         return ans                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |class Solution:   def minAbsoluteDifference(self, nums: List[int], x: int) -> int:     if x == 0:       return 0      arr, best_dist = SortedList([]), float('inf')     for i in range(x, len(nums)):       arr.add(nums[i - x])       v = nums[i]        pos = arr.bisect_left(v)       if pos < len(arr):         best_dist = min(best_dist, abs(arr[pos] - v))       if pos > 0:         best_dist = min(best_dist, abs(arr[pos - 1] - v))          return best_dist                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
|117|3             |C++     |medium    |StarCoder      |IDE Extension    |You are given a 0-indexed integer array nums and an integer x.  Find the minimum absolute difference between two elements in the array that are at least x indices apart.  In other words, find two indices i and j such that abs(i - j) >= x and abs(nums[i] - nums[j]) is minimized.  Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.  Example 1:  Input: nums = [4,3,2,4], x = 2 Output: 0 Explanation: We can select nums[0] = 4 and nums[3] = 4.  They are at least 2 indices apart, and their absolute difference is the minimum, 0.  It can be shown that 0 is the optimal answer.  Example 2:  Input: nums = [5,3,2,10,15], x = 1 Output: 1 Explanation: We can select nums[1] = 3 and nums[2] = 2. They are at least 1 index apart, and their absolute difference is the minimum, 1. It can be shown that 1 is the optimal answer.  Example 3:  Input: nums = [1,2,3,4], x = 3 Output: 3 Explanation: We can select nums[0] = 1 and nums[3] = 4. They are at least 3 indices apart, and their absolute difference is the minimum, 3. It can be shown that 3 is the optimal answer.   Constraints:  1 <= nums.length <= 10^5 1 <= nums[i] <= 10^9 0 <= x < nums.length                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |class Solution { public:     int minAbsoluteDifference(vector<int>& nums, int x) { /*You are given a 0-indexed integer array nums and an integer x.  Find the minimum absolute difference between two elements in the array that are at least x indices apart.  In other words, find two indices i and j such that abs(i - j) >= x and abs(nums[i] - nums[j]) is minimized.  Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.  Example 1:  Input: nums = [4,3,2,4], x = 2 Output: 0 Explanation: We can select nums[0] = 4 and nums[3] = 4.  They are at least 2 indices apart, and their absolute difference is the minimum, 0.  It can be shown that 0 is the optimal answer.  Example 2:  Input: nums = [5,3,2,10,15], x = 1 Output: 1 Explanation: We can select nums[1] = 3 and nums[2] = 2. They are at least 1 index apart, and their absolute difference is the minimum, 1. It can be shown that 1 is the optimal answer.  Example 3:  Input: nums = [1,2,3,4], x = 3 Output: 3 Explanation: We can select nums[0] = 1 and nums[3] = 4. They are at least 3 indices apart, and their absolute difference is the minimum, 3. It can be shown that 3 is the optimal answer.   Constraints:  1 <= nums.length <= 10^5 1 <= nums[i] <= 10^9 0 <= x < nums.length*/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |class Solution { public:     int minAbsoluteDifference(vector<int>& nums, int x) {     int n=nums.size();     vector<int>v;     for(int i=0;i<n;i++)     {         v.push_back(abs(nums[i]-x));     }     sort(v.begin(),v.end());     int ans=v[0];     for(int i=1;i<n;i++)     {         ans=min(ans,v[i]-v[i-1]);     }     return ans;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |class Solution { public:     int minAbsoluteDifference(vector<int>& nums, int x) {         int ans = INT_MAX;         set<int> s;         for(int i = x; i < nums.size(); ++i){             s.insert(nums[i-x]);             auto it = s.upper_bound(nums[i]);             if(it != s.end()) ans = min(ans, abs(nums[i] - *it));             if(it != s.begin()) ans = min(ans, abs(nums[i] - *prev(it)));         }         return ans;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|118|4             |Java    |medium    |StarCoder      |IDE Extension    |You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.  Return the head of the linked list after doubling it.  Example 1:  Input: head = [1,8,9] Output: [3,7,8] Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.  Example 2:  Input: head = [9,9,9] Output: [1,9,9,8] Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998.   Constraints:  The number of nodes in the list is in the range [1, 10^4] 0 <= Node.val <= 9 The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |class Solution {     public ListNode doubleIt(ListNode head) { /*You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.  Return the head of the linked list after doubling it.  Example 1:  Input: head = [1,8,9] Output: [3,7,8] Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.  Example 2:  Input: head = [9,9,9] Output: [1,9,9,8] Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998.   Constraints:  The number of nodes in the list is in the range [1, 10^4] 0 <= Node.val <= 9 The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.*/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |class Solution {     public ListNode doubleIt(ListNode head) {     ListNode dummy = new ListNode(0);     dummy.next = head;     ListNode cur = dummy;     while (cur.next != null && cur.next.next != null) {         ListNode next = cur.next.next;         cur.next.next =  next.next;         next.next = cur.next;         cur.next = next;         cur = cur.next.next;     }     return dummy.next;     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |class Solution {     public ListNode doubleIt(ListNode head) {         if (head.val > 4)             head = new ListNode(0, head);         for(ListNode node = head; node != null; node = node.next) {             node.val = (node.val * 2) % 10;             if (node.next != null && node.next.val > 4)                 node.val++;         }         return head;     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
|119|4             |Python  |medium    |StarCoder      |IDE Extension    |You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.  Return the head of the linked list after doubling it.  Example 1:  Input: head = [1,8,9] Output: [3,7,8] Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.  Example 2:  Input: head = [9,9,9] Output: [1,9,9,8] Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998.   Constraints:  The number of nodes in the list is in the range [1, 10^4] 0 <= Node.val <= 9 The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |class Solution:     def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]: """You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.  Return the head of the linked list after doubling it.  Example 1:  Input: head = [1,8,9] Output: [3,7,8] Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.  Example 2:  Input: head = [9,9,9] Output: [1,9,9,8] Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998.   Constraints:  The number of nodes in the list is in the range [1, 10^4] 0 <= Node.val <= 9 The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself. """                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |class Solution:     def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:         if head is None:             return None         temp = head         while temp is not None:             temp.val *= 2             temp = temp.next         return head                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |class Solution:     def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:         if head.val > 4:             head = ListNode(0, head)         node = head         while node:             node.val = (node.val * 2) % 10             if node.next and node.next.val > 4:                 node.val += 1             node = node.next         return head                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
|120|4             |C++     |medium    |StarCoder      |IDE Extension    |You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.  Return the head of the linked list after doubling it.  Example 1:  Input: head = [1,8,9] Output: [3,7,8] Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.  Example 2:  Input: head = [9,9,9] Output: [1,9,9,8] Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998.   Constraints:  The number of nodes in the list is in the range [1, 10^4] 0 <= Node.val <= 9 The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |class Solution { public:     ListNode* doubleIt(ListNode* head) { /*You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.  Return the head of the linked list after doubling it.  Example 1:  Input: head = [1,8,9] Output: [3,7,8] Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.  Example 2:  Input: head = [9,9,9] Output: [1,9,9,8] Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998.   Constraints:  The number of nodes in the list is in the range [1, 10^4] 0 <= Node.val <= 9 The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself. */                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |class Solution { public:     ListNode* doubleIt(ListNode* head) {         ListNode* temp=head;         while(temp!=NULL){             ListNode* temp2=temp->next;             temp->next=new ListNode(temp->val);             temp->next->next=temp2;             temp=temp2;         }         return head;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |class Solution { public:     ListNode* doubleIt(ListNode* head) {         if (head->val > 4)             head = new ListNode(0, head);         for(ListNode* node = head; node; node = node->next) {             node->val = (node->val * 2) % 10;             if (node->next && node->next->val > 4)                 node->val++;         }         return head;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
|121|5             |Java    |hard      |StarCoder      |IDE Extension    |You are given an array nums of n positive integers and an integer k.  Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:  Choose any non-empty subarray nums[l, ..., r] that you haven't chosen previously. Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index. Multiply your score by x. Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.  The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.  Return the maximum possible score after applying at most k operations.  Since the answer may be large, return it modulo 10^9 + 7.  Example 1:  Input: nums = [8,3,9,3,8], k = 2 Output: 81 Explanation: To get a score of 81, we can apply the following operations: - Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81. It can be proven that 81 is the highest score one can obtain.  Example 2:  Input: nums = [19,12,14,6,10,18], k = 3 Output: 4788 Explanation: To get a score of 4788, we can apply the following operations:  - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19. - Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788. It can be proven that 4788 is the highest score one can obtain.   Constraints:  1 <= nums.length == n <= 10^5 1 <= nums[i] <= 10^5 1 <= k <= min(n * (n + 1) / 2, 10^9) |public class Solution { /*  * You are given an array nums of n positive integers and an integer k.  Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:  Choose any non-empty subarray nums[l, ..., r] that you haven't chosen previously. Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index. Multiply your score by x. Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.  The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.  Return the maximum possible score after applying at most k operations.  Since the answer may be large, return it modulo 10^9 + 7.  Constraints:  1 <= nums.length == n <= 10^5 1 <= nums[i] <= 10^5 1 <= k <= min(n * (n + 1) / 2, 10^9). */     public int maximumScore(List<Integer> nums, int k) {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |public class Solution {     public int maximumScore(List<Integer> nums, int k) {                  int n = nums.size();         int[] dp = new int[n];         int[] prime = new int[n];         int[] primeCount = new int[n];         int[] prefix = new int[n];         int[] suffix = new int[n];                           for(int i = 0; i < n; i++){             dp[i] = nums.get(i);             prime[i] = getPrime(nums.get(i));             primeCount[i] = getPrimeCount(nums.get(i));                      }                  for(int i = 1; i < n; i++){             prefix[i] = prefix[i-1] + primeCount[i-1];         }                  for(int i = n-2; i >= 0; i--){             suffix[  i] = suffix[i+1] + primeCount[i+1];         }                  int[] dp2 = new int[n];         int[] dp3 = new int[n];         int[] dp4 = new int[n];                  for(int i = 0  ; i < n; i++){             dp2[i] = dp[i];             dp3[i] = dp[i];             dp4[i] = dp[i];         }                  for(int i = 0; i < k; i++){             int max  = -1;             int maxIndex = -1;             for(int j = 0; j < n; j++){                 if(j == 0){                     dp2[j] = dp[j] * prime[j];                 }else{                     dp2[j  ] = Math.max(dp2[j-1], dp[j] * prime[j]);                 }                                  if(j == n-1){                     dp3[j] = dp[j] * prime[j];                 }else{                     dp3[j]  = Math.max(dp3[j+1], dp[j] * prime[j]);                 }                                  if(prefix[j] + suffix[j] - primeCount[j] > max){                     max = prefix[j] + suffix[j] - primeCount  [j];                     maxIndex = j;                 }             }                          dp4[maxIndex] = 0;                          for(int j = 0; j < n; j++){                 if(j == 0){                     dp4[j] = Math.max(dp4  [j], dp2[j]);                 }else if(j == n-1){                     dp4[j] = Math.max(dp4[j], dp3[j]);                 }else{                     dp4[j] = Math.max(dp4[j],  Math.max(dp2[j], dp3[j]));                 }             }                          for(int j = 0; j < n; j++){                 dp[j] = dp4[j];             }         }                  int sum = 0;         for(int i  = 0; i < n; i++){             sum = (sum + dp[i]) % 1000000007;         }                  return sum;     }          public int getPrime(int num){         int count = 0;         for(  int i = 2; i <= num; i++){             if(num % i == 0){                 count++;             }         }         return count;     }          public int getPrimeCount(int num){         int count = 0;         for(  int i =  2; i <= num; i++){             if(num % i == 0){                 count++;             }         }         return count - 1;     } }|class Solution {     static final int MOD = 1000000007;      public int maximumScore(List<Integer> nums, int k) {         int n = nums.size();          int upper = Collections.max(nums) + 1;          boolean[] prime = new boolean[upper];         int[] primeScore = new int[upper];         Arrays.fill(prime, true);         prime[0] = prime[1] = false;         for (int i = 2; i < upper; i++) {             if (prime[i]) {                 for (int j = i; j < upper; j += i) {                     primeScore[j]++;                     prime[j] = false;                 }             }         }          int[] nextGreaterElement = new int[n];         Arrays.fill(nextGreaterElement, n);         Stack<Integer> s = new Stack<>();         for (int i = n - 1; i >= 0; i--) {             while (!s.empty() && primeScore[nums.get(i)] >= primeScore[nums.get(s.peek())]) {                 s.pop();             }             nextGreaterElement[i] = s.empty() ? n : s.peek();             s.push(i);         }          int[] prevGreaterOrEqualElement = new int[n];         Arrays.fill(prevGreaterOrEqualElement, -1);         s = new Stack<>();         for (int i = 0; i < n; i++) {             while (!s.empty() && primeScore[nums.get(i)] > primeScore[nums.get(s.peek())]) {                 s.pop();             }             prevGreaterOrEqualElement[i] = s.empty() ? -1 : s.peek();             s.push(i);         }          int res = 1;         int[][] tuples = new int[n][2];         for (int i = 0; i < n; i++) {             tuples[i][0] = nums.get(i);             tuples[i][1] = i;         }         Arrays.sort(tuples, new Comparator<int[]>() {             public int compare(int[] a, int[] b) {                 return b[0] - a[0];             }         });         for (int i = 0; i < n; i++) {             int num = tuples[i][0];             int idx = tuples[i][1];             int operations = Math.min((idx - prevGreaterOrEqualElement[idx]) * (nextGreaterElement[idx] - idx), k);             res = (int)((1L * res * pow(num, operations)) % MOD);             k -= operations;             if (k == 0) {                 return res;             }         }          return res;     }      public int pow(int x, int n) {         int res = 1;         while (n > 0) {             if (n % 2 == 1) {                 res = (int)((1L * res * x) % MOD);             }             x = (int)((1L * x * x) % MOD);             n /= 2;         }         return res;     } }|
|122|5             |Python  |hard      |StarCoder      |IDE Extension    |You are given an array nums of n positive integers and an integer k.  Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:  Choose any non-empty subarray nums[l, ..., r] that you haven't chosen previously. Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index. Multiply your score by x. Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.  The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.  Return the maximum possible score after applying at most k operations.  Since the answer may be large, return it modulo 10^9 + 7.  Example 1:  Input: nums = [8,3,9,3,8], k = 2 Output: 81 Explanation: To get a score of 81, we can apply the following operations: - Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81. It can be proven that 81 is the highest score one can obtain.  Example 2:  Input: nums = [19,12,14,6,10,18], k = 3 Output: 4788 Explanation: To get a score of 4788, we can apply the following operations:  - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19. - Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788. It can be proven that 4788 is the highest score one can obtain.   Constraints:  1 <= nums.length == n <= 10^5 1 <= nums[i] <= 10^5 1 <= k <= min(n * (n + 1) / 2, 10^9) |class Solution:     def maximumScore(self, nums: List[int], k: int) -> int: """You are given an array nums of n positive integers and an integer k.  Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:  Choose any non-empty subarray nums[l, ..., r] that you haven't chosen previously. Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index. Multiply your score by x. Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.  The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.  Return the maximum possible score after applying at most k operations.  Since the answer may be large, return it modulo 10^9 + 7.  Example 1:  Input: nums = [8,3,9,3,8], k = 2 Output: 81 Explanation: To get a score of 81, we can apply the following operations: - Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81. It can be proven that 81 is the highest score one can obtain.  Example 2:  Input: nums = [19,12,14,6,10,18], k = 3 Output: 4788 Explanation: To get a score of 4788, we can apply the following operations:  - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19. - Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788. It can be proven that 4788 is the highest score one can obtain.   Constraints:  1 <= nums.length == n <= 10^5 1 <= nums[i] <= 10^5 1 <= k <= min(n * (n + 1) / 2, 10^9) """                                                          |class Solution:     def maximumScore(self, nums: List[int], k: int) -> int:         n = len(nums)         dp = [0]*n         dp[0] = nums[0]         for i in range(1, n):             dp[i] = max(dp[i-1], nums[i])         ans = dp[k-1]         for i in range(k-1, n):             ans = max(ans, dp[i] * dp[k-1-i])         return ans % (10**9 + 7)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |class Solution:      MOD = 1000000007      def maximumScore(self, nums: List[int], k: int) -> int:         n = len(nums)          upper = max(nums) + 1          prime = [True]*upper         prime[0] = prime[1] = False         primeScore = [0]*upper         for i in range(2, upper):             if prime[i]:                 for j in range(i, upper, i):                     primeScore[j] += 1                     prime[j] = False          nextGreaterElement = [n]*n         s = []         for i in range(n - 1, -1, -1):             while s and primeScore[nums[i]] >= primeScore[nums[s[-1]]]:                 s.pop()             nextGreaterElement[i] = s[-1] if s else n             s.append(i)          prevGreaterOrEqualElement = [-1]*n         s = []         for i in range(n):             while s and primeScore[nums[i]] > primeScore[nums[s[-1]]]:                 s.pop()             prevGreaterOrEqualElement[i] = s[-1] if s else -1             s.append(i)          res = 1         tuples = [[nums[i], i] for i in range(n)]         tuples.sort(reverse=True)         for num, idx in tuples:             operations = min((idx - prevGreaterOrEqualElement[idx]) * (nextGreaterElement[idx] - idx), k)             res = (res * self.pow(num, operations)) % self.MOD             k -= operations             if k == 0:                 return res          return res      def pow(self, x: int, n: int) -> int:         res = 1         while n > 0:             if n % 2 == 1:                 res = (res * x) % self.MOD             x = (x * x) % self.MOD             n //= 2         return res                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
|123|5             |C++     |hard      |StarCoder      |IDE Extension    |You are given an array nums of n positive integers and an integer k.  Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:  Choose any non-empty subarray nums[l, ..., r] that you haven't chosen previously. Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index. Multiply your score by x. Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.  The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.  Return the maximum possible score after applying at most k operations.  Since the answer may be large, return it modulo 10^9 + 7.  Example 1:  Input: nums = [8,3,9,3,8], k = 2 Output: 81 Explanation: To get a score of 81, we can apply the following operations: - Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81. It can be proven that 81 is the highest score one can obtain.  Example 2:  Input: nums = [19,12,14,6,10,18], k = 3 Output: 4788 Explanation: To get a score of 4788, we can apply the following operations:  - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19. - Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788. It can be proven that 4788 is the highest score one can obtain.   Constraints:  1 <= nums.length == n <= 10^5 1 <= nums[i] <= 10^5 1 <= k <= min(n * (n + 1) / 2, 10^9) |class Solution { public:     int maximumScore(vector<int>& nums, int k) { /*You are given an array nums of n positive integers and an integer k.  Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:  Choose any non-empty subarray nums[l, ..., r] that you haven't chosen previously. Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index. Multiply your score by x. Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.  The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.  Return the maximum possible score after applying at most k operations.  Since the answer may be large, return it modulo 10^9 + 7.  Example 1:  Input: nums = [8,3,9,3,8], k = 2 Output: 81 Explanation: To get a score of 81, we can apply the following operations: - Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81. It can be proven that 81 is the highest score one can obtain.  Example 2:  Input: nums = [19,12,14,6,10,18], k = 3 Output: 4788 Explanation: To get a score of 4788, we can apply the following operations:  - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19. - Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342. - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788. It can be proven that 4788 is the highest score one can obtain.   Constraints:  1 <= nums.length == n <= 10^5 1 <= nums[i] <= 10^5 1 <= k <= min(n * (n + 1) / 2, 10^9)*/                                                               |class Solution { public:     int maximumScore(vector<int>& nums, int k) {         int MOD=1e9+7;         int n=nums.size();         vector<int> dp(n+1,0);         vector<int> primes;         for(int i=2;i<=n;i++) {             if(dp[i]==0) {                 primes.push_back(i);                 for(int j=i;j<=n;j+=i) {                     dp[j]+=1;                 }             }         }         int ans=0;         for(int i=0;i<k;i++) {             int mx=0;             int mx_idx=-1;             for(int j=i;j<n;j++) {                 if(mx<dp[j]) {                     mx=dp[j];                     mx_idx=j;                 }             }             ans=(ans+nums[mx_idx]*primes[mx-1])%MOD;             dp[mx_idx]=0;         }         return ans;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |class Solution { public:     const int MOD = 1000000007;      int maximumScore(vector<int>& nums, int k) {         int n = nums.size();          int upper = *max_element(nums.begin(), nums.end()) + 1;          vector<bool> prime(upper, true);         prime[0] = prime[1] = false;         vector<int> primeScore(upper, 0);         for (int i = 2; i < upper; i++) {             if (prime[i]) {                 for (int j = i; j < upper; j += i) {                     primeScore[j]++;                     prime[j] = false;                 }             }         }          vector<int> nextGreaterElement(n, n);         stack<int> s;         for (int i = n - 1; i >= 0; i--) {             while (!s.empty() && primeScore[nums[i]] >= primeScore[nums[s.top()]]) {                 s.pop();             }             nextGreaterElement[i] = s.empty() ? n : s.top();             s.push(i);         }          vector<int> prevGreaterOrEqualElement(n, -1);         s = stack<int>();         for (int i = 0; i < n; i++) {             while (!s.empty() && primeScore[nums[i]] > primeScore[nums[s.top()]]) {                 s.pop();             }             prevGreaterOrEqualElement[i] = s.empty() ? -1 : s.top();             s.push(i);         }          int res = 1;         vector<pair<int, int>> tuples(n);         for (int i = 0; i < n; i++) {             tuples[i].first = nums[i];             tuples[i].second = i;         }         sort(tuples.rbegin(), tuples.rend());         for (const auto& [num, i] : tuples) {             int operations = min((i - prevGreaterOrEqualElement[i]) * (nextGreaterElement[i] - i), k);             res = (int)((1L * res * pow(num, operations)) % MOD);             k -= operations;             if (k == 0) {                 return res;             }         }          return res;     }      int pow(int x, int n) {         int res = 1;         while (n > 0) {             if (n % 2 == 1) {                 res = (int)((1L * res * x) % MOD);             }             x = (int)((1L * x * x) % MOD);             n /= 2;         }         return res;     } };                                                                                                                                                                                                                                                                                                                                                                               |
|124|6             |Java    |hard      |StarCoder      |IDE Extension    |You are given a 0-indexed 2D integer array items of length n and an integer k.  items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.  Let's define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.  Your task is to find the maximum elegance from all subsequences of size k in items.  Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.  Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order.  Example 1:  Input: items = [[3,2],[5,1],[10,1]], k = 2 Output: 17 Explanation: In this example, we have to select a subsequence of size 2. We can select items[0] = [3,2] and items[2] = [10,1]. The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1]. Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance.   Example 2:  Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3 Output: 19 Explanation: In this example, we have to select a subsequence of size 3.  We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3].  The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3].  Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.  Example 3:  Input: items = [[1,1],[2,1],[3,1]], k = 3 Output: 7 Explanation: In this example, we have to select a subsequence of size 3.  We should select all the items.  The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1].  Hence, the maximum elegance is 6 + 1^2 = 7.     Constraints:  1 <= items.length == n <= 10^5 items[i].length == 2 items[i][0] == profit_i items[i][1] == category_i 1 <= profit_i <= 10^9 1 <= category_i <= n  1 <= k <= n                                             |public class Solution {     public int findMaximumElegance(int[][] items, int k) { /*  * You are given a 0-indexed 2D integer array items of length n and an integer k.  items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.  Let's define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.  Your task is to find the maximum elegance from all subsequences of size k in items.  Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.  Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order.  Example 1:  Input: items = [[3,2],[5,1],[10,1]], k = 2 Output: 17 Explanation: In this example, we have to select a subsequence of size 2. We can select items[0] = [3,2] and items[2] = [10,1]. The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1]. Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance.   Example 2:  Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3 Output: 19 Explanation: In this example, we have to select a subsequence of size 3.  We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3].  The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3].  Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.  Example 3:  Input: items = [[1,1],[2,1],[3,1]], k = 3 Output: 7 Explanation: In this example, we have to select a subsequence of size 3.  We should select all the items.  The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1].  Hence, the maximum elegance is 6 + 1^2 = 7.     Constraints:  1 <= items.length == n <= 10^5 items[i].length == 2 items[i][0] == profit_i items[i][1] == category_i 1 <= profit_i <= 10^9 1 <= category_i <= n  1 <= k <= n */                                                                                             |public class Solution {     public int findMaximumElegance(int[][] items, int k) {         int n = items.length;         int[][] dp = new int[n][k];         for(int i=0; i<n; i++) {             dp[i][0] = items[i][0];         }         for(int i=1; i  <n; i++) {             for(int j=1; j<k; j++) {                 int max = Integer.MIN_VALUE;                 for(int m=0; m<i; m++) {                     if(items[m][1] != items[i][ 1]) {                         max = Math.max(max, dp[m][j-1]);                     }                 }                 dp[i][j] = max + items[i][0];             }         }         int max = Integer.MIN_VALUE;         for(int i= 0; i<n; i++) {             max = Math.max(max, dp[i][k-1]);         }         return max;     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |class Solution {     public long findMaximumElegance(int[][] A, int k) {         Arrays.sort(A, (a, b) -> b[0] - a[0]);         long res = 0, cur = 0;         List<Integer> dup = new ArrayList<>();         Set<Integer> seen = new HashSet<>();         for (int i = 0; i < A.length; ++i) {             if (i < k) {                 if (seen.contains(A[i][1])) {                     dup.add(A[i][0]);                 }                 cur += A[i][0];             } else if (!seen.contains(A[i][1])) {                 if (dup.isEmpty()) break;                 cur += A[i][0] - dup.remove(dup.size() - 1);             }             seen.add(A[i][1]);             res = Math.max(res, cur + 1L * seen.size() * seen.size());         }         return res;     } }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|125|6             |Python  |hard      |StarCoder      |IDE Extension    |You are given a 0-indexed 2D integer array items of length n and an integer k.  items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.  Let's define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.  Your task is to find the maximum elegance from all subsequences of size k in items.  Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.  Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order.  Example 1:  Input: items = [[3,2],[5,1],[10,1]], k = 2 Output: 17 Explanation: In this example, we have to select a subsequence of size 2. We can select items[0] = [3,2] and items[2] = [10,1]. The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1]. Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance.   Example 2:  Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3 Output: 19 Explanation: In this example, we have to select a subsequence of size 3.  We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3].  The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3].  Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.  Example 3:  Input: items = [[1,1],[2,1],[3,1]], k = 3 Output: 7 Explanation: In this example, we have to select a subsequence of size 3.  We should select all the items.  The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1].  Hence, the maximum elegance is 6 + 1^2 = 7.     Constraints:  1 <= items.length == n <= 10^5 items[i].length == 2 items[i][0] == profit_i items[i][1] == category_i 1 <= profit_i <= 10^9 1 <= category_i <= n  1 <= k <= n                                             |class Solution:     def findMaximumElegance(self, items: List[List[int]], k: int) -> int: """You are given a 0-indexed 2D integer array items of length n and an integer k.  items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.  Let's define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.  Your task is to find the maximum elegance from all subsequences of size k in items.  Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.  Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order.  Example 1:  Input: items = [[3,2],[5,1],[10,1]], k = 2 Output: 17 Explanation: In this example, we have to select a subsequence of size 2. We can select items[0] = [3,2] and items[2] = [10,1]. The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1]. Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance.   Example 2:  Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3 Output: 19 Explanation: In this example, we have to select a subsequence of size 3.  We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3].  The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3].  Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.  Example 3:  Input: items = [[1,1],[2,1],[3,1]], k = 3 Output: 7 Explanation: In this example, we have to select a subsequence of size 3.  We should select all the items.  The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1].  Hence, the maximum elegance is 6 + 1^2 = 7.     Constraints:  1 <= items.length == n <= 10^5 items[i].length == 2 items[i][0] == profit_i items[i][1] == category_i 1 <= profit_i <= 10^9 1 <= category_i <= n  1 <= k <= n """                                                                                        |class Solution:     def findMaximumElegance(self, items: List[List[int]], k: int) -> int:         n = len(items)         dp = [[0]*n for _ in range(n)]         for i in range(n):             dp[i][i] = items[i][0]         for l in range(2, n+1):             for i in range(n-l+1):                 j = i+l-1                 dp[i][j] = max(dp[i][j-1], dp[i+1][j]) + items[j][0]         return max(dp[0][k-1], dp[n-k][n-1])                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |class Solution:     def findMaximumElegance(self, items: List[List[int]], k: int) -> int:         items = sorted(items, key=lambda v: -v[0])         res = cur = 0         A = []         seen = set()         for i, (p, c) in enumerate(items):             if i < k:                 if c in seen:                     A.append(p)                 cur += p             elif c not in seen:                 if not A: break                 cur += p - A.pop()             seen.add(c)             res = max(res, cur + len(seen) * len(seen))         return res                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
|126|6             |C++     |hard      |StarCoder      |IDE Extension    |You are given a 0-indexed 2D integer array items of length n and an integer k.  items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.  Let's define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.  Your task is to find the maximum elegance from all subsequences of size k in items.  Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.  Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order.  Example 1:  Input: items = [[3,2],[5,1],[10,1]], k = 2 Output: 17 Explanation: In this example, we have to select a subsequence of size 2. We can select items[0] = [3,2] and items[2] = [10,1]. The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1]. Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance.   Example 2:  Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3 Output: 19 Explanation: In this example, we have to select a subsequence of size 3.  We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3].  The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3].  Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.  Example 3:  Input: items = [[1,1],[2,1],[3,1]], k = 3 Output: 7 Explanation: In this example, we have to select a subsequence of size 3.  We should select all the items.  The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1].  Hence, the maximum elegance is 6 + 1^2 = 7.     Constraints:  1 <= items.length == n <= 10^5 items[i].length == 2 items[i][0] == profit_i items[i][1] == category_i 1 <= profit_i <= 10^9 1 <= category_i <= n  1 <= k <= n                                             |class Solution { public:     long long findMaximumElegance(vector<vector<int>>& items, int k) { /*You are given a 0-indexed 2D integer array items of length n and an integer k.  items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.  Let's define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.  Your task is to find the maximum elegance from all subsequences of size k in items.  Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.  Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order.  Example 1:  Input: items = [[3,2],[5,1],[10,1]], k = 2 Output: 17  Example 2:  Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3 Output: 19  Example 3:  Input: items = [[1,1],[2,1],[3,1]], k = 3 Output: 7   Constraints:  1 <= items.length == n <= 10^5 items[i].length == 2 items[i][0] == profit_i items[i][1] == category_i 1 <= profit_i <= 10^9 1 <= category_i <= n  1 <= k <= n */                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |class Solution { public:     long long findMaximumElegance(vector<vector<int>>& items, int k) {   int n=items.size();   vector<vector<int>>dp(n,vector<int>(k,0));   for(int i=0;i<n;i++)   {     dp[i][0]=items[i][0];   }   for(int i=1;i<n;i++)   {     for(int j=1;j<k;j++)     {       dp[i][j]=max(dp[i-1][j],dp[i-1][j-1]);       if(items[i][1]!=items[i-1][1])       {         dp[i][j]=max(dp[i][j],dp[i-1][j]+items[i][0]);       }     }   }   return dp[n-1][k-1];     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |class Solution { public:     long long findMaximumElegance(vector<vector<int>>& A, int k) {         sort(A.begin(), A.end(), [](const vector<int>& a, const vector<int>& b) {             return a[0] > b[0];         });         long long res = 0, cur = 0;         vector<int> dup;         unordered_set<int> seen;         for (int i = 0; i < A.size(); ++i) {             if (i < k) {                 if (seen.count(A[i][1])) {                     dup.push_back(A[i][0]);                 }                 cur += A[i][0];             } else if (seen.find(A[i][1]) == seen.end()) {                 if (dup.empty()) break;                 cur += A[i][0] - dup.back();                 dup.pop_back();             }             seen.insert(A[i][1]);             res = fmax(res, cur + 1L * seen.size() * seen.size());         }         return res;     } };                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
