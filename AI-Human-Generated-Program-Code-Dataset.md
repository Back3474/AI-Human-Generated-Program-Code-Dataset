 id | problem_number | language | difficulty | generator_name | generator_type | description | prompt | ai_generated_code | human_generated_code 
---|---|---|---|---|---|---|---|---|---
 1 | 1 | Java | easy | Bing AI Chat | Chatbot | You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.Return the maximum sum or -1 if no such pair exists.Example 1:Input: nums = [51,71,17,24,42]Output: 88Explanation: For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.Example 2:Input: nums = [1,2,3,4]Output: -1Explanation: No pair exists in nums with equal maximum digits.Constraints:2 &lt;= nums.length &lt;= 1001 &lt;= nums[i] &lt;= 10^4  | solve the following problem with java code. Class name: Solution, Method name: maxSum(int[] nums).You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.Return the maximum sum or -1 if no such pair exists.Example 1:Input: nums = [51,71,17,24,42]Output: 88Explanation: For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.Example 2:Input: nums = [1,2,3,4]Output: -1Explanation: No pair exists in nums with equal maximum digits.Constraints:2 &lt;= nums.length &lt;= 1001 &lt;= nums[i] &lt;= 10^4 | Public Class Solution {    Public Int Maxsum(int[] Nums) {        Int[] Maxsum = New Int[10];        For (Int Num : Nums) {            Int Maxdigit = 0;            Int Temp = Num;            While (Temp &gt; 0) {                Maxdigit = Math.max(maxdigit, Temp % 10);                Temp /= 10;            }            For (Int I = 0; I &lt; 10; I++) {                If (I == Maxdigit) {                    Maxsum[i] = Math.max(maxsum[i], Num + Maxsum[i]);                } Else {                    Maxsum[i] = Math.max(maxsum[i], Num);                }            }        }        Int Res = -1;        For (Int Sum : Maxsum) {            Res = Math.max(res, Sum);        }        Return Res == 0 ? -1 : Res;    }} | Class Solution {    Public Int Maxsum(int[] Nums) {    Int Ans = -1;    Map&lt;integer,list&lt;integer&gt;&gt; Ump = New Hashmap&lt;&gt;();    For(int I = 0; I &lt; Nums.length; ++I){        Int T = Nums[i], Maxdigit = 0;        While(t != 0){ //Evaluate Max Digit In The Number            Maxdigit = Math.max(t%10, Maxdigit);            T = T/10;        }        If(!ump.containskey(maxdigit)) Ump.put(maxdigit, New Arraylist&lt;&gt;());        Ump.get(maxdigit).add(nums[i]); // Add The Number To The Map     }    For(map.entry&lt;integer, List&lt;integer&gt;&gt; Entry: Ump.entryset()){        Entry.getvalue().sort(comparator.reverseorder()); //To Find Max Two Number In Each Max Digit         If(entry.getvalue().size() &gt;= 2) Ans = Math.max(ans, Entry.getvalue().get(0) + Entry.getvalue().get(1)); //Sum Max Two Number And Take Max    }    Return Ans;    }} 
 2 | 1 | Python | easy | Bing AI Chat | Chatbot | You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.Return the maximum sum or -1 if no such pair exists.Example 1:Input: nums = [51,71,17,24,42]Output: 88Explanation: For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.Example 2:Input: nums = [1,2,3,4]Output: -1Explanation: No pair exists in nums with equal maximum digits.Constraints:2 &lt;= nums.length &lt;= 1001 &lt;= nums[i] &lt;= 10^4  | solve the following problem with python3 code. Class name: Solution, Method name: def maxSum(self, nums: List[int]) -&gt; int:.You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.Return the maximum sum or -1 if no such pair exists.Example 1:Input: nums = [51,71,17,24,42]Output: 88Explanation: For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.Example 2:Input: nums = [1,2,3,4]Output: -1Explanation: No pair exists in nums with equal maximum digits.Constraints:2 &lt;= nums.length &lt;= 1001 &lt;= nums[i] &lt;= 10^4 | Class Solution:    Def Maxsum(self, Nums: List[int]) -&gt; Int:        Max_digit = {}        For Num In Nums:            Digit = Max(int(d) For D In Str(num))            If Digit Not In Max_digit:                Max_digit[digit] = []            Max_digit[digit].append(num)        Res = -1        For Digit, Values In Max_digit.items():            If Len(values) &gt;= 2:                Values.sort(reverse=true)                Res = Max(res, Values[0] + Values[1])        Return Res | Class Solution:    Def Maxsum(self, Nums: List[int]) -&gt; Int:        Max_by_digit = Defaultdict(int)        Max_sum = -1        For Num In Nums:            Digit = Max(str(num))            If Digit In Max_by_digit:                Max_sum = Max(max_sum, Max_by_digit[digit] + Num)            Max_by_digit[digit] = Max(max_by_digit[digit], Num)        Return Max_sum 
 3 | 1 | C++ | easy | Bing AI Chat | Chatbot | You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.Return the maximum sum or -1 if no such pair exists.Example 1:Input: nums = [51,71,17,24,42]Output: 88Explanation: For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.Example 2:Input: nums = [1,2,3,4]Output: -1Explanation: No pair exists in nums with equal maximum digits.Constraints:2 &lt;= nums.length &lt;= 1001 &lt;= nums[i] &lt;= 10^4  | solve the following problem with C++ code. Class name: Solution, Method name: maxSum(std::vector&lt;int&gt;&amp; nums).You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.Return the maximum sum or -1 if no such pair exists.Example 1:Input: nums = [51,71,17,24,42]Output: 88Explanation: For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.Example 2:Input: nums = [1,2,3,4]Output: -1Explanation: No pair exists in nums with equal maximum digits.Constraints:2 &lt;= nums.length &lt;= 1001 &lt;= nums[i] &lt;= 10^4 | Class Solution {Public:    Int Maxsum(std::vector&lt;int&gt;&amp; Nums) {        Int Maxsum = -1;        For (Int I = 0; I &lt; Nums.size(); I++) {            For (Int J = I + 1; J &lt; Nums.size(); J++) {                If (Maxdigit(nums[i]) == Maxdigit(nums[j])) {                    Maxsum = Std::max(maxsum, Nums[i] + Nums[j]);                }            }        }        Return Maxsum;    }Private:    Int Maxdigit(int Num) {        Int Maxdigit = 0;        While (Num &gt; 0) {            Maxdigit = Std::max(maxdigit, Num % 10);            Num /= 10;        }        Return Maxdigit;    }}; | Class Solution {    Public:        Int Maxsum(vector&lt;int&gt;&amp; Nums) {        Int Res = -1, Max_num[10] = {};        For (Auto Num : Nums) {            Int Max_d = 0;            For (Int V = Num; V; V /= 10)                Max_d = Max(max_d, V % 10);            If (Max_num[max_d])                Res = Max(res, Max_num[max_d] + Num);            Max_num[max_d] = Max(max_num[max_d], Num);        }        Return Res;    }}; 
 4 | 2 | Java | easy | Bing AI Chat | Chatbot | Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.Return the final string that will be present on your laptop screen.Example 1:Input: s = &quot;string&quot;Output: &quot;rtsng&quot;Explanation: After typing first character, the text on the screen is &quot;s&quot;.After the second character, the text is &quot;st&quot;. After the third character, the text is &quot;str&quot;.Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.After the fifth character, the text is &quot;rtsn&quot;. After the sixth character, the text is &quot;rtsng&quot;. Therefore, we return &quot;rtsng&quot;.Example 2:Input: s = &quot;poiinter&quot;Output: &quot;ponter&quot;Explanation: After the first character, the text on the screen is &quot;p&quot;.After the second character, the text is &quot;po&quot;. Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.After the fifth character, the text is &quot;pon&quot;.After the sixth character, the text is &quot;pont&quot;. After the seventh character, the text is &quot;ponte&quot;. After the eighth character, the text is &quot;ponter&quot;. Therefore, we return &quot;ponter&quot;. Constraints:1 &lt;= s.length &lt;= 100s consists of lowercase English letters.s[0] != &#39;i&#39; | Solve the following problem with java code. Class name: Solution, Method name: finalString(String s).Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.Return the final string that will be present on your laptop screen.Example 1:Input: s = &quot;string&quot;Output: &quot;rtsng&quot;Explanation: After typing first character, the text on the screen is &quot;s&quot;.After the second character, the text is &quot;st&quot;. After the third character, the text is &quot;str&quot;.Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.After the fifth character, the text is &quot;rtsn&quot;. After the sixth character, the text is &quot;rtsng&quot;. Therefore, we return &quot;rtsng&quot;.Example 2:Input: s = &quot;poiinter&quot;Output: &quot;ponter&quot;Explanation: After the first character, the text on the screen is &quot;p&quot;.After the second character, the text is &quot;po&quot;. Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.After the fifth character, the text is &quot;pon&quot;.After the sixth character, the text is &quot;pont&quot;. After the seventh character, the text is &quot;ponte&quot;. After the eighth character, the text is &quot;ponter&quot;. Therefore, we return &quot;ponter&quot;. Constraints:1 &lt;= s.length &lt;= 100s consists of lowercase English letters.s[0] != &#39;i&#39; | Class Solution {    Public String Finalstring(string S) {        Stringbuilder Sb = New Stringbuilder();        For (Char C : S.tochararray()) {            If (C == &#39;I&#39;) {                Sb.reverse();            } Else {                Sb.append(c);            }        }        Return Sb.tostring();    }} | Class Solution {    Public String Finalstring(string S) {        Stringbuilder Nm=new Stringbuilder();        For(char C:s.tochararray())        {            If(c==&#39;i&#39;)            {                Nm.reverse();            }            Else            {                Nm.append(c);            }        }        Return Nm.tostring();    }} 
 5 | 2 | Python | easy | Bing AI Chat | Chatbot | Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.Return the final string that will be present on your laptop screen.Example 1:Input: s = &quot;string&quot;Output: &quot;rtsng&quot;Explanation: After typing first character, the text on the screen is &quot;s&quot;.After the second character, the text is &quot;st&quot;. After the third character, the text is &quot;str&quot;.Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.After the fifth character, the text is &quot;rtsn&quot;. After the sixth character, the text is &quot;rtsng&quot;. Therefore, we return &quot;rtsng&quot;.Example 2:Input: s = &quot;poiinter&quot;Output: &quot;ponter&quot;Explanation: After the first character, the text on the screen is &quot;p&quot;.After the second character, the text is &quot;po&quot;. Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.After the fifth character, the text is &quot;pon&quot;.After the sixth character, the text is &quot;pont&quot;. After the seventh character, the text is &quot;ponte&quot;. After the eighth character, the text is &quot;ponter&quot;. Therefore, we return &quot;ponter&quot;. Constraints:1 &lt;= s.length &lt;= 100s consists of lowercase English letters.s[0] != &#39;i&#39; | Solve the following problem with python3 code. Class name: Solution, Method name: def finalString(self, s: str) -&gt; str:.Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.Return the final string that will be present on your laptop screen.Example 1:Input: s = &quot;string&quot;Output: &quot;rtsng&quot;Explanation: After typing first character, the text on the screen is &quot;s&quot;.After the second character, the text is &quot;st&quot;. After the third character, the text is &quot;str&quot;.Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.After the fifth character, the text is &quot;rtsn&quot;. After the sixth character, the text is &quot;rtsng&quot;. Therefore, we return &quot;rtsng&quot;.Example 2:Input: s = &quot;poiinter&quot;Output: &quot;ponter&quot;Explanation: After the first character, the text on the screen is &quot;p&quot;.After the second character, the text is &quot;po&quot;. Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.After the fifth character, the text is &quot;pon&quot;.After the sixth character, the text is &quot;pont&quot;. After the seventh character, the text is &quot;ponte&quot;. After the eighth character, the text is &quot;ponter&quot;. Therefore, we return &quot;ponter&quot;. Constraints:1 &lt;= s.length &lt;= 100s consists of lowercase English letters.s[0] != &#39;i&#39; | Class Solution:    Def Finalstring(self, S: Str) -&gt; Str:        Res = &quot;&quot;        For C In S:            If C == &#39;I&#39;:                Res = Res[::-1]            Else:                Res += C        Return Res | Class Solution:    Def Finalstring(self, S: Str) -&gt; Str:        While &quot;I&quot; In S:            Index=s.index(&quot;i&quot;)            #First Half And Second Half            First=s[:index][::-1]            Second=s[index+1:]            S=&quot;&quot;.join([first,second])        Return S 
 6 | 2 | C++ | easy | Bing AI Chat | Chatbot | Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.Return the final string that will be present on your laptop screen.Example 1:Input: s = &quot;string&quot;Output: &quot;rtsng&quot;Explanation: After typing first character, the text on the screen is &quot;s&quot;.After the second character, the text is &quot;st&quot;. After the third character, the text is &quot;str&quot;.Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.After the fifth character, the text is &quot;rtsn&quot;. After the sixth character, the text is &quot;rtsng&quot;. Therefore, we return &quot;rtsng&quot;.Example 2:Input: s = &quot;poiinter&quot;Output: &quot;ponter&quot;Explanation: After the first character, the text on the screen is &quot;p&quot;.After the second character, the text is &quot;po&quot;. Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.After the fifth character, the text is &quot;pon&quot;.After the sixth character, the text is &quot;pont&quot;. After the seventh character, the text is &quot;ponte&quot;. After the eighth character, the text is &quot;ponter&quot;. Therefore, we return &quot;ponter&quot;. Constraints:1 &lt;= s.length &lt;= 100s consists of lowercase English letters.s[0] != &#39;i&#39; | Solve the following problem with C++ code. Class name: Solution, Method name: string finalString(string s).Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.Return the final string that will be present on your laptop screen.Example 1:Input: s = &quot;string&quot;Output: &quot;rtsng&quot;Explanation: After typing first character, the text on the screen is &quot;s&quot;.After the second character, the text is &quot;st&quot;. After the third character, the text is &quot;str&quot;.Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.After the fifth character, the text is &quot;rtsn&quot;. After the sixth character, the text is &quot;rtsng&quot;. Therefore, we return &quot;rtsng&quot;.Example 2:Input: s = &quot;poiinter&quot;Output: &quot;ponter&quot;Explanation: After the first character, the text on the screen is &quot;p&quot;.After the second character, the text is &quot;po&quot;. Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.After the fifth character, the text is &quot;pon&quot;.After the sixth character, the text is &quot;pont&quot;. After the seventh character, the text is &quot;ponte&quot;. After the eighth character, the text is &quot;ponter&quot;. Therefore, we return &quot;ponter&quot;. Constraints:1 &lt;= s.length &lt;= 100s consists of lowercase English letters.s[0] != &#39;i&#39; | Class Solution {Public:    Std::string Finalstring(std::string S) {        Std::string Result = &quot;&quot;;        For (Char C : S) {            If (C == &#39;I&#39;) {                Std::reverse(result.begin(), Result.end());            } Else {                Result += C;            }        }        Return Result;    }}; | Class Solution {Public:    String Finalstring(const String &amp;S) {        String A, B;        For (Char Ch : S)            If (Ch == &#39;I&#39;)                Swap(a, B);            Else                A += Ch;        Return String(rbegin(b), Rend(b)) + A;    }}; 
 7 | 3 | Java | medium | Bing AI Chat | Chatbot | You are given a 0-indexed integer array nums and an integer x.Find the minimum absolute difference between two elements in the array that are at least x indices apart.In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.Example 1:Input: nums = [4,3,2,4], x = 2Output: 0Explanation: We can select nums[0] = 4 and nums[3] = 4. They are at least 2 indices apart, and their absolute difference is the minimum, 0. It can be shown that 0 is the optimal answer.Example 2:Input: nums = [5,3,2,10,15], x = 1Output: 1Explanation: We can select nums[1] = 3 and nums[2] = 2.They are at least 1 index apart, and their absolute difference is the minimum, 1.It can be shown that 1 is the optimal answer.Example 3:Input: nums = [1,2,3,4], x = 3Output: 3Explanation: We can select nums[0] = 1 and nums[3] = 4.They are at least 3 indices apart, and their absolute difference is the minimum, 3.It can be shown that 3 is the optimal answer. Constraints:1 &lt;= nums.length &lt;= 10^51 &lt;= nums[i] &lt;= 10^90 &lt;= x &lt; nums.length  | Solve the following problem with java code. Class name: Solution, Method name: minAbsoluteDifference(List&lt;Integer&gt; nums, int x).You are given a 0-indexed integer array nums and an integer x.Find the minimum absolute difference between two elements in the array that are at least x indices apart.In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.Example 1:Input: nums = [4,3,2,4], x = 2Output: 0Explanation: We can select nums[0] = 4 and nums[3] = 4. They are at least 2 indices apart, and their absolute difference is the minimum, 0. It can be shown that 0 is the optimal answer.Example 2:Input: nums = [5,3,2,10,15], x = 1Output: 1Explanation: We can select nums[1] = 3 and nums[2] = 2.They are at least 1 index apart, and their absolute difference is the minimum, 1.It can be shown that 1 is the optimal answer.Example 3:Input: nums = [1,2,3,4], x = 3Output: 3Explanation: We can select nums[0] = 1 and nums[3] = 4.They are at least 3 indices apart, and their absolute difference is the minimum, 3.It can be shown that 3 is the optimal answer. Constraints:1 &lt;= nums.length &lt;= 10^51 &lt;= nums[i] &lt;= 10^90 &lt;= x &lt; nums.length | Public Class Solution {    Public Int Minabsolutedifference(list&lt;integer&gt; Nums, Int X) {        Treemap&lt;integer, Integer&gt; Map = New Treemap&lt;&gt;();        Map.put(nums.get(0), 0);        Int N = Nums.size();        Int Mindiff = Integer.max_value;        For (Int I = 1; I &lt; N; I++) {            If (I &gt;= X) {                Map.remove(nums.get(i - X));            }            Integer Lower = Map.floorkey(nums.get(i));            Integer Higher = Map.ceilingkey(nums.get(i));            If (Lower != Null) {                Mindiff = Math.min(mindiff, Math.abs(nums.get(i) - Lower));            }            If (Higher != Null) {                Mindiff = Math.min(mindiff, Math.abs(nums.get(i) - Higher));            }            Map.put(nums.get(i), I);        }        Return Mindiff;    }} | Class Solution {    Int Minabsolutedifference(list&lt;integer&gt; Nums, Int X) {        Int Ans = Integer.max_value;        Treeset&lt;integer&gt; S = New Treeset&lt;&gt;();        For(int I = X; I &lt; Nums.size(); ++I){            S.add(nums.get(i-x));            Integer High = S.ceiling(nums.get(i)), Low = S.floor(nums.get(i));            If(high != Null) Ans = Math.min(ans, Math.abs(nums.get(i) - High));            If(low != Null) Ans = Math.min(ans, Math.abs(nums.get(i) - Low));        }        Return Ans;    }} 
 8 | 3 | Python | medium | Bing AI Chat | Chatbot | You are given a 0-indexed integer array nums and an integer x.Find the minimum absolute difference between two elements in the array that are at least x indices apart.In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.Example 1:Input: nums = [4,3,2,4], x = 2Output: 0Explanation: We can select nums[0] = 4 and nums[3] = 4. They are at least 2 indices apart, and their absolute difference is the minimum, 0. It can be shown that 0 is the optimal answer.Example 2:Input: nums = [5,3,2,10,15], x = 1Output: 1Explanation: We can select nums[1] = 3 and nums[2] = 2.They are at least 1 index apart, and their absolute difference is the minimum, 1.It can be shown that 1 is the optimal answer.Example 3:Input: nums = [1,2,3,4], x = 3Output: 3Explanation: We can select nums[0] = 1 and nums[3] = 4.They are at least 3 indices apart, and their absolute difference is the minimum, 3.It can be shown that 3 is the optimal answer. Constraints:1 &lt;= nums.length &lt;= 10^51 &lt;= nums[i] &lt;= 10^90 &lt;= x &lt; nums.length  | Solve the following problem with python3 code. Class name: Solution, Method name: def minAbsoluteDifference(self, nums: List[int], x: int) -&gt; int:.You are given a 0-indexed integer array nums and an integer x.Find the minimum absolute difference between two elements in the array that are at least x indices apart.In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.Example 1:Input: nums = [4,3,2,4], x = 2Output: 0Explanation: We can select nums[0] = 4 and nums[3] = 4. They are at least 2 indices apart, and their absolute difference is the minimum, 0. It can be shown that 0 is the optimal answer.Example 2:Input: nums = [5,3,2,10,15], x = 1Output: 1Explanation: We can select nums[1] = 3 and nums[2] = 2.They are at least 1 index apart, and their absolute difference is the minimum, 1.It can be shown that 1 is the optimal answer.Example 3:Input: nums = [1,2,3,4], x = 3Output: 3Explanation: We can select nums[0] = 1 and nums[3] = 4.They are at least 3 indices apart, and their absolute difference is the minimum, 3.It can be shown that 3 is the optimal answer. Constraints:1 &lt;= nums.length &lt;= 10^51 &lt;= nums[i] &lt;= 10^90 &lt;= x &lt; nums.length | Class Solution:    Def Minabsolutedifference(self, Nums: List[int], X: Int) -&gt; Int:        N = Len(nums)        Min_diff = Float(&#39;inf&#39;)        For I In Range(n):            For J In Range(i + X, N):                Min_diff = Min(min_diff, Abs(nums[i] - Nums[j]))        Return Min_diff | Class Solution:  Def Minabsolutedifference(self, Nums: List[int], X: Int) -&gt; Int:    If X == 0:      Return 0    Arr, Best_dist = Sortedlist([]), Float(&#39;inf&#39;)    For I In Range(x, Len(nums)):      Arr.add(nums[i - X])      V = Nums[i]      Pos = Arr.bisect_left(v)      If Pos &lt; Len(arr):        Best_dist = Min(best_dist, Abs(arr[pos] - V))      If Pos &gt; 0:        Best_dist = Min(best_dist, Abs(arr[pos - 1] - V))        Return Best_dist 
 9 | 3 | C++ | medium | Bing AI Chat | Chatbot | You are given a 0-indexed integer array nums and an integer x.Find the minimum absolute difference between two elements in the array that are at least x indices apart.In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.Example 1:Input: nums = [4,3,2,4], x = 2Output: 0Explanation: We can select nums[0] = 4 and nums[3] = 4. They are at least 2 indices apart, and their absolute difference is the minimum, 0. It can be shown that 0 is the optimal answer.Example 2:Input: nums = [5,3,2,10,15], x = 1Output: 1Explanation: We can select nums[1] = 3 and nums[2] = 2.They are at least 1 index apart, and their absolute difference is the minimum, 1.It can be shown that 1 is the optimal answer.Example 3:Input: nums = [1,2,3,4], x = 3Output: 3Explanation: We can select nums[0] = 1 and nums[3] = 4.They are at least 3 indices apart, and their absolute difference is the minimum, 3.It can be shown that 3 is the optimal answer. Constraints:1 &lt;= nums.length &lt;= 10^51 &lt;= nums[i] &lt;= 10^90 &lt;= x &lt; nums.length  | Solve the following problem with C++ code. Class name: Solution, Method name: int minAbsoluteDifference(vector&lt;int&gt;&amp; nums, int x).You are given a 0-indexed integer array nums and an integer x.Find the minimum absolute difference between two elements in the array that are at least x indices apart.In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.Example 1:Input: nums = [4,3,2,4], x = 2Output: 0Explanation: We can select nums[0] = 4 and nums[3] = 4. They are at least 2 indices apart, and their absolute difference is the minimum, 0. It can be shown that 0 is the optimal answer.Example 2:Input: nums = [5,3,2,10,15], x = 1Output: 1Explanation: We can select nums[1] = 3 and nums[2] = 2.They are at least 1 index apart, and their absolute difference is the minimum, 1.It can be shown that 1 is the optimal answer.Example 3:Input: nums = [1,2,3,4], x = 3Output: 3Explanation: We can select nums[0] = 1 and nums[3] = 4.They are at least 3 indices apart, and their absolute difference is the minimum, 3.It can be shown that 3 is the optimal answer. Constraints:1 &lt;= nums.length &lt;= 10^51 &lt;= nums[i] &lt;= 10^90 &lt;= x &lt; nums.length | Class Solution {Public:    Int Minabsolutedifference(std::vector&lt;int&gt;&amp; Nums, Int X) {        Int Mindiff = Int_max;        For (Int I = 0; I &lt; Nums.size(); I++) {            For (Int J = I + X; J &lt; Nums.size(); J++) {                Mindiff = Std::min(mindiff, Std::abs(nums[i] - Nums[j]));            }        }        Return Mindiff;    }}; | Class Solution {Public:    Int Minabsolutedifference(vector&lt;int&gt;&amp; Nums, Int X) {        Int Ans = Int_max;        Set&lt;int&gt; S;        For(int I = X; I &lt; Nums.size(); ++I){            S.insert(nums[i-x]);            Auto It = S.upper_bound(nums[i]);            If(it != S.end()) Ans = Min(ans, Abs(nums[i] - *It));            If(it != S.begin()) Ans = Min(ans, Abs(nums[i] - *Prev(it)));        }        Return Ans;    }}; 
 10 | 4 | Java | medium | Bing AI Chat | Chatbot | You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.Return the head of the linked list after doubling it.Example 1:Input: head = [1,8,9]Output: [3,7,8]Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.Example 2:Input: head = [9,9,9]Output: [1,9,9,8]Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. Constraints:The number of nodes in the list is in the range [1, 10^4]0 &lt;= Node.val &lt;= 9The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.  | Solve the following problem with java code. Class name: Solution, Method name: doubleIt(ListNode head).You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.Return the head of the linked list after doubling it.Example 1:Input: head = [1,8,9]Output: [3,7,8]Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.Example 2:Input: head = [9,9,9]Output: [1,9,9,8]Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. Constraints:The number of nodes in the list is in the range [1, 10^4]0 &lt;= Node.val &lt;= 9The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself. | Class Solution {    Public Listnode Doubleit(listnode Head) {        // Convert Linked List To Number        Long Num = 0;        While (Head != Null) {            Num = Num * 10 + Head.val;            Head = Head.next;        }        // Double The Number        Num *= 2;        // Convert Number Back To Linked List        Listnode Dummy = New Listnode(0);        Listnode Curr = Dummy;        Do {            Curr.next = New Listnode((int)(num % 10));            Num /= 10;            Curr = Curr.next;        } While (Num &gt; 0);        // Reverse The Linked List And Return        Return Reverse(dummy.next);    }    Private Listnode Reverse(listnode Head) {        Listnode Prev = Null;        While (Head != Null) {            Listnode Next = Head.next;            Head.next = Prev;            Prev = Head;            Head = Next;        }        Return Prev;    }} | Class Solution {    Public Listnode Doubleit(listnode Head) {        If (Head.val &gt; 4)            Head = New Listnode(0, Head);        For(listnode Node = Head; Node != Null; Node = Node.next) {            Node.val = (Node.val * 2) % 10;            If (Node.next != Null &amp;&amp; Node.next.val &gt; 4)                Node.val++;        }        Return Head;    }} 
 11 | 4 | Python | medium | Bing AI Chat | Chatbot | You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.Return the head of the linked list after doubling it.Example 1:Input: head = [1,8,9]Output: [3,7,8]Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.Example 2:Input: head = [9,9,9]Output: [1,9,9,8]Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. Constraints:The number of nodes in the list is in the range [1, 10^4]0 &lt;= Node.val &lt;= 9The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.  | Solve the following problem with python3 code. Class name: Solution, Method name: def doubleIt(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:.You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.Return the head of the linked list after doubling it.Example 1:Input: head = [1,8,9]Output: [3,7,8]Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.Example 2:Input: head = [9,9,9]Output: [1,9,9,8]Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. Constraints:The number of nodes in the list is in the range [1, 10^4]0 &lt;= Node.val &lt;= 9The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself. | Class Solution:    Def Doubleit(self, Head: Optional[listnode]) -&gt; Optional[listnode]:        # Convert Linked List To Integer        Num = 0        Curr = Head        While Curr:            Num = Num * 10 + Curr.val            Curr = Curr.next        # Double The Integer        Num *= 2        # Convert Integer To Linked List        Dummy = Listnode(0)        Curr = Dummy        For Digit In Str(num):            Curr.next = Listnode(int(digit))            Curr = Curr.next        Return Dummy.next | Class Solution:    Def Doubleit(self, Head: Optional[listnode]) -&gt; Optional[listnode]:        If Head.val &gt; 4:            Head = Listnode(0, Head)        Node = Head        While Node:            Node.val = (Node.val * 2) % 10            If Node.next And Node.next.val &gt; 4:                Node.val += 1            Node = Node.next        Return Head 
 12 | 4 | C++ | medium | Bing AI Chat | Chatbot | You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.Return the head of the linked list after doubling it.Example 1:Input: head = [1,8,9]Output: [3,7,8]Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.Example 2:Input: head = [9,9,9]Output: [1,9,9,8]Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. Constraints:The number of nodes in the list is in the range [1, 10^4]0 &lt;= Node.val &lt;= 9The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.  | Solve the following problem with C++ code. Class name: Solution, Method name: ListNode* doubleIt(ListNode* head).You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.Return the head of the linked list after doubling it.Example 1:Input: head = [1,8,9]Output: [3,7,8]Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.Example 2:Input: head = [9,9,9]Output: [1,9,9,8]Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. Constraints:The number of nodes in the list is in the range [1, 10^4]0 &lt;= Node.val &lt;= 9The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself. | Class Solution {Public:    Listnode* Doubleit(listnode* Head) {        Listnode* Current = Head;        Int Carry = 0;        While (Current != Nullptr) {            Int Sum = Current-&gt;val * 2 + Carry;            Current-&gt;val = Sum % 10;            Carry = Sum / 10;            If (Current-&gt;next == Nullptr &amp;&amp; Carry &gt; 0) {                Current-&gt;next = New Listnode(carry);                Break;            }            Current = Current-&gt;next;        }        Return Head;    }}; | Class Solution {Public:    Listnode* Doubleit(listnode* Head) {        If (Head-&gt;val &gt; 4)            Head = New Listnode(0, Head);        For(listnode* Node = Head; Node; Node = Node-&gt;next) {            Node-&gt;val = (Node-&gt;val * 2) % 10;            If (Node-&gt;next &amp;&amp; Node-&gt;next-&gt;val &gt; 4)                Node-&gt;val++;        }        Return Head;    }}; 
 13 | 5 | Java | hard | Bing AI Chat | Chatbot | You are given an array nums of n positive integers and an integer k.Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.Multiply your score by x.Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.Return the maximum possible score after applying at most k operations.Since the answer may be large, return it modulo 10^9 + 7.Example 1:Input: nums = [8,3,9,3,8], k = 2Output: 81Explanation: To get a score of 81, we can apply the following operations:- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.It can be proven that 81 is the highest score one can obtain.Example 2:Input: nums = [19,12,14,6,10,18], k = 3Output: 4788Explanation: To get a score of 4788, we can apply the following operations: - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.It can be proven that 4788 is the highest score one can obtain. Constraints:1 &lt;= nums.length == n &lt;= 10^51 &lt;= nums[i] &lt;= 10^51 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9)  | Solve the following problem with java code. Class name: Solution, Method name: maximumScore(List&lt;Integer&gt; nums, int k).You are given an array nums of n positive integers and an integer k.Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.Multiply your score by x.Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.Return the maximum possible score after applying at most k operations.Since the answer may be large, return it modulo 10^9 + 7.Example 1:Input: nums = [8,3,9,3,8], k = 2Output: 81Explanation: To get a score of 81, we can apply the following operations:- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.It can be proven that 81 is the highest score one can obtain.Example 2:Input: nums = [19,12,14,6,10,18], k = 3Output: 4788Explanation: To get a score of 4788, we can apply the following operations: - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.It can be proven that 4788 is the highest score one can obtain. Constraints:1 &lt;= nums.length == n &lt;= 10^51 &lt;= nums[i] &lt;= 10^51 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9). | Public Class Solution {    Private Static Final Int Mod = 1_000_000_007;    Private List&lt;integer&gt; Nums;    Private Int N;    Private List&lt;integer&gt;[] Factors;    Public Int Maximumscore(list&lt;integer&gt; Nums, Int K) {        This.nums = Nums;        This.n = Nums.size();        This.factors = New Arraylist[n];        For (Int I = 0; I &lt; N; I++) {            Factors[i] = Primefactors(nums.get(i));        }        Priorityqueue&lt;int[]&gt; Pq = New Priorityqueue&lt;&gt;((a, B) -&gt; B[2] - A[2]);        Pq.offer(new Int[]{0, N - 1, Maxprimescore(0, N - 1)});        Long Res = 1;        Boolean[] Chosen = New Boolean[n];        While (K-- &gt; 0) {            Int[] Cur = Pq.poll();            Int L = Cur[0], R = Cur[1], Maxscore = Cur[2];            Res = (Res * Maxscore) % Mod;            Int Maxidx = Maxprimescoreindex(l, R);            Chosen[maxidx] = True;            If (Maxidx - 1 &gt;= L &amp;&amp; !Chosen[maxidx - 1]) {                Pq.offer(new Int[]{l, Maxidx - 1, Maxprimescore(l, Maxidx - 1)});            }            If (Maxidx + 1 &lt;= R &amp;&amp; !Chosen[maxidx + 1]) {                Pq.offer(new Int[]{maxidx + 1, R, Maxprimescore(maxidx + 1, R)});            }        }        Return (Int) Res;    }    Private List&lt;integer&gt; Primefactors(int Num) {        List&lt;integer&gt; Factors = New Arraylist&lt;&gt;();        For (Int I = 2; I * I &lt;= Num; I++) {            If (Num % I == 0) {                Factors.add(i);                While (Num % I == 0) {                    Num /= I;                }            }        }        If (Num &gt; 1) {            Factors.add(num);        }        Return Factors;    }    Private Int Maxprimescore(int L, Int R) {        Int Maxscore = 0;        For (Int I = L; I &lt;= R; I++) {            Maxscore = Math.max(maxscore, Factors[i].size());        }        Return Maxscore;    }    Private Int Maxprimescoreindex(int L, Int R) {        Int Maxscore = 0, Idx = -1;        For (Int I = L; I &lt;= R; I++) {            If (Factors[i].size() &gt;= Maxscore) {                Maxscore = Factors[i].size();                Idx = I;            }        }        Return Idx;    }} | Class Solution {    Static Final Int Mod = 1000000007;    Public Int Maximumscore(list&lt;integer&gt; Nums, Int K) {        Int N = Nums.size();        Int Upper = Collections.max(nums) + 1;        Boolean[] Prime = New Boolean[upper];        Int[] Primescore = New Int[upper];        Arrays.fill(prime, True);        Prime[0] = Prime[1] = False;        For (Int I = 2; I &lt; Upper; I++) {            If (Prime[i]) {                For (Int J = I; J &lt; Upper; J += I) {                    Primescore[j]++;                    Prime[j] = False;                }            }        }        Int[] Nextgreaterelement = New Int[n];        Arrays.fill(nextgreaterelement, N);        Stack&lt;integer&gt; S = New Stack&lt;&gt;();        For (Int I = N - 1; I &gt;= 0; I--) {            While (!S.empty() &amp;&amp; Primescore[nums.get(i)] &gt;= Primescore[nums.get(s.peek())]) {                S.pop();            }            Nextgreaterelement[i] = S.empty() ? N : S.peek();            S.push(i);        }        Int[] Prevgreaterorequalelement = New Int[n];        Arrays.fill(prevgreaterorequalelement, -1);        S = New Stack&lt;&gt;();        For (Int I = 0; I &lt; N; I++) {            While (!S.empty() &amp;&amp; Primescore[nums.get(i)] &gt; Primescore[nums.get(s.peek())]) {                S.pop();            }            Prevgreaterorequalelement[i] = S.empty() ? -1 : S.peek();            S.push(i);        }        Int Res = 1;        Int[][] Tuples = New Int[n][2];        For (Int I = 0; I &lt; N; I++) {            Tuples[i][0] = Nums.get(i);            Tuples[i][1] = I;        }        Arrays.sort(tuples, New Comparator&lt;int[]&gt;() {            Public Int Compare(int[] A, Int[] B) {                Return B[0] - A[0];            }        });        For (Int I = 0; I &lt; N; I++) {            Int Num = Tuples[i][0];            Int Idx = Tuples[i][1];            Int Operations = Math.min((idx - Prevgreaterorequalelement[idx]) * (Nextgreaterelement[idx] - Idx), K);            Res = (Int)((1l * Res * Pow(num, Operations)) % Mod);            K -= Operations;            If (K == 0) {                Return Res;            }        }        Return Res;    }    Public Int Pow(int X, Int N) {        Int Res = 1;        While (N &gt; 0) {            If (N % 2 == 1) {                Res = (Int)((1l * Res * X) % Mod);            }            X = (Int)((1l * X * X) % Mod);            N /= 2;        }        Return Res;    }} 
 14 | 5 | Python | hard | Bing AI Chat | Chatbot | You are given an array nums of n positive integers and an integer k.Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.Multiply your score by x.Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.Return the maximum possible score after applying at most k operations.Since the answer may be large, return it modulo 10^9 + 7.Example 1:Input: nums = [8,3,9,3,8], k = 2Output: 81Explanation: To get a score of 81, we can apply the following operations:- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.It can be proven that 81 is the highest score one can obtain.Example 2:Input: nums = [19,12,14,6,10,18], k = 3Output: 4788Explanation: To get a score of 4788, we can apply the following operations: - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.It can be proven that 4788 is the highest score one can obtain. Constraints:1 &lt;= nums.length == n &lt;= 10^51 &lt;= nums[i] &lt;= 10^51 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9)  | Solve the following problem with python3 code. Class name: Solution, Method name: def maximumScore(self, nums: List[int], k: int) -&gt; int:.You are given an array nums of n positive integers and an integer k.Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.Multiply your score by x.Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.Return the maximum possible score after applying at most k operations.Since the answer may be large, return it modulo 10^9 + 7.Example 1:Input: nums = [8,3,9,3,8], k = 2Output: 81Explanation: To get a score of 81, we can apply the following operations:- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.It can be proven that 81 is the highest score one can obtain.Example 2:Input: nums = [19,12,14,6,10,18], k = 3Output: 4788Explanation: To get a score of 4788, we can apply the following operations: - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.It can be proven that 4788 is the highest score one can obtain. Constraints:1 &lt;= nums.length == n &lt;= 10^51 &lt;= nums[i] &lt;= 10^51 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9). | Class Solution:    Def Maximumscore(self, Nums: List[int], K: Int) -&gt; Int:        N = Len(nums)        Mod = 10**9 + 7        # Precompute The Prime Score Of All Numbers In Nums        Prime_score = [0] * N        For I, Num In Enumerate(nums):            For J In Range(2, Int(sqrt(num)) + 1):                If Num % J == 0:                    Prime_score[i] += 1                    While Num % J == 0:                        Num //= J            If Num &gt; 1:                Prime_score[i] += 1        # Compute The Maximum Score Using Dynamic Programming        Dp = [1]        For _ In Range(k):            New_dp = [0] * (N + 1)            For L In Range(n):                For R In Range(l, N):                    Max_prime_score = Max(prime_score[l:r+1])                    Max_index = Prime_score[l:r+1].index(max_prime_score) + L                    New_dp[r+1] = Max(new_dp[r+1], Dp[l] * Nums[max_index] % Mod)            Dp = New_dp        Return Max(dp) % Mod | Class Solution:     Mod = 1000000007    Def Maximumscore(self, Nums: List[int], K: Int) -&gt; Int:        N = Len(nums)        Upper = Max(nums) + 1        Prime = [True]*upper        Prime[0] = Prime[1] = False        Primescore = [0]*upper        For I In Range(2, Upper):            If Prime[i]:                For J In Range(i, Upper, I):                    Primescore[j] += 1                    Prime[j] = False        Nextgreaterelement = [N]*n        S = []        For I In Range(n - 1, -1, -1):            While S And Primescore[nums[i]] &gt;= Primescore[nums[s[-1]]]:                S.pop()            Nextgreaterelement[i] = S[-1] If S Else N            S.append(i)        Prevgreaterorequalelement = [-1]*n        S = []        For I In Range(n):            While S And Primescore[nums[i]] &gt; Primescore[nums[s[-1]]]:                S.pop()            Prevgreaterorequalelement[i] = S[-1] If S Else -1            S.append(i)        Res = 1        Tuples = [[Nums[i], I] For I In Range(n)]        Tuples.sort(reverse=true)        For Num, Idx In Tuples:            Operations = Min((idx - Prevgreaterorequalelement[idx]) * (Nextgreaterelement[idx] - Idx), K)            Res = (Res * Self.pow(num, Operations)) % Self.mod            K -= Operations            If K == 0:                Return Res        Return Res    Def Pow(self, X: Int, N: Int) -&gt; Int:        Res = 1        While N &gt; 0:            If N % 2 == 1:                Res = (Res * X) % Self.mod            X = (X * X) % Self.mod            N //= 2        Return Res 
 15 | 5 | C++ | hard | Bing AI Chat | Chatbot | You are given an array nums of n positive integers and an integer k.Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.Multiply your score by x.Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.Return the maximum possible score after applying at most k operations.Since the answer may be large, return it modulo 10^9 + 7.Example 1:Input: nums = [8,3,9,3,8], k = 2Output: 81Explanation: To get a score of 81, we can apply the following operations:- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.It can be proven that 81 is the highest score one can obtain.Example 2:Input: nums = [19,12,14,6,10,18], k = 3Output: 4788Explanation: To get a score of 4788, we can apply the following operations: - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.It can be proven that 4788 is the highest score one can obtain. Constraints:1 &lt;= nums.length == n &lt;= 10^51 &lt;= nums[i] &lt;= 10^51 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9)  | Solve the following problem with C++ code. Class name: Solution, Method name: int maximumScore(vector&lt;int&gt;&amp; nums, int k).You are given an array nums of n positive integers and an integer k.Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.Multiply your score by x.Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.Return the maximum possible score after applying at most k operations.Since the answer may be large, return it modulo 10^9 + 7.Example 1:Input: nums = [8,3,9,3,8], k = 2Output: 81Explanation: To get a score of 81, we can apply the following operations:- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.It can be proven that 81 is the highest score one can obtain.Example 2:Input: nums = [19,12,14,6,10,18], k = 3Output: 4788Explanation: To get a score of 4788, we can apply the following operations: - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.It can be proven that 4788 is the highest score one can obtain. Constraints:1 &lt;= nums.length == n &lt;= 10^51 &lt;= nums[i] &lt;= 10^51 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9). | Class Solution {Public:    Int Maximumscore(std::vector&lt;int&gt;&amp; Nums, Int K) {        Const Int Mod = 1e9 + 7;        Int N = Nums.size();        Std::vector&lt;int&gt; Primescore(n);        For (Int I = 0; I &lt; N; I++) {            Primescore[i] = Getprimescore(nums[i]);        }        Std::vector&lt;std::vector&lt;long Long&gt;&gt; Dp(n, Std::vector&lt;long Long&gt;(k + 1));        For (Int I = 0; I &lt; N; I++) {            Dp[i][0] = Nums[i];            For (Int J = 1; J &lt;= K; J++) {                For (Int L = 0; L &lt; I; L++) {                    If (Primescore[l] &gt;= Primescore[i]) {                        Dp[i][j] = Std::max(dp[i][j], Dp[l][j - 1] * Nums[i] % Mod);                    }                }            }        }        Long Long Maxscore = 0;        For (Int I = 0; I &lt; N; I++) {            Maxscore = Std::max(maxscore, Dp[i][k]);        }        Return Maxscore % Mod;    }Private:    Int Getprimescore(int Num) {        Int Score = 0;        For (Int I = 2; I &lt;= Std::sqrt(num); I++) {            If (Num % I == 0) {                Score++;                While (Num % I == 0) {                    Num /= I;                }            }        }        If (Num &gt; 1) {            Score++;        }        Return Score;    }}; | Class Solution {Public:    Const Int Mod = 1000000007;    Int Maximumscore(vector&lt;int&gt;&amp; Nums, Int K) {        Int N = Nums.size();        Int Upper = *Max_element(nums.begin(), Nums.end()) + 1;        Vector&lt;bool&gt; Prime(upper, True);        Prime[0] = Prime[1] = False;        Vector&lt;int&gt; Primescore(upper, 0);        For (Int I = 2; I &lt; Upper; I++) {            If (Prime[i]) {                For (Int J = I; J &lt; Upper; J += I) {                    Primescore[j]++;                    Prime[j] = False;                }            }        }        Vector&lt;int&gt; Nextgreaterelement(n, N);        Stack&lt;int&gt; S;        For (Int I = N - 1; I &gt;= 0; I--) {            While (!S.empty() &amp;&amp; Primescore[nums[i]] &gt;= Primescore[nums[s.top()]]) {                S.pop();            }            Nextgreaterelement[i] = S.empty() ? N : S.top();            S.push(i);        }        Vector&lt;int&gt; Prevgreaterorequalelement(n, -1);        S = Stack&lt;int&gt;();        For (Int I = 0; I &lt; N; I++) {            While (!S.empty() &amp;&amp; Primescore[nums[i]] &gt; Primescore[nums[s.top()]]) {                S.pop();            }            Prevgreaterorequalelement[i] = S.empty() ? -1 : S.top();            S.push(i);        }        Int Res = 1;        Vector&lt;pair&lt;int, Int&gt;&gt; Tuples(n);        For (Int I = 0; I &lt; N; I++) {            Tuples[i].first = Nums[i];            Tuples[i].second = I;        }        Sort(tuples.rbegin(), Tuples.rend());        For (Const Auto&amp; [Num, I] : Tuples) {            Int Operations = Min((i - Prevgreaterorequalelement[i]) * (Nextgreaterelement[i] - I), K);            Res = (Int)((1l * Res * Pow(num, Operations)) % Mod);            K -= Operations;            If (K == 0) {                Return Res;            }        }        Return Res;    }    Int Pow(int X, Int N) {        Int Res = 1;        While (N &gt; 0) {            If (N % 2 == 1) {                Res = (Int)((1l * Res * X) % Mod);            }            X = (Int)((1l * X * X) % Mod);            N /= 2;        }        Return Res;    }}; 
 16 | 6 | Java | hard | Bing AI Chat | Chatbot | You are given a 0-indexed 2D integer array items of length n and an integer k.items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.Your task is to find the maximum elegance from all subsequences of size k in items.Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.Example 1:Input: items = [[3,2],[5,1],[10,1]], k = 2Output: 17Explanation: In this example, we have to select a subsequence of size 2.We can select items[0] = [3,2] and items[2] = [10,1].The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. Example 2:Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3Output: 19Explanation: In this example, we have to select a subsequence of size 3. We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.Example 3:Input: items = [[1,1],[2,1],[3,1]], k = 3Output: 7Explanation: In this example, we have to select a subsequence of size 3. We should select all the items. The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. Hence, the maximum elegance is 6 + 1^2 = 7.   Constraints:1 &lt;= items.length == n &lt;= 10^5items[i].length == 2items[i][0] == profit_iitems[i][1] == category_i1 &lt;= profit_i &lt;= 10^91 &lt;= category_i &lt;= n 1 &lt;= k &lt;= n  | Solve the following problem with java code. Class name: Solution, Method name: findMaximumElegance(int [][] items, int k).You are given a 0-indexed 2D integer array items of length n and an integer k.items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.Your task is to find the maximum elegance from all subsequences of size k in items.Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.Example 1:Input: items = [[3,2],[5,1],[10,1]], k = 2Output: 17Explanation: In this example, we have to select a subsequence of size 2.We can select items[0] = [3,2] and items[2] = [10,1].The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. Example 2:Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3Output: 19Explanation: In this example, we have to select a subsequence of size 3. We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.Example 3:Input: items = [[1,1],[2,1],[3,1]], k = 3Output: 7Explanation: In this example, we have to select a subsequence of size 3. We should select all the items. The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. Hence, the maximum elegance is 6 + 1^2 = 7.   Constraints:1 &lt;= items.length == n &lt;= 10^5items[i].length == 2items[i][0] == profit_iitems[i][1] == category_i1 &lt;= profit_i &lt;= 10^91 &lt;= category_i &lt;= n 1 &lt;= k &lt;= n | Class Solution {    Private Static Final Int Mod = 1_000_000_007;    Public Int Findmaximumelegance(int[][] Items, Int K) {        Int N = Items.length;        List&lt;int[]&gt;[] Categoryitems = New List[n + 1];        For (Int I = 0; I &lt;= N; I++) {            Categoryitems[i] = New Arraylist&lt;&gt;();        }        For (Int[] Item : Items) {            Categoryitems[item[1]].add(item);        }        Priorityqueue&lt;integer&gt; Pq = New Priorityqueue&lt;&gt;();        Long[] Dp = New Long[k + 1];        Dp[0] = 0;        Int Totalitems = 0;        For (List&lt;int[]&gt; Itemlist : Categoryitems) {            If (Itemlist.isempty()) Continue;            Collections.sort(itemlist, Comparator.comparingint(a -&gt; -A[0]));            Int Categoryprofit = 0;            For (Int[] Item : Itemlist) {                Categoryprofit += Item[0];                Pq.offer(item[0]);                If (Pq.size() &gt; Totalitems + 1) {                    Categoryprofit -= Pq.poll();                }            }            For (Int J = Math.min(k, Totalitems + Itemlist.size()); J &gt;= 0; J--) {                For (Int L = Math.max(0, J - Totalitems); L &lt;= Math.min(j, Itemlist.size()); L++) {                    Dp[j] = Math.max(dp[j], (J - L &gt; 0 ? Dp[j - L - 1] : 0) + Categoryprofit);                }            }            Totalitems += Itemlist.size();        }        Long Res = 0;        For (Int I = 1; I &lt;= K; I++) {            Res = Math.max(res, Dp[i] + (Long)i * I);        }        Return (Int)(res % Mod);    }} | Class Solution {    Public Long Findmaximumelegance(int[][] A, Int K) {        Arrays.sort(a, (A, B) -&gt; B[0] - A[0]);        Long Res = 0, Cur = 0;        List&lt;integer&gt; Dup = New Arraylist&lt;&gt;();        Set&lt;integer&gt; Seen = New Hashset&lt;&gt;();        For (Int I = 0; I &lt; A.length; ++I) {            If (I &lt; K) {                If (Seen.contains(a[i][1])) {                    Dup.add(a[i][0]);                }                Cur += A[i][0];            } Else If (!Seen.contains(a[i][1])) {                If (Dup.isempty()) Break;                Cur += A[i][0] - Dup.remove(dup.size() - 1);            }            Seen.add(a[i][1]);            Res = Math.max(res, Cur + 1l * Seen.size() * Seen.size());        }        Return Res;    }} 
 17 | 6 | Python | hard | Bing AI Chat | Chatbot | You are given a 0-indexed 2D integer array items of length n and an integer k.items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.Your task is to find the maximum elegance from all subsequences of size k in items.Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.Example 1:Input: items = [[3,2],[5,1],[10,1]], k = 2Output: 17Explanation: In this example, we have to select a subsequence of size 2.We can select items[0] = [3,2] and items[2] = [10,1].The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. Example 2:Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3Output: 19Explanation: In this example, we have to select a subsequence of size 3. We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.Example 3:Input: items = [[1,1],[2,1],[3,1]], k = 3Output: 7Explanation: In this example, we have to select a subsequence of size 3. We should select all the items. The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. Hence, the maximum elegance is 6 + 1^2 = 7.   Constraints:1 &lt;= items.length == n &lt;= 10^5items[i].length == 2items[i][0] == profit_iitems[i][1] == category_i1 &lt;= profit_i &lt;= 10^91 &lt;= category_i &lt;= n 1 &lt;= k &lt;= n  | Solve the following problem with python3 code. Class name: Solution, Method name: def findMaximumElegance(self, items: List[List[int]], k: int) -&gt; int:.You are given a 0-indexed 2D integer array items of length n and an integer k.items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.Your task is to find the maximum elegance from all subsequences of size k in items.Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.Example 1:Input: items = [[3,2],[5,1],[10,1]], k = 2Output: 17Explanation: In this example, we have to select a subsequence of size 2.We can select items[0] = [3,2] and items[2] = [10,1].The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. Example 2:Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3Output: 19Explanation: In this example, we have to select a subsequence of size 3. We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.Example 3:Input: items = [[1,1],[2,1],[3,1]], k = 3Output: 7Explanation: In this example, we have to select a subsequence of size 3. We should select all the items. The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. Hence, the maximum elegance is 6 + 1^2 = 7.   Constraints:1 &lt;= items.length == n &lt;= 10^5items[i].length == 2items[i][0] == profit_iitems[i][1] == category_i1 &lt;= profit_i &lt;= 10^91 &lt;= category_i &lt;= n 1 &lt;= k &lt;= n | Class Solution:    Def Findmaximumelegance(self, Items: List[list[int]], K: Int) -&gt; Int:        N = Len(items)        Items.sort(key=lambda X: (-X[0], X[1]))        Dp = [[0, 0] For _ In Range(n + 1)]        For I In Range(1, N + 1):            Dp[i][0] = Max(dp[i - 1][0], Dp[i - 1][1])            Dp[i][1] = Max(dp[i - 1][0] + Items[i - 1][0], Dp[i - 1][1] + Items[i - 1][0])        Return Max(dp[k]) + Len(set([item[1] For Item In Items[:k]])) ** 2 | Class Solution:    Def Findmaximumelegance(self, Items: List[list[int]], K: Int) -&gt; Int:        Items = Sorted(items, Key=lambda V: -V[0])        Res = Cur = 0        A = []        Seen = Set()        For I, (P, C) In Enumerate(items):            If I &lt; K:                If C In Seen:                    A.append(p)                Cur += P            Elif C Not In Seen:                If Not A: Break                Cur += P - A.pop()            Seen.add(c)            Res = Max(res, Cur + Len(seen) * Len(seen))        Return Res 
 18 | 6 | C++ | hard | Bing AI Chat | Chatbot | You are given a 0-indexed 2D integer array items of length n and an integer k.items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.Your task is to find the maximum elegance from all subsequences of size k in items.Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.Example 1:Input: items = [[3,2],[5,1],[10,1]], k = 2Output: 17Explanation: In this example, we have to select a subsequence of size 2.We can select items[0] = [3,2] and items[2] = [10,1].The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. Example 2:Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3Output: 19Explanation: In this example, we have to select a subsequence of size 3. We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.Example 3:Input: items = [[1,1],[2,1],[3,1]], k = 3Output: 7Explanation: In this example, we have to select a subsequence of size 3. We should select all the items. The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. Hence, the maximum elegance is 6 + 1^2 = 7.   Constraints:1 &lt;= items.length == n &lt;= 10^5items[i].length == 2items[i][0] == profit_iitems[i][1] == category_i1 &lt;= profit_i &lt;= 10^91 &lt;= category_i &lt;= n 1 &lt;= k &lt;= n  | Solve the following problem with C++ code. Class name: Solution, Method name: long long findMaximumElegance(vector&lt;vector&lt;int&gt;&gt;&amp; items, int k).You are given a 0-indexed 2D integer array items of length n and an integer k.items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.Your task is to find the maximum elegance from all subsequences of size k in items.Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.Example 1:Input: items = [[3,2],[5,1],[10,1]], k = 2Output: 17Explanation: In this example, we have to select a subsequence of size 2.We can select items[0] = [3,2] and items[2] = [10,1].The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. Example 2:Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3Output: 19Explanation: In this example, we have to select a subsequence of size 3. We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.Example 3:Input: items = [[1,1],[2,1],[3,1]], k = 3Output: 7Explanation: In this example, we have to select a subsequence of size 3. We should select all the items. The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. Hence, the maximum elegance is 6 + 1^2 = 7.   Constraints:1 &lt;= items.length == n &lt;= 10^5items[i].length == 2items[i][0] == profit_iitems[i][1] == category_i1 &lt;= profit_i &lt;= 10^91 &lt;= category_i &lt;= n 1 &lt;= k &lt;= n | Class Solution {Public:    Long Long Findmaximumelegance(std::vector&lt;std::vector&lt;int&gt;&gt;&amp; Items, Int K) {        Const Int Mod = 1e9 + 7;        Int N = Items.size();        Std::vector&lt;std::unordered_map&lt;int, Long Long&gt;&gt; Dp(n);        For (Int I = 0; I &lt; N; I++) {            Dp[i][1 &lt;&lt; Items[i][1]] = Items[i][0];            For (Int J = 0; J &lt; I; J++) {                For (Auto&amp; [Mask, Val] : Dp[j]) {                    Int Newmask = Mask | (1 &lt;&lt; Items[i][1]);                    Dp[i][newmask] = Std::max(dp[i][newmask], Val + Items[i][0]);                }            }        }        Long Long Maxelegance = 0;        For (Int I = 0; I &lt; N; I++) {            For (Auto&amp; [Mask, Val] : Dp[i]) {                Int Cnt = __builtin_popcount(mask);                If (Cnt &gt;= K) {                    Maxelegance = Std::max(maxelegance, Val + Cnt * Cnt);                }            }        }        Return Maxelegance % Mod;    }}; | Class Solution {Public:    Long Long Findmaximumelegance(vector&lt;vector&lt;int&gt;&gt;&amp; A, Int K) {        Sort(a.begin(), A.end(), [](Const Vector&lt;int&gt;&amp; A, Const Vector&lt;int&gt;&amp; B) {            Return A[0] &gt; B[0];        });        Long Long Res = 0, Cur = 0;        Vector&lt;int&gt; Dup;        Unordered_set&lt;int&gt; Seen;        For (Int I = 0; I &lt; A.size(); ++I) {            If (I &lt; K) {                If (Seen.count(a[i][1])) {                    Dup.push_back(a[i][0]);                }                Cur += A[i][0];            } Else If (Seen.find(a[i][1]) == Seen.end()) {                If (Dup.empty()) Break;                Cur += A[i][0] - Dup.back();                Dup.pop_back();            }            Seen.insert(a[i][1]);            Res = Fmax(res, Cur + 1l * Seen.size() * Seen.size());        }        Return Res;    }}; 
 19 | 1 | Java | easy | ChatGPT | Chatbot | You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.Return the maximum sum or -1 if no such pair exists.Example 1:Input: nums = [51,71,17,24,42]Output: 88Explanation: For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.Example 2:Input: nums = [1,2,3,4]Output: -1Explanation: No pair exists in nums with equal maximum digits.Constraints:2 &lt;= nums.length &lt;= 1001 &lt;= nums[i] &lt;= 10^4  | solve the following problem with java code. Class name: Solution, Method name: maxSum(int[] nums).You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.Return the maximum sum or -1 if no such pair exists.Example 1:Input: nums = [51,71,17,24,42]Output: 88Explanation: For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.Example 2:Input: nums = [1,2,3,4]Output: -1Explanation: No pair exists in nums with equal maximum digits.Constraints:2 &lt;= nums.length &lt;= 1001 &lt;= nums[i] &lt;= 10^4 | Public Class Solution {    Public Int Maxsum(int[] Nums) {        // Create An Array Of Size 10 To Keep Track Of The Maximum Values For Each Digit (0-9)        Int[] Maxdigits = New Int[10];                // Iterate Through The Array And Update The Maxdigits Array With The Maximum Values For Each Digit        For (Int Num : Nums) {            Int Maxdigit = Getmaxdigit(num);            Maxdigits[maxdigit] = Math.max(maxdigits[maxdigit], Num);        }                Int Maxsum = -1;                // Iterate Through The Maxdigits Array To Find Pairs With Equal Maximum Digits        For (Int I = 0; I &lt;= 9; I++) {            For (Int J = I; J &lt;= 9; J++) {                If (Maxdigits[i] != 0 &amp;&amp; Maxdigits[j] != 0 &amp;&amp; I == J) {                    Maxsum = Math.max(maxsum, Maxdigits[i] + Maxdigits[j]);                }            }        }                Return Maxsum;    }        // Helper Method To Get The Maximum Digit From A Number    Private Int Getmaxdigit(int Num) {        Int Maxdigit = 0;        While (Num &gt; 0) {            Maxdigit = Math.max(maxdigit, Num % 10);            Num /= 10;        }        Return Maxdigit;    }    } | Class Solution {    Public Int Maxsum(int[] Nums) {    Int Ans = -1;    Map&lt;integer,list&lt;integer&gt;&gt; Ump = New Hashmap&lt;&gt;();    For(int I = 0; I &lt; Nums.length; ++I){        Int T = Nums[i], Maxdigit = 0;        While(t != 0){ //Evaluate Max Digit In The Number            Maxdigit = Math.max(t%10, Maxdigit);            T = T/10;        }        If(!ump.containskey(maxdigit)) Ump.put(maxdigit, New Arraylist&lt;&gt;());        Ump.get(maxdigit).add(nums[i]); // Add The Number To The Map     }    For(map.entry&lt;integer, List&lt;integer&gt;&gt; Entry: Ump.entryset()){        Entry.getvalue().sort(comparator.reverseorder()); //To Find Max Two Number In Each Max Digit         If(entry.getvalue().size() &gt;= 2) Ans = Math.max(ans, Entry.getvalue().get(0) + Entry.getvalue().get(1)); //Sum Max Two Number And Take Max    }    Return Ans;    }} 
 20 | 1 | Python | easy | ChatGPT | Chatbot | You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.Return the maximum sum or -1 if no such pair exists.Example 1:Input: nums = [51,71,17,24,42]Output: 88Explanation: For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.Example 2:Input: nums = [1,2,3,4]Output: -1Explanation: No pair exists in nums with equal maximum digits.Constraints:2 &lt;= nums.length &lt;= 1001 &lt;= nums[i] &lt;= 10^4  | solve the following problem with python3 code. Class name: Solution, Method name: def maxSum(self, nums: List[int]) -&gt; int:.You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.Return the maximum sum or -1 if no such pair exists.Example 1:Input: nums = [51,71,17,24,42]Output: 88Explanation: For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.Example 2:Input: nums = [1,2,3,4]Output: -1Explanation: No pair exists in nums with equal maximum digits.Constraints:2 &lt;= nums.length &lt;= 1001 &lt;= nums[i] &lt;= 10^4 | Class Solution:    Def Maxsum(self, Nums: List[int]) -&gt; Int:        Max_digit_sum = {}  # Dictionary To Store The Maximum Sum For Each Maximum Digit                For Num In Nums:            Max_digit = Max(str(num))  # Find The Maximum Digit In The Current Number            If Max_digit In Max_digit_sum:                Max_digit_sum[max_digit] = Max(max_digit_sum[max_digit], Num)            Else:                Max_digit_sum[max_digit] = Num                Max_sum = -1  # Initialize The Maximum Sum To -1                # Iterate Through The Dictionary To Find The Maximum Sum        For Digit, Num In Max_digit_sum.items():            If Max_digit_sum[digit] != Num:                Max_sum = Max(max_sum, Num + Max_digit_sum[digit])                Return Max_sum | Class Solution:    Def Maxsum(self, Nums: List[int]) -&gt; Int:        Max_by_digit = Defaultdict(int)        Max_sum = -1        For Num In Nums:            Digit = Max(str(num))            If Digit In Max_by_digit:                Max_sum = Max(max_sum, Max_by_digit[digit] + Num)            Max_by_digit[digit] = Max(max_by_digit[digit], Num)        Return Max_sum 
 21 | 1 | C++ | easy | ChatGPT | Chatbot | You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.Return the maximum sum or -1 if no such pair exists.Example 1:Input: nums = [51,71,17,24,42]Output: 88Explanation: For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.Example 2:Input: nums = [1,2,3,4]Output: -1Explanation: No pair exists in nums with equal maximum digits.Constraints:2 &lt;= nums.length &lt;= 1001 &lt;= nums[i] &lt;= 10^4  | solve the following problem with C++ code. Class name: Solution, Method name: maxSum(std::vector&lt;int&gt;&amp; nums).You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.Return the maximum sum or -1 if no such pair exists.Example 1:Input: nums = [51,71,17,24,42]Output: 88Explanation: For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.Example 2:Input: nums = [1,2,3,4]Output: -1Explanation: No pair exists in nums with equal maximum digits.Constraints:2 &lt;= nums.length &lt;= 1001 &lt;= nums[i] &lt;= 10^4 | Class Solution {Public:    Int Maxsum(std::vector&lt;int&gt;&amp; Nums) {        Std::vector&lt;int&gt; Maxdigit(10, -1); // To Store The Maximum Number For Each Digit (0-9)        Int Maxsum = -1; // Initialize Maxsum To -1 As The Minimum Possible Answer                For (Int Num : Nums) {            Int Maxdig = 0; // To Store The Maximum Digit In The Current Number            Int Temp = Num; // Temporary Variable To Avoid Modifying Num                        While (Temp &gt; 0) {                Int Digit = Temp % 10;                Maxdig = Std::max(maxdig, Digit); // Update Maxdig If A Larger Digit Is Found                Temp /= 10;            }                        If (Maxdigit[maxdig] != -1) {                // If We Have Seen A Number With The Same Maximum Digit Before, Update Maxsum                Maxsum = Std::max(maxsum, Maxdigit[maxdig] + Num);            }                        // Update Maxdigit[maxdig] With The Maximum Of The Current Number And The Previous Maximum            Maxdigit[maxdig] = Std::max(maxdigit[maxdig], Num);        }                Return Maxsum;    }}; | Class Solution {    Public:        Int Maxsum(vector&lt;int&gt;&amp; Nums) {        Int Res = -1, Max_num[10] = {};        For (Auto Num : Nums) {            Int Max_d = 0;            For (Int V = Num; V; V /= 10)                Max_d = Max(max_d, V % 10);            If (Max_num[max_d])                Res = Max(res, Max_num[max_d] + Num);            Max_num[max_d] = Max(max_num[max_d], Num);        }        Return Res;    }}; 
 22 | 2 | Java | easy | ChatGPT | Chatbot | Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.Return the final string that will be present on your laptop screen.Example 1:Input: s = &quot;string&quot;Output: &quot;rtsng&quot;Explanation: After typing first character, the text on the screen is &quot;s&quot;.After the second character, the text is &quot;st&quot;. After the third character, the text is &quot;str&quot;.Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.After the fifth character, the text is &quot;rtsn&quot;. After the sixth character, the text is &quot;rtsng&quot;. Therefore, we return &quot;rtsng&quot;.Example 2:Input: s = &quot;poiinter&quot;Output: &quot;ponter&quot;Explanation: After the first character, the text on the screen is &quot;p&quot;.After the second character, the text is &quot;po&quot;. Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.After the fifth character, the text is &quot;pon&quot;.After the sixth character, the text is &quot;pont&quot;. After the seventh character, the text is &quot;ponte&quot;. After the eighth character, the text is &quot;ponter&quot;. Therefore, we return &quot;ponter&quot;. Constraints:1 &lt;= s.length &lt;= 100s consists of lowercase English letters.s[0] != &#39;i&#39; | Solve the following problem with java code. Class name: Solution, Method name: finalString(String s).Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.Return the final string that will be present on your laptop screen.Example 1:Input: s = &quot;string&quot;Output: &quot;rtsng&quot;Explanation: After typing first character, the text on the screen is &quot;s&quot;.After the second character, the text is &quot;st&quot;. After the third character, the text is &quot;str&quot;.Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.After the fifth character, the text is &quot;rtsn&quot;. After the sixth character, the text is &quot;rtsng&quot;. Therefore, we return &quot;rtsng&quot;.Example 2:Input: s = &quot;poiinter&quot;Output: &quot;ponter&quot;Explanation: After the first character, the text on the screen is &quot;p&quot;.After the second character, the text is &quot;po&quot;. Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.After the fifth character, the text is &quot;pon&quot;.After the sixth character, the text is &quot;pont&quot;. After the seventh character, the text is &quot;ponte&quot;. After the eighth character, the text is &quot;ponter&quot;. Therefore, we return &quot;ponter&quot;. Constraints:1 &lt;= s.length &lt;= 100s consists of lowercase English letters.s[0] != &#39;i&#39; | Public Class Solution {    Public String Finalstring(string S) {        Stringbuilder Result = New Stringbuilder();        Stringbuilder Reversebuffer = New Stringbuilder();                Boolean Reverse = False;                For (Char C : S.tochararray()) {            If (C == &#39;I&#39;) {                Reverse = !Reverse;            } Else {                If (Reverse) {                    Reversebuffer.insert(0, C);                } Else {                    Result.append(c);                }            }        }                Result.append(reversebuffer);                Return Result.tostring();    }    } | Class Solution {    Public String Finalstring(string S) {        Stringbuilder Nm=new Stringbuilder();        For(char C:s.tochararray())        {            If(c==&#39;i&#39;)            {                Nm.reverse();            }            Else            {                Nm.append(c);            }        }        Return Nm.tostring();    }} 
 23 | 2 | Python | easy | ChatGPT | Chatbot | Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.Return the final string that will be present on your laptop screen.Example 1:Input: s = &quot;string&quot;Output: &quot;rtsng&quot;Explanation: After typing first character, the text on the screen is &quot;s&quot;.After the second character, the text is &quot;st&quot;. After the third character, the text is &quot;str&quot;.Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.After the fifth character, the text is &quot;rtsn&quot;. After the sixth character, the text is &quot;rtsng&quot;. Therefore, we return &quot;rtsng&quot;.Example 2:Input: s = &quot;poiinter&quot;Output: &quot;ponter&quot;Explanation: After the first character, the text on the screen is &quot;p&quot;.After the second character, the text is &quot;po&quot;. Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.After the fifth character, the text is &quot;pon&quot;.After the sixth character, the text is &quot;pont&quot;. After the seventh character, the text is &quot;ponte&quot;. After the eighth character, the text is &quot;ponter&quot;. Therefore, we return &quot;ponter&quot;. Constraints:1 &lt;= s.length &lt;= 100s consists of lowercase English letters.s[0] != &#39;i&#39; | Solve the following problem with python3 code. Class name: Solution, Method name: def finalString(self, s: str) -&gt; str:.Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.Return the final string that will be present on your laptop screen.Example 1:Input: s = &quot;string&quot;Output: &quot;rtsng&quot;Explanation: After typing first character, the text on the screen is &quot;s&quot;.After the second character, the text is &quot;st&quot;. After the third character, the text is &quot;str&quot;.Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.After the fifth character, the text is &quot;rtsn&quot;. After the sixth character, the text is &quot;rtsng&quot;. Therefore, we return &quot;rtsng&quot;.Example 2:Input: s = &quot;poiinter&quot;Output: &quot;ponter&quot;Explanation: After the first character, the text on the screen is &quot;p&quot;.After the second character, the text is &quot;po&quot;. Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.After the fifth character, the text is &quot;pon&quot;.After the sixth character, the text is &quot;pont&quot;. After the seventh character, the text is &quot;ponte&quot;. After the eighth character, the text is &quot;ponter&quot;. Therefore, we return &quot;ponter&quot;. Constraints:1 &lt;= s.length &lt;= 100s consists of lowercase English letters.s[0] != &#39;i&#39; | Class Solution:    Def Finalstring(self, S: Str) -&gt; Str:        Stack = []  # Use A Stack To Simulate Typing Process                For Char In S:            If Char == &#39;I&#39;:                # If The Character Is &#39;I&#39;, Reverse The Stack                Stack.reverse()            Else:                Stack.append(char)                # Convert The Stack To A String And Return        Return &#39;&#39;.Join(stack) | Class Solution:    Def Finalstring(self, S: Str) -&gt; Str:        While &quot;I&quot; In S:            Index=s.index(&quot;i&quot;)            #First Half And Second Half            First=s[:index][::-1]            Second=s[index+1:]            S=&quot;&quot;.join([first,second])        Return S 
 24 | 2 | C++ | easy | ChatGPT | Chatbot | Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.Return the final string that will be present on your laptop screen.Example 1:Input: s = &quot;string&quot;Output: &quot;rtsng&quot;Explanation: After typing first character, the text on the screen is &quot;s&quot;.After the second character, the text is &quot;st&quot;. After the third character, the text is &quot;str&quot;.Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.After the fifth character, the text is &quot;rtsn&quot;. After the sixth character, the text is &quot;rtsng&quot;. Therefore, we return &quot;rtsng&quot;.Example 2:Input: s = &quot;poiinter&quot;Output: &quot;ponter&quot;Explanation: After the first character, the text on the screen is &quot;p&quot;.After the second character, the text is &quot;po&quot;. Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.After the fifth character, the text is &quot;pon&quot;.After the sixth character, the text is &quot;pont&quot;. After the seventh character, the text is &quot;ponte&quot;. After the eighth character, the text is &quot;ponter&quot;. Therefore, we return &quot;ponter&quot;. Constraints:1 &lt;= s.length &lt;= 100s consists of lowercase English letters.s[0] != &#39;i&#39; | Solve the following problem with C++ code. Class name: Solution, Method name: string finalString(string s).Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.Return the final string that will be present on your laptop screen.Example 1:Input: s = &quot;string&quot;Output: &quot;rtsng&quot;Explanation: After typing first character, the text on the screen is &quot;s&quot;.After the second character, the text is &quot;st&quot;. After the third character, the text is &quot;str&quot;.Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.After the fifth character, the text is &quot;rtsn&quot;. After the sixth character, the text is &quot;rtsng&quot;. Therefore, we return &quot;rtsng&quot;.Example 2:Input: s = &quot;poiinter&quot;Output: &quot;ponter&quot;Explanation: After the first character, the text on the screen is &quot;p&quot;.After the second character, the text is &quot;po&quot;. Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.After the fifth character, the text is &quot;pon&quot;.After the sixth character, the text is &quot;pont&quot;. After the seventh character, the text is &quot;ponte&quot;. After the eighth character, the text is &quot;ponter&quot;. Therefore, we return &quot;ponter&quot;. Constraints:1 &lt;= s.length &lt;= 100s consists of lowercase English letters.s[0] != &#39;i&#39; | Class Solution {Public:    Std::string Finalstring(std::string S) {        Std::string Result = &quot;&quot;; // Initialize The Result String                For (Char C : S) {            If (C == &#39;I&#39;) {                // If The Character Is &#39;I&#39;, Reverse The Result String                Std::reverse(result.begin(), Result.end());            } Else {                // Otherwise, Append The Character To The Result String                Result += C;            }        }                Return Result;    }}; | Class Solution {Public:    String Finalstring(const String &amp;S) {        String A, B;        For (Char Ch : S)            If (Ch == &#39;I&#39;)                Swap(a, B);            Else                A += Ch;        Return String(rbegin(b), Rend(b)) + A;    }}; 
 25 | 3 | Java | medium | ChatGPT | Chatbot | You are given a 0-indexed integer array nums and an integer x.Find the minimum absolute difference between two elements in the array that are at least x indices apart.In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.Example 1:Input: nums = [4,3,2,4], x = 2Output: 0Explanation: We can select nums[0] = 4 and nums[3] = 4. They are at least 2 indices apart, and their absolute difference is the minimum, 0. It can be shown that 0 is the optimal answer.Example 2:Input: nums = [5,3,2,10,15], x = 1Output: 1Explanation: We can select nums[1] = 3 and nums[2] = 2.They are at least 1 index apart, and their absolute difference is the minimum, 1.It can be shown that 1 is the optimal answer.Example 3:Input: nums = [1,2,3,4], x = 3Output: 3Explanation: We can select nums[0] = 1 and nums[3] = 4.They are at least 3 indices apart, and their absolute difference is the minimum, 3.It can be shown that 3 is the optimal answer. Constraints:1 &lt;= nums.length &lt;= 10^51 &lt;= nums[i] &lt;= 10^90 &lt;= x &lt; nums.length  | Solve the following problem with java code. Class name: Solution, Method name: minAbsoluteDifference(List&lt;Integer&gt; nums, int x).You are given a 0-indexed integer array nums and an integer x.Find the minimum absolute difference between two elements in the array that are at least x indices apart.In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.Example 1:Input: nums = [4,3,2,4], x = 2Output: 0Explanation: We can select nums[0] = 4 and nums[3] = 4. They are at least 2 indices apart, and their absolute difference is the minimum, 0. It can be shown that 0 is the optimal answer.Example 2:Input: nums = [5,3,2,10,15], x = 1Output: 1Explanation: We can select nums[1] = 3 and nums[2] = 2.They are at least 1 index apart, and their absolute difference is the minimum, 1.It can be shown that 1 is the optimal answer.Example 3:Input: nums = [1,2,3,4], x = 3Output: 3Explanation: We can select nums[0] = 1 and nums[3] = 4.They are at least 3 indices apart, and their absolute difference is the minimum, 3.It can be shown that 3 is the optimal answer. Constraints:1 &lt;= nums.length &lt;= 10^51 &lt;= nums[i] &lt;= 10^90 &lt;= x &lt; nums.length | Public Class Solution {    Public Int Minabsolutedifference(list&lt;integer&gt; Nums, Int X) {        Int N = Nums.size();        Int Minabsdiff = Integer.max_value;                // Create A Treemap To Store The Indices Of Elements        Treemap&lt;integer, Integer&gt; Indexmap = New Treemap&lt;&gt;();                For (Int I = 0; I &lt; N; I++) {            Int Num = Nums.get(i);                        // Check If There Exists A Number In The Treemap With A Difference Of At Least X            // From The Current Number, And Update The Minimum Absolute Difference Accordingly.            Integer Floorkey = Indexmap.floorkey(num - X);            If (Floorkey != Null) {                Int Index = Indexmap.get(floorkey);                Minabsdiff = Math.min(minabsdiff, Math.abs(num - Nums.get(index)));            }                        // Check If There Exists A Number In The Treemap With A Difference Of At Least X            // From The Current Number, And Update The Minimum Absolute Difference Accordingly.            Integer Ceilingkey = Indexmap.ceilingkey(num + X);            If (Ceilingkey != Null) {                Int Index = Indexmap.get(ceilingkey);                Minabsdiff = Math.min(minabsdiff, Math.abs(num - Nums.get(index)));            }                        // Update The Index Of The Current Number In The Treemap.            Indexmap.put(num, I);        }                Return Minabsdiff;    }   } | Class Solution {    Int Minabsolutedifference(list&lt;integer&gt; Nums, Int X) {        Int Ans = Integer.max_value;        Treeset&lt;integer&gt; S = New Treeset&lt;&gt;();        For(int I = X; I &lt; Nums.size(); ++I){            S.add(nums.get(i-x));            Integer High = S.ceiling(nums.get(i)), Low = S.floor(nums.get(i));            If(high != Null) Ans = Math.min(ans, Math.abs(nums.get(i) - High));            If(low != Null) Ans = Math.min(ans, Math.abs(nums.get(i) - Low));        }        Return Ans;    }} 
 26 | 3 | Python | medium | ChatGPT | Chatbot | You are given a 0-indexed integer array nums and an integer x.Find the minimum absolute difference between two elements in the array that are at least x indices apart.In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.Example 1:Input: nums = [4,3,2,4], x = 2Output: 0Explanation: We can select nums[0] = 4 and nums[3] = 4. They are at least 2 indices apart, and their absolute difference is the minimum, 0. It can be shown that 0 is the optimal answer.Example 2:Input: nums = [5,3,2,10,15], x = 1Output: 1Explanation: We can select nums[1] = 3 and nums[2] = 2.They are at least 1 index apart, and their absolute difference is the minimum, 1.It can be shown that 1 is the optimal answer.Example 3:Input: nums = [1,2,3,4], x = 3Output: 3Explanation: We can select nums[0] = 1 and nums[3] = 4.They are at least 3 indices apart, and their absolute difference is the minimum, 3.It can be shown that 3 is the optimal answer. Constraints:1 &lt;= nums.length &lt;= 10^51 &lt;= nums[i] &lt;= 10^90 &lt;= x &lt; nums.length  | Solve the following problem with python3 code. Class name: Solution, Method name: def minAbsoluteDifference(self, nums: List[int], x: int) -&gt; int:.You are given a 0-indexed integer array nums and an integer x.Find the minimum absolute difference between two elements in the array that are at least x indices apart.In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.Example 1:Input: nums = [4,3,2,4], x = 2Output: 0Explanation: We can select nums[0] = 4 and nums[3] = 4. They are at least 2 indices apart, and their absolute difference is the minimum, 0. It can be shown that 0 is the optimal answer.Example 2:Input: nums = [5,3,2,10,15], x = 1Output: 1Explanation: We can select nums[1] = 3 and nums[2] = 2.They are at least 1 index apart, and their absolute difference is the minimum, 1.It can be shown that 1 is the optimal answer.Example 3:Input: nums = [1,2,3,4], x = 3Output: 3Explanation: We can select nums[0] = 1 and nums[3] = 4.They are at least 3 indices apart, and their absolute difference is the minimum, 3.It can be shown that 3 is the optimal answer. Constraints:1 &lt;= nums.length &lt;= 10^51 &lt;= nums[i] &lt;= 10^90 &lt;= x &lt; nums.length | Class Solution:    Def Minabsolutedifference(self, Nums: List[int], X: Int) -&gt; Int:        Nums.sort()  # Sort The Input Array                Min_diff = Float(&#39;inf&#39;)  # Initialize The Minimum Difference To Positive Infinity                Left = 0  # Initialize The Left Pointer        Right = X  # Initialize The Right Pointer                While Right &lt; Len(nums):            Min_diff = Min(min_diff, Nums[right] - Nums[left])  # Update The Minimum Difference                        Left += 1  # Move The Left Pointer            Right += 1  # Move The Right Pointer                Return Min_diff | Class Solution:  Def Minabsolutedifference(self, Nums: List[int], X: Int) -&gt; Int:    If X == 0:      Return 0    Arr, Best_dist = Sortedlist([]), Float(&#39;inf&#39;)    For I In Range(x, Len(nums)):      Arr.add(nums[i - X])      V = Nums[i]      Pos = Arr.bisect_left(v)      If Pos &lt; Len(arr):        Best_dist = Min(best_dist, Abs(arr[pos] - V))      If Pos &gt; 0:        Best_dist = Min(best_dist, Abs(arr[pos - 1] - V))        Return Best_dist 
 27 | 3 | C++ | medium | ChatGPT | Chatbot | You are given a 0-indexed integer array nums and an integer x.Find the minimum absolute difference between two elements in the array that are at least x indices apart.In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.Example 1:Input: nums = [4,3,2,4], x = 2Output: 0Explanation: We can select nums[0] = 4 and nums[3] = 4. They are at least 2 indices apart, and their absolute difference is the minimum, 0. It can be shown that 0 is the optimal answer.Example 2:Input: nums = [5,3,2,10,15], x = 1Output: 1Explanation: We can select nums[1] = 3 and nums[2] = 2.They are at least 1 index apart, and their absolute difference is the minimum, 1.It can be shown that 1 is the optimal answer.Example 3:Input: nums = [1,2,3,4], x = 3Output: 3Explanation: We can select nums[0] = 1 and nums[3] = 4.They are at least 3 indices apart, and their absolute difference is the minimum, 3.It can be shown that 3 is the optimal answer. Constraints:1 &lt;= nums.length &lt;= 10^51 &lt;= nums[i] &lt;= 10^90 &lt;= x &lt; nums.length  | Solve the following problem with C++ code. Class name: Solution, Method name: int minAbsoluteDifference(vector&lt;int&gt;&amp; nums, int x).You are given a 0-indexed integer array nums and an integer x.Find the minimum absolute difference between two elements in the array that are at least x indices apart.In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.Example 1:Input: nums = [4,3,2,4], x = 2Output: 0Explanation: We can select nums[0] = 4 and nums[3] = 4. They are at least 2 indices apart, and their absolute difference is the minimum, 0. It can be shown that 0 is the optimal answer.Example 2:Input: nums = [5,3,2,10,15], x = 1Output: 1Explanation: We can select nums[1] = 3 and nums[2] = 2.They are at least 1 index apart, and their absolute difference is the minimum, 1.It can be shown that 1 is the optimal answer.Example 3:Input: nums = [1,2,3,4], x = 3Output: 3Explanation: We can select nums[0] = 1 and nums[3] = 4.They are at least 3 indices apart, and their absolute difference is the minimum, 3.It can be shown that 3 is the optimal answer. Constraints:1 &lt;= nums.length &lt;= 10^51 &lt;= nums[i] &lt;= 10^90 &lt;= x &lt; nums.length | Class Solution {Public:    Int Minabsolutedifference(std::vector&lt;int&gt;&amp; Nums, Int X) {        Int N = Nums.size();        Std::vector&lt;std::pair&lt;int, Int&gt;&gt; Indexednums; // Store The Numbers Along With Their Indices                // Create A Vector Of Pairs (Number, Index)        For (Int I = 0; I &lt; N; ++I) {            Indexednums.push_back({nums[i], I});        }                // Sort The Vector Based On Numbers        Std::sort(indexednums.begin(), Indexednums.end());                Int Mindiff = Int_max; // Initialize The Minimum Difference To A Large Value                // Traverse The Sorted Vector And Find The Minimum Absolute Difference        For (Int I = 0; I &lt; N; ++I) {            // Find The Index Of The Element That Is At Least X Indices Apart            Int J = I + X;            If (J &lt; N) {                Int Diff = Abs(indexednums[i].first - Indexednums[j].first);                Mindiff = Std::min(mindiff, Diff);            }        }                Return Mindiff;    }}; | Class Solution {Public:    Int Minabsolutedifference(vector&lt;int&gt;&amp; Nums, Int X) {        Int Ans = Int_max;        Set&lt;int&gt; S;        For(int I = X; I &lt; Nums.size(); ++I){            S.insert(nums[i-x]);            Auto It = S.upper_bound(nums[i]);            If(it != S.end()) Ans = Min(ans, Abs(nums[i] - *It));            If(it != S.begin()) Ans = Min(ans, Abs(nums[i] - *Prev(it)));        }        Return Ans;    }}; 
 28 | 4 | Java | medium | ChatGPT | Chatbot | You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.Return the head of the linked list after doubling it.Example 1:Input: head = [1,8,9]Output: [3,7,8]Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.Example 2:Input: head = [9,9,9]Output: [1,9,9,8]Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. Constraints:The number of nodes in the list is in the range [1, 10^4]0 &lt;= Node.val &lt;= 9The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.  | Solve the following problem with java code. Class name: Solution, Method name: doubleIt(ListNode head).You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.Return the head of the linked list after doubling it.Example 1:Input: head = [1,8,9]Output: [3,7,8]Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.Example 2:Input: head = [9,9,9]Output: [1,9,9,8]Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. Constraints:The number of nodes in the list is in the range [1, 10^4]0 &lt;= Node.val &lt;= 9The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself. | Public Class Solution {    Public Listnode Doubleit(listnode Head) {        If (Head == Null) {            Return Null;        }        Int Carry = 0;        Listnode Current = Head;        Listnode Prev = Null;        // Traverse The List In Reverse Order And Double The Values        While (Current != Null) {            Int Newval = Current.val * 2 + Carry;            Carry = Newval / 10;            Current.val = Newval % 10;            Prev = Current;            Current = Current.next;        }        // If There&#39;s A Remaining Carry, Add A New Node For It        If (Carry &gt; 0) {            Listnode Newnode = New Listnode(carry);            Prev.next = Newnode;        }        Return Reverselist(head);    }    Public Listnode Reverselist(listnode Head) {        Listnode Prev = Null;        Listnode Current = Head;        While (Current != Null) {            Listnode Nextnode = Current.next;            Current.next = Prev;            Prev = Current;            Current = Nextnode;        }        Return Prev;    }} | Class Solution {    Public Listnode Doubleit(listnode Head) {        If (Head.val &gt; 4)            Head = New Listnode(0, Head);        For(listnode Node = Head; Node != Null; Node = Node.next) {            Node.val = (Node.val * 2) % 10;            If (Node.next != Null &amp;&amp; Node.next.val &gt; 4)                Node.val++;        }        Return Head;    }} 
 29 | 4 | Python | medium | ChatGPT | Chatbot | You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.Return the head of the linked list after doubling it.Example 1:Input: head = [1,8,9]Output: [3,7,8]Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.Example 2:Input: head = [9,9,9]Output: [1,9,9,8]Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. Constraints:The number of nodes in the list is in the range [1, 10^4]0 &lt;= Node.val &lt;= 9The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.  | Solve the following problem with python3 code. Class name: Solution, Method name: def doubleIt(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:.You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.Return the head of the linked list after doubling it.Example 1:Input: head = [1,8,9]Output: [3,7,8]Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.Example 2:Input: head = [9,9,9]Output: [1,9,9,8]Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. Constraints:The number of nodes in the list is in the range [1, 10^4]0 &lt;= Node.val &lt;= 9The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself. | Class Solution:    Def Doubleit(self, Head: Optional[listnode]) -&gt; Optional[listnode]:        If Not Head:            Return None                Carry = 0        Current = Head        Prev = None                # Traverse The List In Reverse Order And Double The Values        While Current:            Newval = Current.val * 2 + Carry            Carry = Newval // 10            Current.val = Newval % 10                        Prev = Current            Current = Current.next                # If There&#39;s A Remaining Carry, Add A New Node For It        If Carry &gt; 0:            Newnode = Listnode(carry)            Prev.next = Newnode                Return Self.reverselist(head)        Def Reverselist(self, Head: Optional[listnode]) -&gt; Optional[listnode]:        Prev = None        Current = Head                While Current:            Nextnode = Current.next            Current.next = Prev            Prev = Current            Current = Nextnode                Return Prev | Class Solution:    Def Doubleit(self, Head: Optional[listnode]) -&gt; Optional[listnode]:        If Head.val &gt; 4:            Head = Listnode(0, Head)        Node = Head        While Node:            Node.val = (Node.val * 2) % 10            If Node.next And Node.next.val &gt; 4:                Node.val += 1            Node = Node.next        Return Head 
 30 | 4 | C++ | medium | ChatGPT | Chatbot | You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.Return the head of the linked list after doubling it.Example 1:Input: head = [1,8,9]Output: [3,7,8]Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.Example 2:Input: head = [9,9,9]Output: [1,9,9,8]Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. Constraints:The number of nodes in the list is in the range [1, 10^4]0 &lt;= Node.val &lt;= 9The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.  | Solve the following problem with C++ code. Class name: Solution, Method name: ListNode* doubleIt(ListNode* head).You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.Return the head of the linked list after doubling it.Example 1:Input: head = [1,8,9]Output: [3,7,8]Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.Example 2:Input: head = [9,9,9]Output: [1,9,9,8]Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. Constraints:The number of nodes in the list is in the range [1, 10^4]0 &lt;= Node.val &lt;= 9The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself. | Class Solution {Public:    Listnode* Doubleit(listnode* Head) {        If (!Head) {            Return Nullptr;        }        Int Carry = 0;        Listnode* Current = Head;        Listnode* Prev = Nullptr;        // Traverse The List In Reverse Order And Double The Values        While (Current) {            Int Newval = Current-&gt;val * 2 + Carry;            Carry = Newval / 10;            Current-&gt;val = Newval % 10;            Prev = Current;            Current = Current-&gt;next;        }        // If There&#39;s A Remaining Carry, Add A New Node For It        If (Carry &gt; 0) {            Listnode* Newnode = New Listnode(carry);            Prev-&gt;next = Newnode;        }        Return Reverselist(head);    }    Listnode* Reverselist(listnode* Head) {        Listnode* Prev = Nullptr;        Listnode* Current = Head;        While (Current) {            Listnode* Nextnode = Current-&gt;next;            Current-&gt;next = Prev;            Prev = Current;            Current = Nextnode;        }        Return Prev;    }}; | Class Solution {Public:    Listnode* Doubleit(listnode* Head) {        If (Head-&gt;val &gt; 4)            Head = New Listnode(0, Head);        For(listnode* Node = Head; Node; Node = Node-&gt;next) {            Node-&gt;val = (Node-&gt;val * 2) % 10;            If (Node-&gt;next &amp;&amp; Node-&gt;next-&gt;val &gt; 4)                Node-&gt;val++;        }        Return Head;    }}; 
 31 | 5 | Java | hard | ChatGPT | Chatbot | You are given an array nums of n positive integers and an integer k.Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.Multiply your score by x.Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.Return the maximum possible score after applying at most k operations.Since the answer may be large, return it modulo 10^9 + 7.Example 1:Input: nums = [8,3,9,3,8], k = 2Output: 81Explanation: To get a score of 81, we can apply the following operations:- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.It can be proven that 81 is the highest score one can obtain.Example 2:Input: nums = [19,12,14,6,10,18], k = 3Output: 4788Explanation: To get a score of 4788, we can apply the following operations: - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.It can be proven that 4788 is the highest score one can obtain. Constraints:1 &lt;= nums.length == n &lt;= 10^51 &lt;= nums[i] &lt;= 10^51 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9)  | Solve the following problem with java code. Class name: Solution, Method name: maximumScore(List&lt;Integer&gt; nums, int k).You are given an array nums of n positive integers and an integer k.Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.Multiply your score by x.Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.Return the maximum possible score after applying at most k operations.Since the answer may be large, return it modulo 10^9 + 7.Example 1:Input: nums = [8,3,9,3,8], k = 2Output: 81Explanation: To get a score of 81, we can apply the following operations:- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.It can be proven that 81 is the highest score one can obtain.Example 2:Input: nums = [19,12,14,6,10,18], k = 3Output: 4788Explanation: To get a score of 4788, we can apply the following operations: - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.It can be proven that 4788 is the highest score one can obtain. Constraints:1 &lt;= nums.length == n &lt;= 10^51 &lt;= nums[i] &lt;= 10^51 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9). | Public Class Solution {    Public Int Maximumscore(list&lt;integer&gt; Nums, Int K) {        Int Mod = 1000000007;        Int N = Nums.size();                // Create An Array To Store The Prime Scores For Each Element.        Int[] Primescores = New Int[n];                // Calculate The Prime Scores For Each Element Using A Helper Function.        For (Int I = 0; I &lt; N; I++) {            Primescores[i] = Calculateprimescore(nums.get(i));        }                Long Score = 1l; // Initialize The Score As A Long Integer To Avoid Overflow.                // Create A Max Heap To Keep Track Of The Elements With The Highest Prime Scores.        Priorityqueue&lt;integer&gt; Maxheap = New Priorityqueue&lt;&gt;((a, B) -&gt; Integer.compare(primescores[b], Primescores[a]));                // Initialize The Max Heap With The Element At Index K.        Maxheap.offer(k);                // Create Two Arrays To Keep Track Of The Left And Right Boundaries Of The Subarray.        Int[] Left = New Int[n];        Int[] Right = New Int[n];                // Initialize The Left And Right Boundaries.        Left[k] = K;        Right[k] = K;                // Perform At Most K Operations.        For (Int I = 0; I &lt; K; I++) {            Int Maxindex = Maxheap.poll(); // Get The Index With The Highest Prime Score.                        // Calculate The New Score By Multiplying The Current Score By The Selected Element.            Score = (Score * Nums.get(maxindex)) % Mod;                        // Update The Left And Right Boundaries For The Subarray.            Int Newleft = Left[maxindex] - 1;            Int Newright = Right[maxindex] + 1;                        // Add The New Potential Candidates To The Max Heap.            If (Newleft &gt;= 0) {                Maxheap.offer(newleft);                Left[newleft] = Newleft;                Right[newleft] = Right[maxindex];            }            If (Newright &lt; N) {                Maxheap.offer(newright);                Left[newright] = Left[maxindex];                Right[newright] = Newright;            }        }                Return (Int)score;    }        // Helper Function To Calculate The Prime Score Of An Integer.    Private Int Calculateprimescore(int Num) {        Set&lt;integer&gt; Factors = New Hashset&lt;&gt;();                // Find Prime Factors Of The Number.        While (Num % 2 == 0) {            Factors.add(2);            Num /= 2;        }                For (Int I = 3; I &lt;= Math.sqrt(num); I += 2) {            While (Num % I == 0) {                Factors.add(i);                Num /= I;            }        }                If (Num &gt; 2) {            Factors.add(num);        }                Return Factors.size();    }} | Class Solution {    Static Final Int Mod = 1000000007;    Public Int Maximumscore(list&lt;integer&gt; Nums, Int K) {        Int N = Nums.size();        Int Upper = Collections.max(nums) + 1;        Boolean[] Prime = New Boolean[upper];        Int[] Primescore = New Int[upper];        Arrays.fill(prime, True);        Prime[0] = Prime[1] = False;        For (Int I = 2; I &lt; Upper; I++) {            If (Prime[i]) {                For (Int J = I; J &lt; Upper; J += I) {                    Primescore[j]++;                    Prime[j] = False;                }            }        }        Int[] Nextgreaterelement = New Int[n];        Arrays.fill(nextgreaterelement, N);        Stack&lt;integer&gt; S = New Stack&lt;&gt;();        For (Int I = N - 1; I &gt;= 0; I--) {            While (!S.empty() &amp;&amp; Primescore[nums.get(i)] &gt;= Primescore[nums.get(s.peek())]) {                S.pop();            }            Nextgreaterelement[i] = S.empty() ? N : S.peek();            S.push(i);        }        Int[] Prevgreaterorequalelement = New Int[n];        Arrays.fill(prevgreaterorequalelement, -1);        S = New Stack&lt;&gt;();        For (Int I = 0; I &lt; N; I++) {            While (!S.empty() &amp;&amp; Primescore[nums.get(i)] &gt; Primescore[nums.get(s.peek())]) {                S.pop();            }            Prevgreaterorequalelement[i] = S.empty() ? -1 : S.peek();            S.push(i);        }        Int Res = 1;        Int[][] Tuples = New Int[n][2];        For (Int I = 0; I &lt; N; I++) {            Tuples[i][0] = Nums.get(i);            Tuples[i][1] = I;        }        Arrays.sort(tuples, New Comparator&lt;int[]&gt;() {            Public Int Compare(int[] A, Int[] B) {                Return B[0] - A[0];            }        });        For (Int I = 0; I &lt; N; I++) {            Int Num = Tuples[i][0];            Int Idx = Tuples[i][1];            Int Operations = Math.min((idx - Prevgreaterorequalelement[idx]) * (Nextgreaterelement[idx] - Idx), K);            Res = (Int)((1l * Res * Pow(num, Operations)) % Mod);            K -= Operations;            If (K == 0) {                Return Res;            }        }        Return Res;    }    Public Int Pow(int X, Int N) {        Int Res = 1;        While (N &gt; 0) {            If (N % 2 == 1) {                Res = (Int)((1l * Res * X) % Mod);            }            X = (Int)((1l * X * X) % Mod);            N /= 2;        }        Return Res;    }} 
 32 | 5 | Python | hard | ChatGPT | Chatbot | You are given an array nums of n positive integers and an integer k.Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.Multiply your score by x.Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.Return the maximum possible score after applying at most k operations.Since the answer may be large, return it modulo 10^9 + 7.Example 1:Input: nums = [8,3,9,3,8], k = 2Output: 81Explanation: To get a score of 81, we can apply the following operations:- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.It can be proven that 81 is the highest score one can obtain.Example 2:Input: nums = [19,12,14,6,10,18], k = 3Output: 4788Explanation: To get a score of 4788, we can apply the following operations: - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.It can be proven that 4788 is the highest score one can obtain. Constraints:1 &lt;= nums.length == n &lt;= 10^51 &lt;= nums[i] &lt;= 10^51 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9)  | Solve the following problem with python3 code. Class name: Solution, Method name: def maximumScore(self, nums: List[int], k: int) -&gt; int:.You are given an array nums of n positive integers and an integer k.Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.Multiply your score by x.Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.Return the maximum possible score after applying at most k operations.Since the answer may be large, return it modulo 10^9 + 7.Example 1:Input: nums = [8,3,9,3,8], k = 2Output: 81Explanation: To get a score of 81, we can apply the following operations:- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.It can be proven that 81 is the highest score one can obtain.Example 2:Input: nums = [19,12,14,6,10,18], k = 3Output: 4788Explanation: To get a score of 4788, we can apply the following operations: - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.It can be proven that 4788 is the highest score one can obtain. Constraints:1 &lt;= nums.length == n &lt;= 10^51 &lt;= nums[i] &lt;= 10^51 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9). | Class Solution:    Def Maximumscore(self, Nums: List[int], K: Int) -&gt; Int:        Def Prime_score(x):            Factors = Set()            While X % 2 == 0:                Factors.add(2)                X //= 2            For I In Range(3, Int(x ** 0.5) + 1, 2):                While X % I == 0:                    Factors.add(i)                    X //= I            If X &gt; 2:                Factors.add(x)            Return Len(factors)                Max_score = 1        Mod = 10 ** 9 + 7                Pq = []  # Priority Queue To Store Elements By Their Prime Scores                For Num In Nums:            Heapq.heappush(pq, (-Prime_score(num), Num))  # Use A Negative Score To Get The Maximum Prime Score First                While K &gt; 0:            Prime_score, Num = Heapq.heappop(pq)  # Pop The Element With The Highest Prime Score            Max_score = (Max_score * Num) % Mod            K -= 1                Return Max_score | Class Solution:     Mod = 1000000007    Def Maximumscore(self, Nums: List[int], K: Int) -&gt; Int:        N = Len(nums)        Upper = Max(nums) + 1        Prime = [True]*upper        Prime[0] = Prime[1] = False        Primescore = [0]*upper        For I In Range(2, Upper):            If Prime[i]:                For J In Range(i, Upper, I):                    Primescore[j] += 1                    Prime[j] = False        Nextgreaterelement = [N]*n        S = []        For I In Range(n - 1, -1, -1):            While S And Primescore[nums[i]] &gt;= Primescore[nums[s[-1]]]:                S.pop()            Nextgreaterelement[i] = S[-1] If S Else N            S.append(i)        Prevgreaterorequalelement = [-1]*n        S = []        For I In Range(n):            While S And Primescore[nums[i]] &gt; Primescore[nums[s[-1]]]:                S.pop()            Prevgreaterorequalelement[i] = S[-1] If S Else -1            S.append(i)        Res = 1        Tuples = [[Nums[i], I] For I In Range(n)]        Tuples.sort(reverse=true)        For Num, Idx In Tuples:            Operations = Min((idx - Prevgreaterorequalelement[idx]) * (Nextgreaterelement[idx] - Idx), K)            Res = (Res * Self.pow(num, Operations)) % Self.mod            K -= Operations            If K == 0:                Return Res        Return Res    Def Pow(self, X: Int, N: Int) -&gt; Int:        Res = 1        While N &gt; 0:            If N % 2 == 1:                Res = (Res * X) % Self.mod            X = (X * X) % Self.mod            N //= 2        Return Res 
 33 | 5 | C++ | hard | ChatGPT | Chatbot | You are given an array nums of n positive integers and an integer k.Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.Multiply your score by x.Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.Return the maximum possible score after applying at most k operations.Since the answer may be large, return it modulo 10^9 + 7.Example 1:Input: nums = [8,3,9,3,8], k = 2Output: 81Explanation: To get a score of 81, we can apply the following operations:- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.It can be proven that 81 is the highest score one can obtain.Example 2:Input: nums = [19,12,14,6,10,18], k = 3Output: 4788Explanation: To get a score of 4788, we can apply the following operations: - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.It can be proven that 4788 is the highest score one can obtain. Constraints:1 &lt;= nums.length == n &lt;= 10^51 &lt;= nums[i] &lt;= 10^51 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9)  | Solve the following problem with C++ code. Class name: Solution, Method name: int maximumScore(vector&lt;int&gt;&amp; nums, int k).You are given an array nums of n positive integers and an integer k.Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.Multiply your score by x.Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.Return the maximum possible score after applying at most k operations.Since the answer may be large, return it modulo 10^9 + 7.Example 1:Input: nums = [8,3,9,3,8], k = 2Output: 81Explanation: To get a score of 81, we can apply the following operations:- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.It can be proven that 81 is the highest score one can obtain.Example 2:Input: nums = [19,12,14,6,10,18], k = 3Output: 4788Explanation: To get a score of 4788, we can apply the following operations: - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.It can be proven that 4788 is the highest score one can obtain. Constraints:1 &lt;= nums.length == n &lt;= 10^51 &lt;= nums[i] &lt;= 10^51 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9). | Class Solution {Public:    Const Int Mod = 1e9 + 7;    Int Maximumscore(std::vector&lt;int&gt;&amp; Nums, Int K) {        Int N = Nums.size();        Std::unordered_map&lt;int, Int&gt; Primescore; // Map To Store Prime Scores Of Elements        Int Left = 0; // Left Pointer Of The Sliding Window        Long Long Score = 1; // Initial Score        Int Maxscore = 1; // Maximum Score        For (Int Right = 0; Right &lt; N; ++Right) {            // Calculate Prime Score For The New Element            Int Curscore = Calculateprimescore(nums[right]);            // Update Prime Score Map            Primescore[nums[right]]++;            // Increment The Score By Multiplying It With The Prime Score            Score = (Score * Curscore) % Mod;            // Check If The Window Size Exceeds K, Then We Need To Shrink The Window            While (Right - Left + 1 &gt; K) {                Int Leftelem = Nums[left];                Primescore[leftelem]--;                // If The Left Element Has No More Occurrences In The Window, Remove It From The Map                If (Primescore[leftelem] == 0) {                    Primescore.erase(leftelem);                }                // Move The Left Pointer To The Right                Left++;            }            // Update The Maximum Score            Maxscore = Std::max(maxscore, Static_cast&lt;int&gt;(score));        }        Return Maxscore;    }    // Helper Function To Calculate The Prime Score Of An Integer    Int Calculateprimescore(int X) {        Int Score = 0;        For (Int I = 2; I * I &lt;= X; ++I) {            While (X % I == 0) {                X /= I;                Score++;            }        }        If (X &gt; 1) {            Score++;        }        Return Score;    }}; | Class Solution {Public:    Const Int Mod = 1000000007;    Int Maximumscore(vector&lt;int&gt;&amp; Nums, Int K) {        Int N = Nums.size();        Int Upper = *Max_element(nums.begin(), Nums.end()) + 1;        Vector&lt;bool&gt; Prime(upper, True);        Prime[0] = Prime[1] = False;        Vector&lt;int&gt; Primescore(upper, 0);        For (Int I = 2; I &lt; Upper; I++) {            If (Prime[i]) {                For (Int J = I; J &lt; Upper; J += I) {                    Primescore[j]++;                    Prime[j] = False;                }            }        }        Vector&lt;int&gt; Nextgreaterelement(n, N);        Stack&lt;int&gt; S;        For (Int I = N - 1; I &gt;= 0; I--) {            While (!S.empty() &amp;&amp; Primescore[nums[i]] &gt;= Primescore[nums[s.top()]]) {                S.pop();            }            Nextgreaterelement[i] = S.empty() ? N : S.top();            S.push(i);        }        Vector&lt;int&gt; Prevgreaterorequalelement(n, -1);        S = Stack&lt;int&gt;();        For (Int I = 0; I &lt; N; I++) {            While (!S.empty() &amp;&amp; Primescore[nums[i]] &gt; Primescore[nums[s.top()]]) {                S.pop();            }            Prevgreaterorequalelement[i] = S.empty() ? -1 : S.top();            S.push(i);        }        Int Res = 1;        Vector&lt;pair&lt;int, Int&gt;&gt; Tuples(n);        For (Int I = 0; I &lt; N; I++) {            Tuples[i].first = Nums[i];            Tuples[i].second = I;        }        Sort(tuples.rbegin(), Tuples.rend());        For (Const Auto&amp; [Num, I] : Tuples) {            Int Operations = Min((i - Prevgreaterorequalelement[i]) * (Nextgreaterelement[i] - I), K);            Res = (Int)((1l * Res * Pow(num, Operations)) % Mod);            K -= Operations;            If (K == 0) {                Return Res;            }        }        Return Res;    }    Int Pow(int X, Int N) {        Int Res = 1;        While (N &gt; 0) {            If (N % 2 == 1) {                Res = (Int)((1l * Res * X) % Mod);            }            X = (Int)((1l * X * X) % Mod);            N /= 2;        }        Return Res;    }}; 
 34 | 6 | Java | hard | ChatGPT | Chatbot | You are given a 0-indexed 2D integer array items of length n and an integer k.items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.Your task is to find the maximum elegance from all subsequences of size k in items.Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.Example 1:Input: items = [[3,2],[5,1],[10,1]], k = 2Output: 17Explanation: In this example, we have to select a subsequence of size 2.We can select items[0] = [3,2] and items[2] = [10,1].The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. Example 2:Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3Output: 19Explanation: In this example, we have to select a subsequence of size 3. We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.Example 3:Input: items = [[1,1],[2,1],[3,1]], k = 3Output: 7Explanation: In this example, we have to select a subsequence of size 3. We should select all the items. The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. Hence, the maximum elegance is 6 + 1^2 = 7.   Constraints:1 &lt;= items.length == n &lt;= 10^5items[i].length == 2items[i][0] == profit_iitems[i][1] == category_i1 &lt;= profit_i &lt;= 10^91 &lt;= category_i &lt;= n 1 &lt;= k &lt;= n  | Solve the following problem with java code. Class name: Solution, Method name: findMaximumElegance(int [][] items, int k).You are given a 0-indexed 2D integer array items of length n and an integer k.items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.Your task is to find the maximum elegance from all subsequences of size k in items.Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.Example 1:Input: items = [[3,2],[5,1],[10,1]], k = 2Output: 17Explanation: In this example, we have to select a subsequence of size 2.We can select items[0] = [3,2] and items[2] = [10,1].The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. Example 2:Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3Output: 19Explanation: In this example, we have to select a subsequence of size 3. We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.Example 3:Input: items = [[1,1],[2,1],[3,1]], k = 3Output: 7Explanation: In this example, we have to select a subsequence of size 3. We should select all the items. The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. Hence, the maximum elegance is 6 + 1^2 = 7.   Constraints:1 &lt;= items.length == n &lt;= 10^5items[i].length == 2items[i][0] == profit_iitems[i][1] == category_i1 &lt;= profit_i &lt;= 10^91 &lt;= category_i &lt;= n 1 &lt;= k &lt;= n | Public Class Solution {    Public Int Findmaximumelegance(int[][] Items, Int K) {        List&lt;int[]&gt; Itemlist = New Arraylist&lt;&gt;();        Map&lt;integer, Integer&gt; Categoryfreq = New Hashmap&lt;&gt;();        Int Totalprofit = 0;        Int Distinctcategories = 0;        Int Maxelegance = 0;        For (Int[] Item : Items) {            Itemlist.add(item);        }        Collections.sort(itemlist, (A, B) -&gt; B[0] - A[0]); // Sort By Profit In Descending Order        For (Int I = 0; I &lt; Itemlist.size(); I++) {            Int[] Item = Itemlist.get(i);            Int Profit = Item[0];            Int Category = Item[1];            Categoryfreq.put(category, Categoryfreq.getordefault(category, 0) + 1);            Totalprofit += Profit;            If (Categoryfreq.get(category) == 1) {                Distinctcategories++;            }            Int Elegance = Totalprofit + Distinctcategories * Distinctcategories;            Maxelegance = Math.max(maxelegance, Elegance);            If (Distinctcategories == K) {                Break; // We Have Reached The Required Number Of Distinct Categories            }        }        Return Maxelegance;    }} | Class Solution {    Public Long Findmaximumelegance(int[][] A, Int K) {        Arrays.sort(a, (A, B) -&gt; B[0] - A[0]);        Long Res = 0, Cur = 0;        List&lt;integer&gt; Dup = New Arraylist&lt;&gt;();        Set&lt;integer&gt; Seen = New Hashset&lt;&gt;();        For (Int I = 0; I &lt; A.length; ++I) {            If (I &lt; K) {                If (Seen.contains(a[i][1])) {                    Dup.add(a[i][0]);                }                Cur += A[i][0];            } Else If (!Seen.contains(a[i][1])) {                If (Dup.isempty()) Break;                Cur += A[i][0] - Dup.remove(dup.size() - 1);            }            Seen.add(a[i][1]);            Res = Math.max(res, Cur + 1l * Seen.size() * Seen.size());        }        Return Res;    }} 
 35 | 6 | Python | hard | ChatGPT | Chatbot | You are given a 0-indexed 2D integer array items of length n and an integer k.items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.Your task is to find the maximum elegance from all subsequences of size k in items.Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.Example 1:Input: items = [[3,2],[5,1],[10,1]], k = 2Output: 17Explanation: In this example, we have to select a subsequence of size 2.We can select items[0] = [3,2] and items[2] = [10,1].The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. Example 2:Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3Output: 19Explanation: In this example, we have to select a subsequence of size 3. We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.Example 3:Input: items = [[1,1],[2,1],[3,1]], k = 3Output: 7Explanation: In this example, we have to select a subsequence of size 3. We should select all the items. The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. Hence, the maximum elegance is 6 + 1^2 = 7.   Constraints:1 &lt;= items.length == n &lt;= 10^5items[i].length == 2items[i][0] == profit_iitems[i][1] == category_i1 &lt;= profit_i &lt;= 10^91 &lt;= category_i &lt;= n 1 &lt;= k &lt;= n  | Solve the following problem with python3 code. Class name: Solution, Method name: def findMaximumElegance(self, items: List[List[int]], k: int) -&gt; int:.You are given a 0-indexed 2D integer array items of length n and an integer k.items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.Your task is to find the maximum elegance from all subsequences of size k in items.Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.Example 1:Input: items = [[3,2],[5,1],[10,1]], k = 2Output: 17Explanation: In this example, we have to select a subsequence of size 2.We can select items[0] = [3,2] and items[2] = [10,1].The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. Example 2:Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3Output: 19Explanation: In this example, we have to select a subsequence of size 3. We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.Example 3:Input: items = [[1,1],[2,1],[3,1]], k = 3Output: 7Explanation: In this example, we have to select a subsequence of size 3. We should select all the items. The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. Hence, the maximum elegance is 6 + 1^2 = 7.   Constraints:1 &lt;= items.length == n &lt;= 10^5items[i].length == 2items[i][0] == profit_iitems[i][1] == category_i1 &lt;= profit_i &lt;= 10^91 &lt;= category_i &lt;= n 1 &lt;= k &lt;= n | Class Solution:    Def Findmaximumelegance(self, Items: List[list[int]], K: Int) -&gt; Int:        N = Len(items)        Max_elegance = 0                # Generate All Possible Combinations Of Items With Size K        For Combo In Combinations(items, K):            Total_profit = Sum(item[0] For Item In Combo)            Categories = [Item[1] For Item In Combo]            Distinct_categories = Len(counter(categories))            Elegance = Total_profit + Distinct_categories ** 2            Max_elegance = Max(max_elegance, Elegance)                Return Max_elegance | Class Solution:    Def Findmaximumelegance(self, Items: List[list[int]], K: Int) -&gt; Int:        Items = Sorted(items, Key=lambda V: -V[0])        Res = Cur = 0        A = []        Seen = Set()        For I, (P, C) In Enumerate(items):            If I &lt; K:                If C In Seen:                    A.append(p)                Cur += P            Elif C Not In Seen:                If Not A: Break                Cur += P - A.pop()            Seen.add(c)            Res = Max(res, Cur + Len(seen) * Len(seen))        Return Res 
 36 | 6 | C++ | hard | ChatGPT | Chatbot | You are given a 0-indexed 2D integer array items of length n and an integer k.items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.Your task is to find the maximum elegance from all subsequences of size k in items.Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.Example 1:Input: items = [[3,2],[5,1],[10,1]], k = 2Output: 17Explanation: In this example, we have to select a subsequence of size 2.We can select items[0] = [3,2] and items[2] = [10,1].The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. Example 2:Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3Output: 19Explanation: In this example, we have to select a subsequence of size 3. We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.Example 3:Input: items = [[1,1],[2,1],[3,1]], k = 3Output: 7Explanation: In this example, we have to select a subsequence of size 3. We should select all the items. The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. Hence, the maximum elegance is 6 + 1^2 = 7.   Constraints:1 &lt;= items.length == n &lt;= 10^5items[i].length == 2items[i][0] == profit_iitems[i][1] == category_i1 &lt;= profit_i &lt;= 10^91 &lt;= category_i &lt;= n 1 &lt;= k &lt;= n  | Solve the following problem with C++ code. Class name: Solution, Method name: long long findMaximumElegance(vector&lt;vector&lt;int&gt;&gt;&amp; items, int k).You are given a 0-indexed 2D integer array items of length n and an integer k.items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.Your task is to find the maximum elegance from all subsequences of size k in items.Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.Example 1:Input: items = [[3,2],[5,1],[10,1]], k = 2Output: 17Explanation: In this example, we have to select a subsequence of size 2.We can select items[0] = [3,2] and items[2] = [10,1].The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. Example 2:Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3Output: 19Explanation: In this example, we have to select a subsequence of size 3. We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.Example 3:Input: items = [[1,1],[2,1],[3,1]], k = 3Output: 7Explanation: In this example, we have to select a subsequence of size 3. We should select all the items. The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. Hence, the maximum elegance is 6 + 1^2 = 7.   Constraints:1 &lt;= items.length == n &lt;= 10^5items[i].length == 2items[i][0] == profit_iitems[i][1] == category_i1 &lt;= profit_i &lt;= 10^91 &lt;= category_i &lt;= n 1 &lt;= k &lt;= n | Class Solution {Public:    Long Long Findmaximumelegance(std::vector&lt;std::vector&lt;int&gt;&gt;&amp; Items, Int K) {        Std::unordered_map&lt;int, Std::vector&lt;int&gt;&gt; Categorytoprofits;        Std::unordered_map&lt;int, Long Long&gt; Categorytototalprofit;        For (Auto&amp; Item : Items) {            Int Profit = Item[0];            Int Category = Item[1];            Categorytoprofits[category].push_back(profit);            Categorytototalprofit[category] += Profit;        }        Std::vector&lt;long Long&gt; Maxprofits;        Long Long Totalelegance = 0;        For (Auto&amp; Pair : Categorytoprofits) {            Int Category = Pair.first;            Std::vector&lt;int&gt;&amp; Profits = Pair.second;            Std::sort(profits.rbegin(), Profits.rend());            Long Long Categorytotalprofit = Categorytototalprofit[category];            Int Categorydistinctcount = Profits.size();            For (Int I = 0; I &lt; K &amp;&amp; I &lt; Categorydistinctcount; ++I) {                Totalelegance += Profits[i] + Static_cast&lt;long Long&gt;(categorydistinctcount) * Categorydistinctcount;                Maxprofits.push_back(profits[i]);            }        }        Std::sort(maxprofits.rbegin(), Maxprofits.rend());        For (Int I = K; I &lt; Maxprofits.size(); ++I) {            Totalelegance -= Maxprofits[i];        }        Return Totalelegance;    }}; | Class Solution {Public:    Long Long Findmaximumelegance(vector&lt;vector&lt;int&gt;&gt;&amp; A, Int K) {        Sort(a.begin(), A.end(), [](Const Vector&lt;int&gt;&amp; A, Const Vector&lt;int&gt;&amp; B) {            Return A[0] &gt; B[0];        });        Long Long Res = 0, Cur = 0;        Vector&lt;int&gt; Dup;        Unordered_set&lt;int&gt; Seen;        For (Int I = 0; I &lt; A.size(); ++I) {            If (I &lt; K) {                If (Seen.count(a[i][1])) {                    Dup.push_back(a[i][0]);                }                Cur += A[i][0];            } Else If (Seen.find(a[i][1]) == Seen.end()) {                If (Dup.empty()) Break;                Cur += A[i][0] - Dup.back();                Dup.pop_back();            }            Seen.insert(a[i][1]);            Res = Fmax(res, Cur + 1l * Seen.size() * Seen.size());        }        Return Res;    }}; 
 37 | 1 | Java | easy | Code Llama | IDE Extension | You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.Return the maximum sum or -1 if no such pair exists.Example 1:Input: nums = [51,71,17,24,42]Output: 88Explanation: For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.Example 2:Input: nums = [1,2,3,4]Output: -1Explanation: No pair exists in nums with equal maximum digits.Constraints:2 &lt;= nums.length &lt;= 1001 &lt;= nums[i] &lt;= 10^4  | class Solution {    public int maxSum(int[] nums) {/*You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.Return the maximum sum or -1 if no such pair exists.Example 1:Input: nums = [51,71,17,24,42]Output: 88Explanation: For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.Example 2:Input: nums = [1,2,3,4]Output: -1Explanation: No pair exists in nums with equal maximum digits.Constraints:2 &lt;= nums.length &lt;= 1001 &lt;= nums[i] &lt;= 10^4*/ | Class Solution {    Public Int Maxsum(int[] Nums) {        Int Max = 0;        Int Maxdigit = 0;        For(int I = 0; I &lt; Nums.length; I++){            Int Digit = 0;            Int Num = Nums[i];            While(num &gt; 0){                Digit = Math.max(digit, Num % 10);                Num /= 10;            }            If(digit &gt; Maxdigit){                Maxdigit = Digit;                Max = Nums[i];            }            Else If(digit == Maxdigit){                Max = Math.max(max, Nums[i]);            }        }                Int Maxsum = 0;        For(int I = 0; I &lt; Nums.length; I++){            Int Digit = 0;            Int Num = Nums[i];            While(num &gt; 0){                Digit = Math.max(digit, Num % 10);                Num /= 10;            }            If(digit == Maxdigit){                Maxsum = Math.max(maxsum, Nums[i]);            }        }                If(maxsum == 0){            Return -1;        }                Int Sum = 0;        For(int I = 0; I &lt; Nums.length; I++){            If(nums[i] == Max){                Sum += Nums[i];            }            Else If(nums[i] == Maxsum){                Sum += Nums[i];            }        }                Return Sum;    }} | Class Solution {    Public Int Maxsum(int[] Nums) {    Int Ans = -1;    Map&lt;integer,list&lt;integer&gt;&gt; Ump = New Hashmap&lt;&gt;();    For(int I = 0; I &lt; Nums.length; ++I){        Int T = Nums[i], Maxdigit = 0;        While(t != 0){ //Evaluate Max Digit In The Number            Maxdigit = Math.max(t%10, Maxdigit);            T = T/10;        }        If(!ump.containskey(maxdigit)) Ump.put(maxdigit, New Arraylist&lt;&gt;());        Ump.get(maxdigit).add(nums[i]); // Add The Number To The Map     }    For(map.entry&lt;integer, List&lt;integer&gt;&gt; Entry: Ump.entryset()){        Entry.getvalue().sort(comparator.reverseorder()); //To Find Max Two Number In Each Max Digit         If(entry.getvalue().size() &gt;= 2) Ans = Math.max(ans, Entry.getvalue().get(0) + Entry.getvalue().get(1)); //Sum Max Two Number And Take Max    }    Return Ans;    }} 
 38 | 1 | Python | easy | Code Llama | IDE Extension | You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.Return the maximum sum or -1 if no such pair exists.Example 1:Input: nums = [51,71,17,24,42]Output: 88Explanation: For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.Example 2:Input: nums = [1,2,3,4]Output: -1Explanation: No pair exists in nums with equal maximum digits.Constraints:2 &lt;= nums.length &lt;= 1001 &lt;= nums[i] &lt;= 10^4  | class Solution:    def maxSum(self, nums: List[int]) -&gt; int:&quot;&quot;&quot;You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.Return the maximum sum or -1 if no such pair exists.Example 1:Input: nums = [51,71,17,24,42]Output: 88Explanation: For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.Example 2:Input: nums = [1,2,3,4]Output: -1Explanation: No pair exists in nums with equal maximum digits.Constraints:2 &lt;= nums.length &lt;= 1001 &lt;= nums[i] &lt;= 10^4&quot;&quot;&quot; | Class Solution:    Def Maxsum(self, Nums: List[int]) -&gt; Int:        For I In Range(len(nums)):            For J In Range(i+1, Len(nums)):                If Max(nums[i], Nums[j]) % 10 == Max(nums[i] // 10, Nums[j] // 10):                    Return Max(nums[i], Nums[j])        Return -1 | Class Solution:    Def Maxsum(self, Nums: List[int]) -&gt; Int:        Max_by_digit = Defaultdict(int)        Max_sum = -1        For Num In Nums:            Digit = Max(str(num))            If Digit In Max_by_digit:                Max_sum = Max(max_sum, Max_by_digit[digit] + Num)            Max_by_digit[digit] = Max(max_by_digit[digit], Num)        Return Max_sum 
 39 | 1 | C++ | easy | Code Llama | IDE Extension | You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.Return the maximum sum or -1 if no such pair exists.Example 1:Input: nums = [51,71,17,24,42]Output: 88Explanation: For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.Example 2:Input: nums = [1,2,3,4]Output: -1Explanation: No pair exists in nums with equal maximum digits.Constraints:2 &lt;= nums.length &lt;= 1001 &lt;= nums[i] &lt;= 10^4  | class Solution {public:    int maxSum(vector&lt;int&gt;&amp; nums) {/*You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.Return the maximum sum or -1 if no such pair exists.Example 1:Input: nums = [51,71,17,24,42]Output: 88Explanation: For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.Example 2:Input: nums = [1,2,3,4]Output: -1Explanation: No pair exists in nums with equal maximum digits.Constraints:2 &lt;= nums.length &lt;= 1001 &lt;= nums[i] &lt;= 10^4*/ | Class Solution {Public:    Int Maxsum(vector&lt;int&gt;&amp; Nums) {       Int N = Nums.size();        Int Max_digit = 0;        For(int I = 0; I &lt; N; I++){            Int Digit = 0;            Int Num = Nums[i];            While(num){                Digit = Max(digit, Num % 10);                Num /= 10;            }            Max_digit = Max(max_digit, Digit);        }                Int Max_sum = -1;        For(int I = 0; I &lt; N; I++){            For(int J = I + 1; J &lt; N; J++){                Int Digit = 0;                Int Num = Nums[i] + Nums[j];                While(num){                    Digit = Max(digit, Num % 10);                    Num /= 10;                }                If(digit == Max_digit){                    Max_sum = Max(max_sum, Nums[i] + Nums[j]);                }            }        }                Return Max_sum;    }}; | Class Solution {    Public:        Int Maxsum(vector&lt;int&gt;&amp; Nums) {        Int Res = -1, Max_num[10] = {};        For (Auto Num : Nums) {            Int Max_d = 0;            For (Int V = Num; V; V /= 10)                Max_d = Max(max_d, V % 10);            If (Max_num[max_d])                Res = Max(res, Max_num[max_d] + Num);            Max_num[max_d] = Max(max_num[max_d], Num);        }        Return Res;    }}; 
 40 | 2 | Java | easy | Code Llama | IDE Extension | Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.Return the final string that will be present on your laptop screen.Example 1:Input: s = &quot;string&quot;Output: &quot;rtsng&quot;Explanation: After typing first character, the text on the screen is &quot;s&quot;.After the second character, the text is &quot;st&quot;. After the third character, the text is &quot;str&quot;.Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.After the fifth character, the text is &quot;rtsn&quot;. After the sixth character, the text is &quot;rtsng&quot;. Therefore, we return &quot;rtsng&quot;.Example 2:Input: s = &quot;poiinter&quot;Output: &quot;ponter&quot;Explanation: After the first character, the text on the screen is &quot;p&quot;.After the second character, the text is &quot;po&quot;. Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.After the fifth character, the text is &quot;pon&quot;.After the sixth character, the text is &quot;pont&quot;. After the seventh character, the text is &quot;ponte&quot;. After the eighth character, the text is &quot;ponter&quot;. Therefore, we return &quot;ponter&quot;. Constraints:1 &lt;= s.length &lt;= 100s consists of lowercase English letters.s[0] != &#39;i&#39; | class Solution {    public String finalString(String s) {/*Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.Return the final string that will be present on your laptop screen.Example 1:Input: s = &quot;string&quot;Output: &quot;rtsng&quot;Explanation: After typing first character, the text on the screen is &quot;s&quot;.After the second character, the text is &quot;st&quot;. After the third character, the text is &quot;str&quot;.Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.After the fifth character, the text is &quot;rtsn&quot;. After the sixth character, the text is &quot;rtsng&quot;. Therefore, we return &quot;rtsng&quot;.Example 2:Input: s = &quot;poiinter&quot;Output: &quot;ponter&quot;Explanation: After the first character, the text on the screen is &quot;p&quot;.After the second character, the text is &quot;po&quot;. Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.After the fifth character, the text is &quot;pon&quot;.After the sixth character, the text is &quot;pont&quot;. After the seventh character, the text is &quot;ponte&quot;. After the eighth character, the text is &quot;ponter&quot;. Therefore, we return &quot;ponter&quot;. Constraints:1 &lt;= s.length &lt;= 100s consists of lowercase English letters.s[0] != &#39;i&#39;*/ | Class Solution {    Public String Finalstring(string S) {        Stringbuilder Sb = New Stringbuilder();        For(int I = 0; I &lt; S.length(); I++){            If(s.charat(i) == &#39;I&#39;){                Sb.reverse();            }            Else{                Sb.append(s.charat(i));            }        }        Return Sb.tostring();    }} | Class Solution {    Public String Finalstring(string S) {        Stringbuilder Nm=new Stringbuilder();        For(char C:s.tochararray())        {            If(c==&#39;i&#39;)            {                Nm.reverse();            }            Else            {                Nm.append(c);            }        }        Return Nm.tostring();    }} 
 41 | 2 | Python | easy | Code Llama | IDE Extension | Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.Return the final string that will be present on your laptop screen.Example 1:Input: s = &quot;string&quot;Output: &quot;rtsng&quot;Explanation: After typing first character, the text on the screen is &quot;s&quot;.After the second character, the text is &quot;st&quot;. After the third character, the text is &quot;str&quot;.Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.After the fifth character, the text is &quot;rtsn&quot;. After the sixth character, the text is &quot;rtsng&quot;. Therefore, we return &quot;rtsng&quot;.Example 2:Input: s = &quot;poiinter&quot;Output: &quot;ponter&quot;Explanation: After the first character, the text on the screen is &quot;p&quot;.After the second character, the text is &quot;po&quot;. Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.After the fifth character, the text is &quot;pon&quot;.After the sixth character, the text is &quot;pont&quot;. After the seventh character, the text is &quot;ponte&quot;. After the eighth character, the text is &quot;ponter&quot;. Therefore, we return &quot;ponter&quot;. Constraints:1 &lt;= s.length &lt;= 100s consists of lowercase English letters.s[0] != &#39;i&#39; | class Solution:    def finalString(self, s: str) -&gt; str:&quot;&quot;&quot;Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.Return the final string that will be present on your laptop screen.Example 1:Input: s = &quot;string&quot;Output: &quot;rtsng&quot;Explanation: After typing first character, the text on the screen is &quot;s&quot;.After the second character, the text is &quot;st&quot;. After the third character, the text is &quot;str&quot;.Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.After the fifth character, the text is &quot;rtsn&quot;. After the sixth character, the text is &quot;rtsng&quot;. Therefore, we return &quot;rtsng&quot;.Example 2:Input: s = &quot;poiinter&quot;Output: &quot;ponter&quot;Explanation: After the first character, the text on the screen is &quot;p&quot;.After the second character, the text is &quot;po&quot;. Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.After the fifth character, the text is &quot;pon&quot;.After the sixth character, the text is &quot;pont&quot;. After the seventh character, the text is &quot;ponte&quot;. After the eighth character, the text is &quot;ponter&quot;. Therefore, we return &quot;ponter&quot;. Constraints:1 &lt;= s.length &lt;= 100s consists of lowercase English letters.s[0] != &#39;i&#39;&quot;&quot;&quot; | Class Solution:    Def Finalstring(self, S: Str) -&gt; Str:        Res = &quot;&quot;        For I In S:            If I == &quot;I&quot;:                Res = Res[::-1]            Else:                Res += I        Return Res | Class Solution:    Def Finalstring(self, S: Str) -&gt; Str:        While &quot;I&quot; In S:            Index=s.index(&quot;i&quot;)            #First Half And Second Half            First=s[:index][::-1]            Second=s[index+1:]            S=&quot;&quot;.join([first,second])        Return S 
 42 | 2 | C++ | easy | Code Llama | IDE Extension | Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.Return the final string that will be present on your laptop screen.Example 1:Input: s = &quot;string&quot;Output: &quot;rtsng&quot;Explanation: After typing first character, the text on the screen is &quot;s&quot;.After the second character, the text is &quot;st&quot;. After the third character, the text is &quot;str&quot;.Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.After the fifth character, the text is &quot;rtsn&quot;. After the sixth character, the text is &quot;rtsng&quot;. Therefore, we return &quot;rtsng&quot;.Example 2:Input: s = &quot;poiinter&quot;Output: &quot;ponter&quot;Explanation: After the first character, the text on the screen is &quot;p&quot;.After the second character, the text is &quot;po&quot;. Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.After the fifth character, the text is &quot;pon&quot;.After the sixth character, the text is &quot;pont&quot;. After the seventh character, the text is &quot;ponte&quot;. After the eighth character, the text is &quot;ponter&quot;. Therefore, we return &quot;ponter&quot;. Constraints:1 &lt;= s.length &lt;= 100s consists of lowercase English letters.s[0] != &#39;i&#39; | class Solution {public:    string finalString(string s) {/*Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.Return the final string that will be present on your laptop screen.Example 1:Input: s = &quot;string&quot;Output: &quot;rtsng&quot;Explanation: After typing first character, the text on the screen is &quot;s&quot;.After the second character, the text is &quot;st&quot;. After the third character, the text is &quot;str&quot;.Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.After the fifth character, the text is &quot;rtsn&quot;. After the sixth character, the text is &quot;rtsng&quot;. Therefore, we return &quot;rtsng&quot;.Example 2:Input: s = &quot;poiinter&quot;Output: &quot;ponter&quot;Explanation: After the first character, the text on the screen is &quot;p&quot;.After the second character, the text is &quot;po&quot;. Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.After the fifth character, the text is &quot;pon&quot;.After the sixth character, the text is &quot;pont&quot;. After the seventh character, the text is &quot;ponte&quot;. After the eighth character, the text is &quot;ponter&quot;. Therefore, we return &quot;ponter&quot;. Constraints:1 &lt;= s.length &lt;= 100s consists of lowercase English letters.s[0] != &#39;i&#39;*/ | Class Solution {Public:    String Finalstring(string S) {        String Ans;        For(int I = 0; I &lt; S.length(); I++){            If(s[i] == &#39;I&#39;){                Reverse(ans.begin(), Ans.end());            }            Else{                Ans.push_back(s[i]);            }        }        Return Ans;    }}; | Class Solution {Public:    String Finalstring(const String &amp;S) {        String A, B;        For (Char Ch : S)            If (Ch == &#39;I&#39;)                Swap(a, B);            Else                A += Ch;        Return String(rbegin(b), Rend(b)) + A;    }}; 
 43 | 3 | Java | medium | Code Llama | IDE Extension | You are given a 0-indexed integer array nums and an integer x.Find the minimum absolute difference between two elements in the array that are at least x indices apart.In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.Example 1:Input: nums = [4,3,2,4], x = 2Output: 0Explanation: We can select nums[0] = 4 and nums[3] = 4. They are at least 2 indices apart, and their absolute difference is the minimum, 0. It can be shown that 0 is the optimal answer.Example 2:Input: nums = [5,3,2,10,15], x = 1Output: 1Explanation: We can select nums[1] = 3 and nums[2] = 2.They are at least 1 index apart, and their absolute difference is the minimum, 1.It can be shown that 1 is the optimal answer.Example 3:Input: nums = [1,2,3,4], x = 3Output: 3Explanation: We can select nums[0] = 1 and nums[3] = 4.They are at least 3 indices apart, and their absolute difference is the minimum, 3.It can be shown that 3 is the optimal answer. Constraints:1 &lt;= nums.length &lt;= 10^51 &lt;= nums[i] &lt;= 10^90 &lt;= x &lt; nums.length  | class Solution {    public int minAbsoluteDifference(List&lt;Integer&gt; nums, int x) {/*You are given a 0-indexed integer array nums and an integer x.Find the minimum absolute difference between two elements in the array that are at least x indices apart.In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.Example 1:Input: nums = [4,3,2,4], x = 2Output: 0Explanation: We can select nums[0] = 4 and nums[3] = 4. They are at least 2 indices apart, and their absolute difference is the minimum, 0. It can be shown that 0 is the optimal answer.Example 2:Input: nums = [5,3,2,10,15], x = 1Output: 1Explanation: We can select nums[1] = 3 and nums[2] = 2.They are at least 1 index apart, and their absolute difference is the minimum, 1.It can be shown that 1 is the optimal answer.Example 3:Input: nums = [1,2,3,4], x = 3Output: 3Explanation: We can select nums[0] = 1 and nums[3] = 4.They are at least 3 indices apart, and their absolute difference is the minimum, 3.It can be shown that 3 is the optimal answer. Constraints:1 &lt;= nums.length &lt;= 10^51 &lt;= nums[i] &lt;= 10^90 &lt;= x &lt; nums.length*/ | Class Solution {    Public Int Minabsolutedifference(list&lt;integer&gt; Nums, Int X) {        Int Min = Integer.max_value;        Int N = Nums.size();        For(int I = 0; I &lt; N; I++){            For(int J = I + X; J &lt; N; J++){                Min = Math.min(min, Math.abs(nums.get(i) - Nums.get(j)));            }        }        Return Min;    }} | Class Solution {    Int Minabsolutedifference(list&lt;integer&gt; Nums, Int X) {        Int Ans = Integer.max_value;        Treeset&lt;integer&gt; S = New Treeset&lt;&gt;();        For(int I = X; I &lt; Nums.size(); ++I){            S.add(nums.get(i-x));            Integer High = S.ceiling(nums.get(i)), Low = S.floor(nums.get(i));            If(high != Null) Ans = Math.min(ans, Math.abs(nums.get(i) - High));            If(low != Null) Ans = Math.min(ans, Math.abs(nums.get(i) - Low));        }        Return Ans;    }} 
 44 | 3 | Python | medium | Code Llama | IDE Extension | You are given a 0-indexed integer array nums and an integer x.Find the minimum absolute difference between two elements in the array that are at least x indices apart.In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.Example 1:Input: nums = [4,3,2,4], x = 2Output: 0Explanation: We can select nums[0] = 4 and nums[3] = 4. They are at least 2 indices apart, and their absolute difference is the minimum, 0. It can be shown that 0 is the optimal answer.Example 2:Input: nums = [5,3,2,10,15], x = 1Output: 1Explanation: We can select nums[1] = 3 and nums[2] = 2.They are at least 1 index apart, and their absolute difference is the minimum, 1.It can be shown that 1 is the optimal answer.Example 3:Input: nums = [1,2,3,4], x = 3Output: 3Explanation: We can select nums[0] = 1 and nums[3] = 4.They are at least 3 indices apart, and their absolute difference is the minimum, 3.It can be shown that 3 is the optimal answer. Constraints:1 &lt;= nums.length &lt;= 10^51 &lt;= nums[i] &lt;= 10^90 &lt;= x &lt; nums.length  | class Solution:    def minAbsoluteDifference(self, nums: List[int], x: int) -&gt; int:&quot;&quot;&quot;You are given a 0-indexed integer array nums and an integer x.Find the minimum absolute difference between two elements in the array that are at least x indices apart.In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.Example 1:Input: nums = [4,3,2,4], x = 2Output: 0Explanation: We can select nums[0] = 4 and nums[3] = 4. They are at least 2 indices apart, and their absolute difference is the minimum, 0. It can be shown that 0 is the optimal answer.Example 2:Input: nums = [5,3,2,10,15], x = 1Output: 1Explanation: We can select nums[1] = 3 and nums[2] = 2.They are at least 1 index apart, and their absolute difference is the minimum, 1.It can be shown that 1 is the optimal answer.Example 3:Input: nums = [1,2,3,4], x = 3Output: 3Explanation: We can select nums[0] = 1 and nums[3] = 4.They are at least 3 indices apart, and their absolute difference is the minimum, 3.It can be shown that 3 is the optimal answer. Constraints:1 &lt;= nums.length &lt;= 10^51 &lt;= nums[i] &lt;= 10^90 &lt;= x &lt; nums.length&quot;&quot;&quot; | Class Solution:    Def Minabsolutedifference(self, Nums: List[int], X: Int) -&gt; Int:        Nums.sort()        Min_diff = Float(&#39;inf&#39;)        For I In Range(len(nums)):            If I + X &lt; Len(nums):                Min_diff = Min(min_diff, Abs(nums[i] - Nums[i + X]))        Return Min_diff | Class Solution:  Def Minabsolutedifference(self, Nums: List[int], X: Int) -&gt; Int:    If X == 0:      Return 0    Arr, Best_dist = Sortedlist([]), Float(&#39;inf&#39;)    For I In Range(x, Len(nums)):      Arr.add(nums[i - X])      V = Nums[i]      Pos = Arr.bisect_left(v)      If Pos &lt; Len(arr):        Best_dist = Min(best_dist, Abs(arr[pos] - V))      If Pos &gt; 0:        Best_dist = Min(best_dist, Abs(arr[pos - 1] - V))        Return Best_dist 
 45 | 3 | C++ | medium | Code Llama | IDE Extension | You are given a 0-indexed integer array nums and an integer x.Find the minimum absolute difference between two elements in the array that are at least x indices apart.In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.Example 1:Input: nums = [4,3,2,4], x = 2Output: 0Explanation: We can select nums[0] = 4 and nums[3] = 4. They are at least 2 indices apart, and their absolute difference is the minimum, 0. It can be shown that 0 is the optimal answer.Example 2:Input: nums = [5,3,2,10,15], x = 1Output: 1Explanation: We can select nums[1] = 3 and nums[2] = 2.They are at least 1 index apart, and their absolute difference is the minimum, 1.It can be shown that 1 is the optimal answer.Example 3:Input: nums = [1,2,3,4], x = 3Output: 3Explanation: We can select nums[0] = 1 and nums[3] = 4.They are at least 3 indices apart, and their absolute difference is the minimum, 3.It can be shown that 3 is the optimal answer. Constraints:1 &lt;= nums.length &lt;= 10^51 &lt;= nums[i] &lt;= 10^90 &lt;= x &lt; nums.length  | class Solution {public:    int minAbsoluteDifference(vector&lt;int&gt;&amp; nums, int x) {/*You are given a 0-indexed integer array nums and an integer x.Find the minimum absolute difference between two elements in the array that are at least x indices apart.In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart. Constraints:1 &lt;= nums.length &lt;= 10^51 &lt;= nums[i] &lt;= 10^90 &lt;= x &lt; nums.length*/ | Class Solution {Public:    Int Minabsolutedifference(vector&lt;int&gt;&amp; Nums, Int X) {        Int N=nums.size();        Int Min=int_max;        Int I=0;        Int J=0;        For(i=0;i&lt;n;i++){            For(j=i+1;j&lt;n;j++){                If(abs(nums[i]-nums[j])&lt;min &amp;&amp; Abs(i-j)&gt;=x){                    Min=abs(nums[i]-nums[j]);                }            }        }        Return Min;    }}; | Class Solution {Public:    Int Minabsolutedifference(vector&lt;int&gt;&amp; Nums, Int X) {        Int Ans = Int_max;        Set&lt;int&gt; S;        For(int I = X; I &lt; Nums.size(); ++I){            S.insert(nums[i-x]);            Auto It = S.upper_bound(nums[i]);            If(it != S.end()) Ans = Min(ans, Abs(nums[i] - *It));            If(it != S.begin()) Ans = Min(ans, Abs(nums[i] - *Prev(it)));        }        Return Ans;    }}; 
 46 | 4 | Java | medium | Code Llama | IDE Extension | You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.Return the head of the linked list after doubling it.Example 1:Input: head = [1,8,9]Output: [3,7,8]Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.Example 2:Input: head = [9,9,9]Output: [1,9,9,8]Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. Constraints:The number of nodes in the list is in the range [1, 10^4]0 &lt;= Node.val &lt;= 9The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.  | /*You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.Return the head of the linked list after doubling it.Example 1:Input: head = [1,8,9]Output: [3,7,8]Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.Example 2:Input: head = [9,9,9]Output: [1,9,9,8]Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. Constraints:The number of nodes in the list is in the range [1, 10^4]0 &lt;= Node.val &lt;= 9The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.*/class Solution {    public ListNode doubleIt(ListNode head) { | Class Solution {    Public Listnode Doubleit(listnode Head) {        Listnode Temp = Head;        Listnode Prev = Null;        While(temp!=null){            Int Val = Temp.val;            Temp.val = Val*2;            If(temp.val&gt;9){                Temp.val = Temp.val%10;                If(prev!=null){                    Prev.val+=1;                }            }            Prev = Temp;            Temp = Temp.next;        }        Return Head;    }} | Class Solution {    Public Listnode Doubleit(listnode Head) {        If (Head.val &gt; 4)            Head = New Listnode(0, Head);        For(listnode Node = Head; Node != Null; Node = Node.next) {            Node.val = (Node.val * 2) % 10;            If (Node.next != Null &amp;&amp; Node.next.val &gt; 4)                Node.val++;        }        Return Head;    }} 
 47 | 4 | Python | medium | Code Llama | IDE Extension | You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.Return the head of the linked list after doubling it.Example 1:Input: head = [1,8,9]Output: [3,7,8]Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.Example 2:Input: head = [9,9,9]Output: [1,9,9,8]Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. Constraints:The number of nodes in the list is in the range [1, 10^4]0 &lt;= Node.val &lt;= 9The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.  | #You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.##Return the head of the linked list after doubling it.##Example 1:##Input: head = [1,8,9]#Output: [3,7,8]#Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.##Example 2:##Input: head = [9,9,9]#Output: [1,9,9,8]#Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. ##Constraints:##The number of nodes in the list is in the range [1, 10^4]#0 &lt;= Node.val &lt;= 9#The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.class Solution:    def doubleIt(self, head: Optional[ListNode]) -&gt; Optional[ListNode]: | Class Solution:    Def Doubleit(self, Head: Optional[listnode]) -&gt; Optional[listnode]:        If Head Is None:            Return None                Head.val = Head.val * 2                If Head.next Is None:            Return Head                Head.next = Self.doubleit(head.next)                If Head.val &gt; 9:            Head.val = Head.val - 10            Head.next.val = Head.next.val + 1                    Return Head | Class Solution:    Def Doubleit(self, Head: Optional[listnode]) -&gt; Optional[listnode]:        If Head.val &gt; 4:            Head = Listnode(0, Head)        Node = Head        While Node:            Node.val = (Node.val * 2) % 10            If Node.next And Node.next.val &gt; 4:                Node.val += 1            Node = Node.next        Return Head 
 48 | 4 | C++ | medium | Code Llama | IDE Extension | You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.Return the head of the linked list after doubling it.Example 1:Input: head = [1,8,9]Output: [3,7,8]Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.Example 2:Input: head = [9,9,9]Output: [1,9,9,8]Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. Constraints:The number of nodes in the list is in the range [1, 10^4]0 &lt;= Node.val &lt;= 9The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.  | /*You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.Return the head of the linked list after doubling it.Example 1:Input: head = [1,8,9]Output: [3,7,8]Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.Example 2:Input: head = [9,9,9]Output: [1,9,9,8]Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. Constraints:The number of nodes in the list is in the range [1, 10^4]0 &lt;= Node.val &lt;= 9The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.*/class Solution {public:    ListNode* doubleIt(ListNode* head) { | Class Solution {Public:    Listnode* Doubleit(listnode* Head) {        Listnode* Temp = Head;         Listnode* Temp2 = Head;         While(temp-&gt;next!=null){             Temp2 = Temp2-&gt;next;             Temp = Temp-&gt;next;         }         Temp2-&gt;next = Head;         Temp = Temp2;         While(temp-&gt;next!=null){             Temp-&gt;val = Temp-&gt;val*2;             If(temp-&gt;val&gt;9){                 Temp-&gt;val = Temp-&gt;val%10;                 Temp-&gt;next-&gt;val = Temp-&gt;next-&gt;val+1;             }             Temp = Temp-&gt;next;         }         If(temp-&gt;val&gt;9){             Temp-&gt;val = Temp-&gt;val%10;             Temp-&gt;next = New Listnode(1);         }         Return Head;    }}; | Class Solution {Public:    Listnode* Doubleit(listnode* Head) {        If (Head-&gt;val &gt; 4)            Head = New Listnode(0, Head);        For(listnode* Node = Head; Node; Node = Node-&gt;next) {            Node-&gt;val = (Node-&gt;val * 2) % 10;            If (Node-&gt;next &amp;&amp; Node-&gt;next-&gt;val &gt; 4)                Node-&gt;val++;        }        Return Head;    }}; 
 49 | 5 | Java | hard | Code Llama | IDE Extension | You are given an array nums of n positive integers and an integer k.Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.Multiply your score by x.Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.Return the maximum possible score after applying at most k operations.Since the answer may be large, return it modulo 10^9 + 7.Example 1:Input: nums = [8,3,9,3,8], k = 2Output: 81Explanation: To get a score of 81, we can apply the following operations:- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.It can be proven that 81 is the highest score one can obtain.Example 2:Input: nums = [19,12,14,6,10,18], k = 3Output: 4788Explanation: To get a score of 4788, we can apply the following operations: - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.It can be proven that 4788 is the highest score one can obtain. Constraints:1 &lt;= nums.length == n &lt;= 10^51 &lt;= nums[i] &lt;= 10^51 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9)  | /*You are given an array nums of n positive integers and an integer k.Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.Multiply your score by x.Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.Return the maximum possible score after applying at most k operations.Since the answer may be large, return it modulo 10^9 + 7.Example 1:Input: nums = [8,3,9,3,8], k = 2Output: 81Explanation: To get a score of 81, we can apply the following operations:- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.It can be proven that 81 is the highest score one can obtain.Example 2:Input: nums = [19,12,14,6,10,18], k = 3Output: 4788Explanation: To get a score of 4788, we can apply the following operations: - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.It can be proven that 4788 is the highest score one can obtain. Constraints:1 &lt;= nums.length == n &lt;= 10^51 &lt;= nums[i] &lt;= 10^51 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9)*/class Solution {    public int maximumScore(List&lt;Integer&gt; nums, int k) { | Class Solution {    Public Int Maximumscore(list&lt;integer&gt; Nums, Int K) {        Int N = Nums.size();        Int[][] Dp = New Int[n][k + 1];        For(int I = 0; I &lt; N; I++)            Arrays.fill(dp[i], -1);        Return Dfs(nums, 0, K, Dp);    }    Public Int Dfs(list&lt;integer&gt; Nums, Int I, Int K, Int[][] Dp){        If(i == Nums.size())            Return 1;        If(k == 0)            Return 0;        If(dp[i][k] != -1)            Return Dp[i][k];        Int Ans = 0;        For(int J = I; J &lt; Nums.size(); J++){            Ans = Math.max(ans, Nums.get(j) * Dfs(nums, J + 1, K - 1, Dp));        }        Return Dp[i][k] = Ans;    }} | Class Solution {    Static Final Int Mod = 1000000007;    Public Int Maximumscore(list&lt;integer&gt; Nums, Int K) {        Int N = Nums.size();        Int Upper = Collections.max(nums) + 1;        Boolean[] Prime = New Boolean[upper];        Int[] Primescore = New Int[upper];        Arrays.fill(prime, True);        Prime[0] = Prime[1] = False;        For (Int I = 2; I &lt; Upper; I++) {            If (Prime[i]) {                For (Int J = I; J &lt; Upper; J += I) {                    Primescore[j]++;                    Prime[j] = False;                }            }        }        Int[] Nextgreaterelement = New Int[n];        Arrays.fill(nextgreaterelement, N);        Stack&lt;integer&gt; S = New Stack&lt;&gt;();        For (Int I = N - 1; I &gt;= 0; I--) {            While (!S.empty() &amp;&amp; Primescore[nums.get(i)] &gt;= Primescore[nums.get(s.peek())]) {                S.pop();            }            Nextgreaterelement[i] = S.empty() ? N : S.peek();            S.push(i);        }        Int[] Prevgreaterorequalelement = New Int[n];        Arrays.fill(prevgreaterorequalelement, -1);        S = New Stack&lt;&gt;();        For (Int I = 0; I &lt; N; I++) {            While (!S.empty() &amp;&amp; Primescore[nums.get(i)] &gt; Primescore[nums.get(s.peek())]) {                S.pop();            }            Prevgreaterorequalelement[i] = S.empty() ? -1 : S.peek();            S.push(i);        }        Int Res = 1;        Int[][] Tuples = New Int[n][2];        For (Int I = 0; I &lt; N; I++) {            Tuples[i][0] = Nums.get(i);            Tuples[i][1] = I;        }        Arrays.sort(tuples, New Comparator&lt;int[]&gt;() {            Public Int Compare(int[] A, Int[] B) {                Return B[0] - A[0];            }        });        For (Int I = 0; I &lt; N; I++) {            Int Num = Tuples[i][0];            Int Idx = Tuples[i][1];            Int Operations = Math.min((idx - Prevgreaterorequalelement[idx]) * (Nextgreaterelement[idx] - Idx), K);            Res = (Int)((1l * Res * Pow(num, Operations)) % Mod);            K -= Operations;            If (K == 0) {                Return Res;            }        }        Return Res;    }    Public Int Pow(int X, Int N) {        Int Res = 1;        While (N &gt; 0) {            If (N % 2 == 1) {                Res = (Int)((1l * Res * X) % Mod);            }            X = (Int)((1l * X * X) % Mod);            N /= 2;        }        Return Res;    }} 
 50 | 5 | Python | hard | Code Llama | IDE Extension | You are given an array nums of n positive integers and an integer k.Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.Multiply your score by x.Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.Return the maximum possible score after applying at most k operations.Since the answer may be large, return it modulo 10^9 + 7.Example 1:Input: nums = [8,3,9,3,8], k = 2Output: 81Explanation: To get a score of 81, we can apply the following operations:- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.It can be proven that 81 is the highest score one can obtain.Example 2:Input: nums = [19,12,14,6,10,18], k = 3Output: 4788Explanation: To get a score of 4788, we can apply the following operations: - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.It can be proven that 4788 is the highest score one can obtain. Constraints:1 &lt;= nums.length == n &lt;= 10^51 &lt;= nums[i] &lt;= 10^51 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9)  | &quot;&quot;&quot;You are given an array nums of n positive integers and an integer k.Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.Multiply your score by x.Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.Return the maximum possible score after applying at most k operations.Since the answer may be large, return it modulo 10^9 + 7.Example 1:Input: nums = [8,3,9,3,8], k = 2Output: 81Explanation: To get a score of 81, we can apply the following operations:- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.It can be proven that 81 is the highest score one can obtain.Example 2:Input: nums = [19,12,14,6,10,18], k = 3Output: 4788Explanation: To get a score of 4788, we can apply the following operations: - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.It can be proven that 4788 is the highest score one can obtain. Constraints:1 &lt;= nums.length == n &lt;= 10^51 &lt;= nums[i] &lt;= 10^51 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9)&quot;&quot;&quot;class Solution:    def maximumScore(self, nums: List[int], k: int) -&gt; int: | Class Solution:    Def Maximumscore(self, Nums: List[int], K: Int) -&gt; Int:        Def Prime_score(num):            Prime_factors = Set()            While Num &gt; 1:                For I In Range(2, Num + 1):                    If Num % I == 0:                        Prime_factors.add(i)                        Num //= I                        Break            Return Len(prime_factors)                N = Len(nums)        Dp = [[0] * N For _ In Range(k + 1)]        Dp[0][0] = 1        For I In Range(1, K + 1):            For J In Range(1, N):                For K In Range(j):                    If Prime_score(nums[k]) &gt; Prime_score(nums[j]):                        Dp[i][j] = Max(dp[i][j], Dp[i - 1][k] * Nums[j])                    Else:                        Dp[i][j] = Max(dp[i][j], Dp[i][k] * Nums[j])        Return Dp[k][n - 1] % (10 ** 9 + 7) | Class Solution:     Mod = 1000000007    Def Maximumscore(self, Nums: List[int], K: Int) -&gt; Int:        N = Len(nums)        Upper = Max(nums) + 1        Prime = [True]*upper        Prime[0] = Prime[1] = False        Primescore = [0]*upper        For I In Range(2, Upper):            If Prime[i]:                For J In Range(i, Upper, I):                    Primescore[j] += 1                    Prime[j] = False        Nextgreaterelement = [N]*n        S = []        For I In Range(n - 1, -1, -1):            While S And Primescore[nums[i]] &gt;= Primescore[nums[s[-1]]]:                S.pop()            Nextgreaterelement[i] = S[-1] If S Else N            S.append(i)        Prevgreaterorequalelement = [-1]*n        S = []        For I In Range(n):            While S And Primescore[nums[i]] &gt; Primescore[nums[s[-1]]]:                S.pop()            Prevgreaterorequalelement[i] = S[-1] If S Else -1            S.append(i)        Res = 1        Tuples = [[Nums[i], I] For I In Range(n)]        Tuples.sort(reverse=true)        For Num, Idx In Tuples:            Operations = Min((idx - Prevgreaterorequalelement[idx]) * (Nextgreaterelement[idx] - Idx), K)            Res = (Res * Self.pow(num, Operations)) % Self.mod            K -= Operations            If K == 0:                Return Res        Return Res    Def Pow(self, X: Int, N: Int) -&gt; Int:        Res = 1        While N &gt; 0:            If N % 2 == 1:                Res = (Res * X) % Self.mod            X = (X * X) % Self.mod            N //= 2        Return Res 
 51 | 5 | C++ | hard | Code Llama | IDE Extension | You are given an array nums of n positive integers and an integer k.Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.Multiply your score by x.Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.Return the maximum possible score after applying at most k operations.Since the answer may be large, return it modulo 10^9 + 7.Example 1:Input: nums = [8,3,9,3,8], k = 2Output: 81Explanation: To get a score of 81, we can apply the following operations:- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.It can be proven that 81 is the highest score one can obtain.Example 2:Input: nums = [19,12,14,6,10,18], k = 3Output: 4788Explanation: To get a score of 4788, we can apply the following operations: - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.It can be proven that 4788 is the highest score one can obtain. Constraints:1 &lt;= nums.length == n &lt;= 10^51 &lt;= nums[i] &lt;= 10^51 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9)  | class Solution {public:    int maximumScore(vector&lt;int&gt;&amp; nums, int k) {/*You are given an array nums of n positive integers and an integer k.Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.Multiply your score by x.Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.Return the maximum possible score after applying at most k operations.Since the answer may be large, return it modulo 10^9 + 7.Example 1:Input: nums = [8,3,9,3,8], k = 2Output: 81Explanation: To get a score of 81, we can apply the following operations:- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.It can be proven that 81 is the highest score one can obtain.Example 2:Input: nums = [19,12,14,6,10,18], k = 3Output: 4788Explanation: To get a score of 4788, we can apply the following operations: - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.It can be proven that 4788 is the highest score one can obtain. Constraints:1 &lt;= nums.length == n &lt;= 10^51 &lt;= nums[i] &lt;= 10^51 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9)*/ | Class Solution {Public:    Int Maximumscore(vector&lt;int&gt;&amp; Nums, Int K) {        Int N = Nums.size();        Vector&lt;int&gt; Primes;        For(int I = 2; I &lt;= N; I++){            Bool Isprime = True;            For(int J = 2; J &lt;= Sqrt(i); J++){                If(i % J == 0){                    Isprime = False;                    Break;                }            }            If(isprime){                Primes.push_back(i);            }        }        Vector&lt;int&gt; Dp(n + 1, 0);        Dp[0] = 1;        For(int I = 1; I &lt;= N; I++){            For(int J = 0; J &lt; Primes.size(); J++){                If(primes[j] &lt;= Nums[i - 1]){                    Dp[i] = (Dp[i] + Dp[i - 1]) % Mod;                }            }        }        Int Ans = 0;        For(int I = 0; I &lt;= N; I++){            For(int J = 0; J &lt;= N; J++){                If(i + J &lt;= N){                    Ans = (Ans + Dp[i] * Dp[n - I - J] % Mod) % Mod;                }            }        }        Return Ans;    }        Int Mod = 1e9 + 7;}; | Class Solution {Public:    Const Int Mod = 1000000007;    Int Maximumscore(vector&lt;int&gt;&amp; Nums, Int K) {        Int N = Nums.size();        Int Upper = *Max_element(nums.begin(), Nums.end()) + 1;        Vector&lt;bool&gt; Prime(upper, True);        Prime[0] = Prime[1] = False;        Vector&lt;int&gt; Primescore(upper, 0);        For (Int I = 2; I &lt; Upper; I++) {            If (Prime[i]) {                For (Int J = I; J &lt; Upper; J += I) {                    Primescore[j]++;                    Prime[j] = False;                }            }        }        Vector&lt;int&gt; Nextgreaterelement(n, N);        Stack&lt;int&gt; S;        For (Int I = N - 1; I &gt;= 0; I--) {            While (!S.empty() &amp;&amp; Primescore[nums[i]] &gt;= Primescore[nums[s.top()]]) {                S.pop();            }            Nextgreaterelement[i] = S.empty() ? N : S.top();            S.push(i);        }        Vector&lt;int&gt; Prevgreaterorequalelement(n, -1);        S = Stack&lt;int&gt;();        For (Int I = 0; I &lt; N; I++) {            While (!S.empty() &amp;&amp; Primescore[nums[i]] &gt; Primescore[nums[s.top()]]) {                S.pop();            }            Prevgreaterorequalelement[i] = S.empty() ? -1 : S.top();            S.push(i);        }        Int Res = 1;        Vector&lt;pair&lt;int, Int&gt;&gt; Tuples(n);        For (Int I = 0; I &lt; N; I++) {            Tuples[i].first = Nums[i];            Tuples[i].second = I;        }        Sort(tuples.rbegin(), Tuples.rend());        For (Const Auto&amp; [Num, I] : Tuples) {            Int Operations = Min((i - Prevgreaterorequalelement[i]) * (Nextgreaterelement[i] - I), K);            Res = (Int)((1l * Res * Pow(num, Operations)) % Mod);            K -= Operations;            If (K == 0) {                Return Res;            }        }        Return Res;    }    Int Pow(int X, Int N) {        Int Res = 1;        While (N &gt; 0) {            If (N % 2 == 1) {                Res = (Int)((1l * Res * X) % Mod);            }            X = (Int)((1l * X * X) % Mod);            N /= 2;        }        Return Res;    }}; 
 52 | 6 | Java | hard | Code Llama | IDE Extension | You are given a 0-indexed 2D integer array items of length n and an integer k.items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.Your task is to find the maximum elegance from all subsequences of size k in items.Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.Example 1:Input: items = [[3,2],[5,1],[10,1]], k = 2Output: 17Explanation: In this example, we have to select a subsequence of size 2.We can select items[0] = [3,2] and items[2] = [10,1].The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. Example 2:Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3Output: 19Explanation: In this example, we have to select a subsequence of size 3. We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.Example 3:Input: items = [[1,1],[2,1],[3,1]], k = 3Output: 7Explanation: In this example, we have to select a subsequence of size 3. We should select all the items. The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. Hence, the maximum elegance is 6 + 1^2 = 7.   Constraints:1 &lt;= items.length == n &lt;= 10^5items[i].length == 2items[i][0] == profit_iitems[i][1] == category_i1 &lt;= profit_i &lt;= 10^91 &lt;= category_i &lt;= n 1 &lt;= k &lt;= n  | /*You are given a 0-indexed 2D integer array items of length n and an integer k.items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.Your task is to find the maximum elegance from all subsequences of size k in items.Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.Example 1:Input: items = [[3,2],[5,1],[10,1]], k = 2Output: 17Explanation: In this example, we have to select a subsequence of size 2.We can select items[0] = [3,2] and items[2] = [10,1].The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. Example 2:Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3Output: 19Explanation: In this example, we have to select a subsequence of size 3. We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.Example 3:Input: items = [[1,1],[2,1],[3,1]], k = 3Output: 7Explanation: In this example, we have to select a subsequence of size 3. We should select all the items. The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. Hence, the maximum elegance is 6 + 1^2 = 7.   Constraints:1 &lt;= items.length == n &lt;= 10^5items[i].length == 2items[i][0] == profit_iitems[i][1] == category_i1 &lt;= profit_i &lt;= 10^91 &lt;= category_i &lt;= n 1 &lt;= k &lt;= n*/class Solution {    public long findMaximumElegance(int[][] items, int k) { | Class Solution {    Public Long Findmaximumelegance(int[][] Items, Int K) {        Int N = Items.length;        Long[][] Dp = New Long[n + 1][k + 1];        For (Int I = 1; I &lt;= N; I++) {            Int Profit = Items[i - 1][0];            Int Category = Items[i - 1][1];            For (Int J = 1; J &lt;= K; J++) {                Dp[i][j] = Math.max(dp[i - 1][j], Dp[i - 1][j - 1] + Profit);                If (Category != Items[i - 1][1]) {                    Dp[i][j] = Math.max(dp[i][j], Dp[i - 1][j] + Profit);                }            }        }        Long Max = 0;        For (Int I = 1; I &lt;= K; I++) {            Max = Math.max(max, Dp[n][i]);        }        Return Max;    }} | Class Solution {    Public Long Findmaximumelegance(int[][] A, Int K) {        Arrays.sort(a, (A, B) -&gt; B[0] - A[0]);        Long Res = 0, Cur = 0;        List&lt;integer&gt; Dup = New Arraylist&lt;&gt;();        Set&lt;integer&gt; Seen = New Hashset&lt;&gt;();        For (Int I = 0; I &lt; A.length; ++I) {            If (I &lt; K) {                If (Seen.contains(a[i][1])) {                    Dup.add(a[i][0]);                }                Cur += A[i][0];            } Else If (!Seen.contains(a[i][1])) {                If (Dup.isempty()) Break;                Cur += A[i][0] - Dup.remove(dup.size() - 1);            }            Seen.add(a[i][1]);            Res = Math.max(res, Cur + 1l * Seen.size() * Seen.size());        }        Return Res;    }} 
 53 | 6 | Python | hard | Code Llama | IDE Extension | You are given a 0-indexed 2D integer array items of length n and an integer k.items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.Your task is to find the maximum elegance from all subsequences of size k in items.Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.Example 1:Input: items = [[3,2],[5,1],[10,1]], k = 2Output: 17Explanation: In this example, we have to select a subsequence of size 2.We can select items[0] = [3,2] and items[2] = [10,1].The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. Example 2:Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3Output: 19Explanation: In this example, we have to select a subsequence of size 3. We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.Example 3:Input: items = [[1,1],[2,1],[3,1]], k = 3Output: 7Explanation: In this example, we have to select a subsequence of size 3. We should select all the items. The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. Hence, the maximum elegance is 6 + 1^2 = 7.   Constraints:1 &lt;= items.length == n &lt;= 10^5items[i].length == 2items[i][0] == profit_iitems[i][1] == category_i1 &lt;= profit_i &lt;= 10^91 &lt;= category_i &lt;= n 1 &lt;= k &lt;= n  | &quot;&quot;&quot;You are given a 0-indexed 2D integer array items of length n and an integer k.items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.Your task is to find the maximum elegance from all subsequences of size k in items.Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.Example 1:Input: items = [[3,2],[5,1],[10,1]], k = 2Output: 17Explanation: In this example, we have to select a subsequence of size 2.We can select items[0] = [3,2] and items[2] = [10,1].The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. Example 2:Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3Output: 19Explanation: In this example, we have to select a subsequence of size 3. We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.Example 3:Input: items = [[1,1],[2,1],[3,1]], k = 3Output: 7Explanation: In this example, we have to select a subsequence of size 3. We should select all the items. The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. Hence, the maximum elegance is 6 + 1^2 = 7.   Constraints:1 &lt;= items.length == n &lt;= 10^5items[i].length == 2items[i][0] == profit_iitems[i][1] == category_i1 &lt;= profit_i &lt;= 10^91 &lt;= category_i &lt;= n 1 &lt;= k &lt;= n&quot;&quot;&quot;class Solution:    def findMaximumElegance(self, items: List[List[int]], k: int) -&gt; int: | Class Solution:    Def Findmaximumelegance(self, Items: List[list[int]], K: Int) -&gt; Int:        N = Len(items)        Profit = [0] * N        Category = [0] * N        For I In Range(n):            Profit[i] = Items[i][0]            Category[i] = Items[i][1]        Profit.sort(reverse=true)        Category.sort(reverse=true)        Profit = Profit[:k]        Category = Category[:k]                Profit_set = Set(profit)        Category_set = Set(category)                Profit_sum = Sum(profit)        Category_sum = Sum(category)                Return Profit_sum + Category_sum ** 2 | Class Solution:    Def Findmaximumelegance(self, Items: List[list[int]], K: Int) -&gt; Int:        Items = Sorted(items, Key=lambda V: -V[0])        Res = Cur = 0        A = []        Seen = Set()        For I, (P, C) In Enumerate(items):            If I &lt; K:                If C In Seen:                    A.append(p)                Cur += P            Elif C Not In Seen:                If Not A: Break                Cur += P - A.pop()            Seen.add(c)            Res = Max(res, Cur + Len(seen) * Len(seen))        Return Res 
 54 | 6 | C++ | hard | Code Llama | IDE Extension | You are given a 0-indexed 2D integer array items of length n and an integer k.items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.Your task is to find the maximum elegance from all subsequences of size k in items.Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.Example 1:Input: items = [[3,2],[5,1],[10,1]], k = 2Output: 17Explanation: In this example, we have to select a subsequence of size 2.We can select items[0] = [3,2] and items[2] = [10,1].The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. Example 2:Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3Output: 19Explanation: In this example, we have to select a subsequence of size 3. We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.Example 3:Input: items = [[1,1],[2,1],[3,1]], k = 3Output: 7Explanation: In this example, we have to select a subsequence of size 3. We should select all the items. The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. Hence, the maximum elegance is 6 + 1^2 = 7.   Constraints:1 &lt;= items.length == n &lt;= 10^5items[i].length == 2items[i][0] == profit_iitems[i][1] == category_i1 &lt;= profit_i &lt;= 10^91 &lt;= category_i &lt;= n 1 &lt;= k &lt;= n  | class Solution {public:    long long findMaximumElegance(vector&lt;vector&lt;int&gt;&gt;&amp; items, int k) {/*You are given a 0-indexed 2D integer array items of length n and an integer k.items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.Your task is to find the maximum elegance from all subsequences of size k in items.Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.Example 1:Input: items = [[3,2],[5,1],[10,1]], k = 2Output: 17Explanation: In this example, we have to select a subsequence of size 2.We can select items[0] = [3,2] and items[2] = [10,1].The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. Example 2:Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3Output: 19Explanation: In this example, we have to select a subsequence of size 3. We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.Example 3:Input: items = [[1,1],[2,1],[3,1]], k = 3Output: 7Explanation: In this example, we have to select a subsequence of size 3. We should select all the items. The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. Hence, the maximum elegance is 6 + 1^2 = 7.   Constraints:1 &lt;= items.length == n &lt;= 10^5items[i].length == 2items[i][0] == profit_iitems[i][1] == category_i1 &lt;= profit_i &lt;= 10^91 &lt;= category_i &lt;= n 1 &lt;= k &lt;= n*/ | Class Solution {Public:    Long Long Findmaximumelegance(vector&lt;vector&lt;int&gt;&gt;&amp; Items, Int K) {        Int N = Items.size();        Vector&lt;int&gt; Profit(n);        Vector&lt;int&gt; Category(n);                For(int I = 0; I &lt; N; I++){            Profit[i] = Items[i][0];            Category[i] = Items[i][1];        }                Sort(profit.begin(), Profit.end());        Sort(category.begin(), Category.end());                Int Max_elegance = 0;                For(int I = 0; I &lt; N; I++){            Int J = I + K - 1;            If(j &gt;= N) Break;                        Int Total_profit = Profit[j] - Profit[i];            Int Distinct_categories = Upper_bound(category.begin(), Category.end(), Category[j]) - Upper_bound(category.begin(), Category.end(), Category[i]);                        Max_elegance = Max(max_elegance, Total_profit + Distinct_categories * Distinct_categories);        }                Return Max_elegance;    }}; | Class Solution {Public:    Long Long Findmaximumelegance(vector&lt;vector&lt;int&gt;&gt;&amp; A, Int K) {        Sort(a.begin(), A.end(), [](Const Vector&lt;int&gt;&amp; A, Const Vector&lt;int&gt;&amp; B) {            Return A[0] &gt; B[0];        });        Long Long Res = 0, Cur = 0;        Vector&lt;int&gt; Dup;        Unordered_set&lt;int&gt; Seen;        For (Int I = 0; I &lt; A.size(); ++I) {            If (I &lt; K) {                If (Seen.count(a[i][1])) {                    Dup.push_back(a[i][0]);                }                Cur += A[i][0];            } Else If (Seen.find(a[i][1]) == Seen.end()) {                If (Dup.empty()) Break;                Cur += A[i][0] - Dup.back();                Dup.pop_back();            }            Seen.insert(a[i][1]);            Res = Fmax(res, Cur + 1l * Seen.size() * Seen.size());        }        Return Res;    }}; 
 55 | 1 | Java | easy | CodeWhisperer | IDE Extension | You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.Return the maximum sum or -1 if no such pair exists.Example 1:Input: nums = [51,71,17,24,42]Output: 88Explanation: For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.Example 2:Input: nums = [1,2,3,4]Output: -1Explanation: No pair exists in nums with equal maximum digits.Constraints:2 &lt;= nums.length &lt;= 1001 &lt;= nums[i] &lt;= 10^4  | public class Solution{    public int maxSum(int[] nums) {/*You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.Return the maximum sum or -1 if no such pair exists.Example 1:Input: nums = [51,71,17,24,42]Output: 88Explanation: For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.Example 2:Input: nums = [1,2,3,4]Output: -1Explanation: No pair exists in nums with equal maximum digits. Constraints:2 &lt;= nums.length &lt;= 1001 &lt;= nums[i] &lt;= 10^4*/ | Public Class Solution{    Public Int Maxsum(int[] Nums) {        Int Max = -1;        For(int I = 0; I &lt; Nums.length; I++) {            For(int J = I + 1; J &lt; Nums.length;                    J++) {                If(nums[i] % 10 == Nums[j] % 10) {                    Max = Math.max(max, Nums[i] + Nums[j]);                }            }                    }        Return Max;            }    } | Class Solution {    Public Int Maxsum(int[] Nums) {    Int Ans = -1;    Map&lt;integer,list&lt;integer&gt;&gt; Ump = New Hashmap&lt;&gt;();    For(int I = 0; I &lt; Nums.length; ++I){        Int T = Nums[i], Maxdigit = 0;        While(t != 0){ //Evaluate Max Digit In The Number            Maxdigit = Math.max(t%10, Maxdigit);            T = T/10;        }        If(!ump.containskey(maxdigit)) Ump.put(maxdigit, New Arraylist&lt;&gt;());        Ump.get(maxdigit).add(nums[i]); // Add The Number To The Map     }    For(map.entry&lt;integer, List&lt;integer&gt;&gt; Entry: Ump.entryset()){        Entry.getvalue().sort(comparator.reverseorder()); //To Find Max Two Number In Each Max Digit         If(entry.getvalue().size() &gt;= 2) Ans = Math.max(ans, Entry.getvalue().get(0) + Entry.getvalue().get(1)); //Sum Max Two Number And Take Max    }    Return Ans;    }} 
 56 | 1 | Python | easy | CodeWhisperer | IDE Extension | You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.Return the maximum sum or -1 if no such pair exists.Example 1:Input: nums = [51,71,17,24,42]Output: 88Explanation: For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.Example 2:Input: nums = [1,2,3,4]Output: -1Explanation: No pair exists in nums with equal maximum digits.Constraints:2 &lt;= nums.length &lt;= 1001 &lt;= nums[i] &lt;= 10^4  | class Solution:    def maxSum(self, nums: List[int]) -&gt; int:&quot;&quot;&quot;You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.Return the maximum sum or -1 if no such pair exists.Example 1:Input: nums = [51,71,17,24,42]Output: 88Explanation: For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.Example 2:Input: nums = [1,2,3,4]Output: -1Explanation: No pair exists in nums with equal maximum digits. Constraints:2 &lt;= nums.length &lt;= 1001 &lt;= nums[i] &lt;= 10^4&quot;&quot;&quot; | Class Solution:    Def Maxsum(self, Nums: List[int]) -&gt; Int:        Nums.sort(reverse=true)        For I In Range(len(nums)-1):            If Nums[i]%10==nums[i+1]%10:                Return Nums[i]+nums[i+1]        Return -1 | Class Solution:    Def Maxsum(self, Nums: List[int]) -&gt; Int:        Max_by_digit = Defaultdict(int)        Max_sum = -1        For Num In Nums:            Digit = Max(str(num))            If Digit In Max_by_digit:                Max_sum = Max(max_sum, Max_by_digit[digit] + Num)            Max_by_digit[digit] = Max(max_by_digit[digit], Num)        Return Max_sum 
 57 | 1 | C++ | easy | CodeWhisperer | IDE Extension | You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.Return the maximum sum or -1 if no such pair exists.Example 1:Input: nums = [51,71,17,24,42]Output: 88Explanation: For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.Example 2:Input: nums = [1,2,3,4]Output: -1Explanation: No pair exists in nums with equal maximum digits.Constraints:2 &lt;= nums.length &lt;= 1001 &lt;= nums[i] &lt;= 10^4  | /*You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.Return the maximum sum or -1 if no such pair exists.Example 1:Input: nums = [51,71,17,24,42]Output: 88Explanation: For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.Example 2:Input: nums = [1,2,3,4]Output: -1Explanation: No pair exists in nums with equal maximum digits.Constraints:2 &lt;= nums.length &lt;= 1001 &lt;= nums[i] &lt;= 10^4*/class Solution {public:    int maxSum(vector&lt;int&gt;&amp; nums) { | Class Solution {Public:    Int Maxsum(vector&lt;int&gt;&amp; Nums) {        Int Ans = -1;        Int N = Nums.size();        For(int I = 0; I &lt; N; I++){            For(int J = I + 1; J &lt; N; J++){                If(nums[i] % 10 == Nums[j] % 10){                    Ans = Max(ans, Nums[i] + Nums[j]);                    Break;                }            }        }        Return Ans;    }}; | Class Solution {    Public:        Int Maxsum(vector&lt;int&gt;&amp; Nums) {        Int Res = -1, Max_num[10] = {};        For (Auto Num : Nums) {            Int Max_d = 0;            For (Int V = Num; V; V /= 10)                Max_d = Max(max_d, V % 10);            If (Max_num[max_d])                Res = Max(res, Max_num[max_d] + Num);            Max_num[max_d] = Max(max_num[max_d], Num);        }        Return Res;    }}; 
 58 | 2 | Java | easy | CodeWhisperer | IDE Extension | Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.Return the final string that will be present on your laptop screen.Example 1:Input: s = &quot;string&quot;Output: &quot;rtsng&quot;Explanation: After typing first character, the text on the screen is &quot;s&quot;.After the second character, the text is &quot;st&quot;. After the third character, the text is &quot;str&quot;.Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.After the fifth character, the text is &quot;rtsn&quot;. After the sixth character, the text is &quot;rtsng&quot;. Therefore, we return &quot;rtsng&quot;.Example 2:Input: s = &quot;poiinter&quot;Output: &quot;ponter&quot;Explanation: After the first character, the text on the screen is &quot;p&quot;.After the second character, the text is &quot;po&quot;. Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.After the fifth character, the text is &quot;pon&quot;.After the sixth character, the text is &quot;pont&quot;. After the seventh character, the text is &quot;ponte&quot;. After the eighth character, the text is &quot;ponter&quot;. Therefore, we return &quot;ponter&quot;. Constraints:1 &lt;= s.length &lt;= 100s consists of lowercase English letters.s[0] != &#39;i&#39; | public class Solution {    public String finalString(String s) {        /*         * Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.Return the final string that will be present on your laptop screen.Example 1:Input: s = &quot;string&quot;Output: &quot;rtsng&quot;Explanation: After typing first character, the text on the screen is &quot;s&quot;.After the second character, the text is &quot;st&quot;. After the third character, the text is &quot;str&quot;.Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.After the fifth character, the text is &quot;rtsn&quot;. After the sixth character, the text is &quot;rtsng&quot;. Therefore, we return &quot;rtsng&quot;.Example 2:Input: s = &quot;poiinter&quot;Output: &quot;ponter&quot;Explanation: After the first character, the text on the screen is &quot;p&quot;.After the second character, the text is &quot;po&quot;. Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.After the fifth character, the text is &quot;pon&quot;.After the sixth character, the text is &quot;pont&quot;. After the seventh character, the text is &quot;ponte&quot;. After the eighth character, the text is &quot;ponter&quot;. Therefore, we return &quot;ponter&quot;. Constraints:1 &lt;= s.length &lt;= 100s consists of lowercase English letters.s[0] != &#39;i&#39;*/ | Public Class Solution {    Public String Finalstring(string S) {        Stringbuilder Sb = New Stringbuilder();        For (Int I = 0; I &lt; S.length(); I++) {            Char C = S.charat(i);            If (C == &#39;I&#39;) {                Sb.append(s.substring(i));                Break;            }            Sb.append(c);        }        Return Sb.tostring();            }    } | Class Solution {    Public String Finalstring(string S) {        Stringbuilder Nm=new Stringbuilder();        For(char C:s.tochararray())        {            If(c==&#39;i&#39;)            {                Nm.reverse();            }            Else            {                Nm.append(c);            }        }        Return Nm.tostring();    }} 
 59 | 2 | Python | easy | CodeWhisperer | IDE Extension | Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.Return the final string that will be present on your laptop screen.Example 1:Input: s = &quot;string&quot;Output: &quot;rtsng&quot;Explanation: After typing first character, the text on the screen is &quot;s&quot;.After the second character, the text is &quot;st&quot;. After the third character, the text is &quot;str&quot;.Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.After the fifth character, the text is &quot;rtsn&quot;. After the sixth character, the text is &quot;rtsng&quot;. Therefore, we return &quot;rtsng&quot;.Example 2:Input: s = &quot;poiinter&quot;Output: &quot;ponter&quot;Explanation: After the first character, the text on the screen is &quot;p&quot;.After the second character, the text is &quot;po&quot;. Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.After the fifth character, the text is &quot;pon&quot;.After the sixth character, the text is &quot;pont&quot;. After the seventh character, the text is &quot;ponte&quot;. After the eighth character, the text is &quot;ponter&quot;. Therefore, we return &quot;ponter&quot;. Constraints:1 &lt;= s.length &lt;= 100s consists of lowercase English letters.s[0] != &#39;i&#39; | class Solution:    def finalString(self, s: str) -&gt; str:&quot;&quot;&quot;Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.Return the final string that will be present on your laptop screen.Example 1:Input: s = &quot;string&quot;Output: &quot;rtsng&quot;Explanation: After typing first character, the text on the screen is &quot;s&quot;.After the second character, the text is &quot;st&quot;. After the third character, the text is &quot;str&quot;.Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.After the fifth character, the text is &quot;rtsn&quot;. After the sixth character, the text is &quot;rtsng&quot;. Therefore, we return &quot;rtsng&quot;.Example 2:Input: s = &quot;poiinter&quot;Output: &quot;ponter&quot;Explanation: After the first character, the text on the screen is &quot;p&quot;.After the second character, the text is &quot;po&quot;. Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.After the fifth character, the text is &quot;pon&quot;.After the sixth character, the text is &quot;pont&quot;. After the seventh character, the text is &quot;ponte&quot;. After the eighth character, the text is &quot;ponter&quot;. Therefore, we return &quot;ponter&quot;. Constraints:1 &lt;= s.length &lt;= 100s consists of lowercase English letters.s[0] != &#39;i&#39;&quot;&quot;&quot; | Class Solution:    Def Finalstring(self, S: Str) -&gt; Str:        Ans = &quot;&quot;        For I In Range(len(s)):            If S[i] == &#39;I&#39;:                Ans = Ans[:-1]            Else:                Ans += S[i]        Return Ans | Class Solution:    Def Finalstring(self, S: Str) -&gt; Str:        While &quot;I&quot; In S:            Index=s.index(&quot;i&quot;)            #First Half And Second Half            First=s[:index][::-1]            Second=s[index+1:]            S=&quot;&quot;.join([first,second])        Return S 
 60 | 2 | C++ | easy | CodeWhisperer | IDE Extension | Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.Return the final string that will be present on your laptop screen.Example 1:Input: s = &quot;string&quot;Output: &quot;rtsng&quot;Explanation: After typing first character, the text on the screen is &quot;s&quot;.After the second character, the text is &quot;st&quot;. After the third character, the text is &quot;str&quot;.Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.After the fifth character, the text is &quot;rtsn&quot;. After the sixth character, the text is &quot;rtsng&quot;. Therefore, we return &quot;rtsng&quot;.Example 2:Input: s = &quot;poiinter&quot;Output: &quot;ponter&quot;Explanation: After the first character, the text on the screen is &quot;p&quot;.After the second character, the text is &quot;po&quot;. Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.After the fifth character, the text is &quot;pon&quot;.After the sixth character, the text is &quot;pont&quot;. After the seventh character, the text is &quot;ponte&quot;. After the eighth character, the text is &quot;ponter&quot;. Therefore, we return &quot;ponter&quot;. Constraints:1 &lt;= s.length &lt;= 100s consists of lowercase English letters.s[0] != &#39;i&#39; | class Solution {public:    string finalString(string s) {/*Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.Return the final string that will be present on your laptop screen.Example 1:Input: s = &quot;string&quot;Output: &quot;rtsng&quot;Explanation: After typing first character, the text on the screen is &quot;s&quot;.After the second character, the text is &quot;st&quot;. After the third character, the text is &quot;str&quot;.Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.After the fifth character, the text is &quot;rtsn&quot;. After the sixth character, the text is &quot;rtsng&quot;. Therefore, we return &quot;rtsng&quot;.Example 2:Input: s = &quot;poiinter&quot;Output: &quot;ponter&quot;Explanation: After the first character, the text on the screen is &quot;p&quot;.After the second character, the text is &quot;po&quot;. Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.After the fifth character, the text is &quot;pon&quot;.After the sixth character, the text is &quot;pont&quot;. After the seventh character, the text is &quot;ponte&quot;. After the eighth character, the text is &quot;ponter&quot;. Therefore, we return &quot;ponter&quot;. Constraints:1 &lt;= s.length &lt;= 100s consists of lowercase English letters.s[0] != &#39;i&#39;*/ | Class Solution {Public:    String Finalstring(string S) {        String Ans=&quot;&quot;;        For(int I=0;i&lt;s.length();i++){            If(s[i]==&#39;i&#39;){                Reverse(ans.begin(),ans.end());                Ans=&quot;&quot;;                Continue;            }            Ans+=s[i];        }        Return Ans;    }}; | Class Solution {Public:    String Finalstring(const String &amp;S) {        String A, B;        For (Char Ch : S)            If (Ch == &#39;I&#39;)                Swap(a, B);            Else                A += Ch;        Return String(rbegin(b), Rend(b)) + A;    }}; 
 61 | 3 | Java | medium | CodeWhisperer | IDE Extension | You are given a 0-indexed integer array nums and an integer x.Find the minimum absolute difference between two elements in the array that are at least x indices apart.In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.Example 1:Input: nums = [4,3,2,4], x = 2Output: 0Explanation: We can select nums[0] = 4 and nums[3] = 4. They are at least 2 indices apart, and their absolute difference is the minimum, 0. It can be shown that 0 is the optimal answer.Example 2:Input: nums = [5,3,2,10,15], x = 1Output: 1Explanation: We can select nums[1] = 3 and nums[2] = 2.They are at least 1 index apart, and their absolute difference is the minimum, 1.It can be shown that 1 is the optimal answer.Example 3:Input: nums = [1,2,3,4], x = 3Output: 3Explanation: We can select nums[0] = 1 and nums[3] = 4.They are at least 3 indices apart, and their absolute difference is the minimum, 3.It can be shown that 3 is the optimal answer. Constraints:1 &lt;= nums.length &lt;= 10^51 &lt;= nums[i] &lt;= 10^90 &lt;= x &lt; nums.length  | class Solution {    public int minAbsoluteDifference(List&lt;Integer&gt; nums, int x) {        /*         * You are given a 0-indexed integer array nums and an integer x.Find the minimum absolute difference between two elements in the array that are at least x indices apart.In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.Example 1:Input: nums = [4,3,2,4], x = 2Output: 0Explanation: We can select nums[0] = 4 and nums[3] = 4. They are at least 2 indices apart, and their absolute difference is the minimum, 0. It can be shown that 0 is the optimal answer.Example 2:Input: nums = [5,3,2,10,15], x = 1Output: 1Explanation: We can select nums[1] = 3 and nums[2] = 2.They are at least 1 index apart, and their absolute difference is the minimum, 1.It can be shown that 1 is the optimal answer.Example 3:Input: nums = [1,2,3,4], x = 3Output: 3Explanation: We can select nums[0] = 1 and nums[3] = 4.They are at least 3 indices apart, and their absolute difference is the minimum, 3.It can be shown that 3 is the optimal answer. Constraints:1 &lt;= nums.length &lt;= 10^51 &lt;= nums[i] &lt;= 10^90 &lt;= x &lt; nums.length*/ | Class Solution {    Public Int Minabsolutedifference(list&lt;integer&gt; Nums, Int X) {        Int Min = Integer.max_value;        Int N = Nums.size();        For (Int I = 0; I &lt; N; I++) {            For (Int J = I + 1; J &lt; N; J++) {                If (Math.abs(i - J) &gt;= X) {                    Min = Math.min(min, Math.abs(nums.get(i) - Nums.get(j)));                }            }        }        Return Min;            }    } | Class Solution {    Int Minabsolutedifference(list&lt;integer&gt; Nums, Int X) {        Int Ans = Integer.max_value;        Treeset&lt;integer&gt; S = New Treeset&lt;&gt;();        For(int I = X; I &lt; Nums.size(); ++I){            S.add(nums.get(i-x));            Integer High = S.ceiling(nums.get(i)), Low = S.floor(nums.get(i));            If(high != Null) Ans = Math.min(ans, Math.abs(nums.get(i) - High));            If(low != Null) Ans = Math.min(ans, Math.abs(nums.get(i) - Low));        }        Return Ans;    }} 
 62 | 3 | Python | medium | CodeWhisperer | IDE Extension | You are given a 0-indexed integer array nums and an integer x.Find the minimum absolute difference between two elements in the array that are at least x indices apart.In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.Example 1:Input: nums = [4,3,2,4], x = 2Output: 0Explanation: We can select nums[0] = 4 and nums[3] = 4. They are at least 2 indices apart, and their absolute difference is the minimum, 0. It can be shown that 0 is the optimal answer.Example 2:Input: nums = [5,3,2,10,15], x = 1Output: 1Explanation: We can select nums[1] = 3 and nums[2] = 2.They are at least 1 index apart, and their absolute difference is the minimum, 1.It can be shown that 1 is the optimal answer.Example 3:Input: nums = [1,2,3,4], x = 3Output: 3Explanation: We can select nums[0] = 1 and nums[3] = 4.They are at least 3 indices apart, and their absolute difference is the minimum, 3.It can be shown that 3 is the optimal answer. Constraints:1 &lt;= nums.length &lt;= 10^51 &lt;= nums[i] &lt;= 10^90 &lt;= x &lt; nums.length  | class Solution:    def minAbsoluteDifference(self, nums: List[int], x: int) -&gt; int:&quot;&quot;&quot;You are given a 0-indexed integer array nums and an integer x.Find the minimum absolute difference between two elements in the array that are at least x indices apart.In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.Example 1:Input: nums = [4,3,2,4], x = 2Output: 0Explanation: We can select nums[0] = 4 and nums[3] = 4. They are at least 2 indices apart, and their absolute difference is the minimum, 0. It can be shown that 0 is the optimal answer.Example 2:Input: nums = [5,3,2,10,15], x = 1Output: 1Explanation: We can select nums[1] = 3 and nums[2] = 2.They are at least 1 index apart, and their absolute difference is the minimum, 1.It can be shown that 1 is the optimal answer.Example 3:Input: nums = [1,2,3,4], x = 3Output: 3Explanation: We can select nums[0] = 1 and nums[3] = 4.They are at least 3 indices apart, and their absolute difference is the minimum, 3.It can be shown that 3 is the optimal answer. Constraints:1 &lt;= nums.length &lt;= 10^51 &lt;= nums[i] &lt;= 10^90 &lt;= x &lt; nums.length &quot;&quot;&quot; | Class Solution:    Def Minabsolutedifference(self, Nums: List[int], X: Int) -&gt; Int:        Nums.sort()        Ans = Float(&#39;inf&#39;)        For I In Range(len(nums)):            J = Bisect_left(nums, Nums[i] + X)            If J &lt; Len(nums):                Ans = Min(ans, Nums[j] - Nums[i])            If I + 1 &lt; Len(nums):                Ans = Min(ans, Nums[i + 1] - Nums[i])        Return Ans | Class Solution:  Def Minabsolutedifference(self, Nums: List[int], X: Int) -&gt; Int:    If X == 0:      Return 0    Arr, Best_dist = Sortedlist([]), Float(&#39;inf&#39;)    For I In Range(x, Len(nums)):      Arr.add(nums[i - X])      V = Nums[i]      Pos = Arr.bisect_left(v)      If Pos &lt; Len(arr):        Best_dist = Min(best_dist, Abs(arr[pos] - V))      If Pos &gt; 0:        Best_dist = Min(best_dist, Abs(arr[pos - 1] - V))        Return Best_dist 
 63 | 3 | C++ | medium | CodeWhisperer | IDE Extension | You are given a 0-indexed integer array nums and an integer x.Find the minimum absolute difference between two elements in the array that are at least x indices apart.In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.Example 1:Input: nums = [4,3,2,4], x = 2Output: 0Explanation: We can select nums[0] = 4 and nums[3] = 4. They are at least 2 indices apart, and their absolute difference is the minimum, 0. It can be shown that 0 is the optimal answer.Example 2:Input: nums = [5,3,2,10,15], x = 1Output: 1Explanation: We can select nums[1] = 3 and nums[2] = 2.They are at least 1 index apart, and their absolute difference is the minimum, 1.It can be shown that 1 is the optimal answer.Example 3:Input: nums = [1,2,3,4], x = 3Output: 3Explanation: We can select nums[0] = 1 and nums[3] = 4.They are at least 3 indices apart, and their absolute difference is the minimum, 3.It can be shown that 3 is the optimal answer. Constraints:1 &lt;= nums.length &lt;= 10^51 &lt;= nums[i] &lt;= 10^90 &lt;= x &lt; nums.length  | class Solution {public:    int minAbsoluteDifference(vector&lt;int&gt;&amp; nums, int x) {/*You are given a 0-indexed integer array nums and an integer x.Find the minimum absolute difference between two elements in the array that are at least x indices apart.In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.Example 1:Input: nums = [4,3,2,4], x = 2Output: 0Explanation: We can select nums[0] = 4 and nums[3] = 4. They are at least 2 indices apart, and their absolute difference is the minimum, 0. It can be shown that 0 is the optimal answer.Example 2:Input: nums = [5,3,2,10,15], x = 1Output: 1Explanation: We can select nums[1] = 3 and nums[2] = 2.They are at least 1 index apart, and their absolute difference is the minimum, 1.It can be shown that 1 is the optimal answer.Example 3:Input: nums = [1,2,3,4], x = 3Output: 3Explanation: We can select nums[0] = 1 and nums[3] = 4.They are at least 3 indices apart, and their absolute difference is the minimum, 3.It can be shown that 3 is the optimal answer. Constraints:1 &lt;= nums.length &lt;= 10^51 &lt;= nums[i] &lt;= 10^90 &lt;= x &lt; nums.length*/ | Class Solution {Public:    Int Minabsolutedifference(vector&lt;int&gt;&amp; Nums, Int X) {        Int N = Nums.size();        Int Ans = Int_max;        For(int I = 0; I &lt; N; I++){            For(int J = I + 1; J &lt; N; J++){                If(abs(nums[i] - Nums[j]) &gt;= X){                    Ans = Min(ans, Abs(nums[i] - Nums[j]));                    Break;                }            }        }        Return Ans;    }}; | Class Solution {Public:    Int Minabsolutedifference(vector&lt;int&gt;&amp; Nums, Int X) {        Int Ans = Int_max;        Set&lt;int&gt; S;        For(int I = X; I &lt; Nums.size(); ++I){            S.insert(nums[i-x]);            Auto It = S.upper_bound(nums[i]);            If(it != S.end()) Ans = Min(ans, Abs(nums[i] - *It));            If(it != S.begin()) Ans = Min(ans, Abs(nums[i] - *Prev(it)));        }        Return Ans;    }}; 
 64 | 4 | Java | medium | CodeWhisperer | IDE Extension | You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.Return the head of the linked list after doubling it.Example 1:Input: head = [1,8,9]Output: [3,7,8]Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.Example 2:Input: head = [9,9,9]Output: [1,9,9,8]Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. Constraints:The number of nodes in the list is in the range [1, 10^4]0 &lt;= Node.val &lt;= 9The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.  | class Solution {    public ListNode doubleIt(ListNode head) {/* *You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.Return the head of the linked list after doubling it.Example 1:Input: head = [1,8,9]Output: [3,7,8]Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.Example 2:Input: head = [9,9,9]Output: [1,9,9,8]Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. Constraints:The number of nodes in the list is in the range [1, 10^4]0 &lt;= Node.val &lt;= 9The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.*/ | Class Solution {    Public Listnode Doubleit(listnode Head) {        Listnode Curr = Head;        While (Curr != Null) {            Curr.val *= 2;            Curr = Curr.next;        }        Return Head;            }    } | Class Solution {    Public Listnode Doubleit(listnode Head) {        If (Head.val &gt; 4)            Head = New Listnode(0, Head);        For(listnode Node = Head; Node != Null; Node = Node.next) {            Node.val = (Node.val * 2) % 10;            If (Node.next != Null &amp;&amp; Node.next.val &gt; 4)                Node.val++;        }        Return Head;    }} 
 65 | 4 | Python | medium | CodeWhisperer | IDE Extension | You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.Return the head of the linked list after doubling it.Example 1:Input: head = [1,8,9]Output: [3,7,8]Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.Example 2:Input: head = [9,9,9]Output: [1,9,9,8]Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. Constraints:The number of nodes in the list is in the range [1, 10^4]0 &lt;= Node.val &lt;= 9The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.  | class Solution:    def doubleIt(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:&quot;&quot;&quot;You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.Return the head of the linked list after doubling it.Example 1:Input: head = [1,8,9]Output: [3,7,8]Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.Example 2:Input: head = [9,9,9]Output: [1,9,9,8]Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. Constraints:The number of nodes in the list is in the range [1, 10^4]0 &lt;= Node.val &lt;= 9The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.&quot;&quot;&quot; | Class Solution:    Def Doubleit(self, Head: Optional[listnode]) -&gt; Optional[listnode]:        If Not Head:            Return Head        If Not Head.next:            Head.val *= 2            Return Head        Prev = Head        Curr = Head.next        While Curr:            Curr.val *= 2            Prev = Curr            Curr = Curr.next        Prev.val *= 2        Return Head | Class Solution:    Def Doubleit(self, Head: Optional[listnode]) -&gt; Optional[listnode]:        If Head.val &gt; 4:            Head = Listnode(0, Head)        Node = Head        While Node:            Node.val = (Node.val * 2) % 10            If Node.next And Node.next.val &gt; 4:                Node.val += 1            Node = Node.next        Return Head 
 66 | 4 | C++ | medium | CodeWhisperer | IDE Extension | You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.Return the head of the linked list after doubling it.Example 1:Input: head = [1,8,9]Output: [3,7,8]Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.Example 2:Input: head = [9,9,9]Output: [1,9,9,8]Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. Constraints:The number of nodes in the list is in the range [1, 10^4]0 &lt;= Node.val &lt;= 9The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.  | /*You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.Return the head of the linked list after doubling it.Example 1:Input: head = [1,8,9]Output: [3,7,8]Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.Example 2:Input: head = [9,9,9]Output: [1,9,9,8]Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. Constraints:The number of nodes in the list is in the range [1, 10^4]0 &lt;= Node.val &lt;= 9The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.*//** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) {} *     ListNode(int x) : val(x), next(nullptr) {} *     ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public:    ListNode* doubleIt(ListNode* head) { | Class Solution {Public:    Listnode* Doubleit(listnode* Head) {        If(head == Null)            Return Null;        Listnode* Temp = Head;        While(temp-&gt;next != Null){            Temp-&gt;val *= 2;            Temp = Temp-&gt;next;            If(temp-&gt;next != Null) {                Temp-&gt;val *= 2;                Temp = Temp-&gt;next;                Continue;            }            Else {                Break;            }        }        Return Head;    }}; | Class Solution {Public:    Listnode* Doubleit(listnode* Head) {        If (Head-&gt;val &gt; 4)            Head = New Listnode(0, Head);        For(listnode* Node = Head; Node; Node = Node-&gt;next) {            Node-&gt;val = (Node-&gt;val * 2) % 10;            If (Node-&gt;next &amp;&amp; Node-&gt;next-&gt;val &gt; 4)                Node-&gt;val++;        }        Return Head;    }}; 
 67 | 5 | Java | hard | CodeWhisperer | IDE Extension | You are given an array nums of n positive integers and an integer k.Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.Multiply your score by x.Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.Return the maximum possible score after applying at most k operations.Since the answer may be large, return it modulo 10^9 + 7.Example 1:Input: nums = [8,3,9,3,8], k = 2Output: 81Explanation: To get a score of 81, we can apply the following operations:- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.It can be proven that 81 is the highest score one can obtain.Example 2:Input: nums = [19,12,14,6,10,18], k = 3Output: 4788Explanation: To get a score of 4788, we can apply the following operations: - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.It can be proven that 4788 is the highest score one can obtain. Constraints:1 &lt;= nums.length == n &lt;= 10^51 &lt;= nums[i] &lt;= 10^51 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9)  | public class Solution {    public int maximumScore(List&lt;Integer&gt; nums, int k) {/*You are given an array nums of n positive integers and an integer k.Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.Multiply your score by x.Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.Return the maximum possible score after applying at most k operations.Since the answer may be large, return it modulo 10^9 + 7.Example 1:Input: nums = [8,3,9,3,8], k = 2Output: 81Explanation: To get a score of 81, we can apply the following operations:- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.It can be proven that 81 is the highest score one can obtain.Example 2:Input: nums = [19,12,14,6,10,18], k = 3Output: 4788Explanation: To get a score of 4788, we can apply the following operations: - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.It can be proven that 4788 is the highest score one can obtain. Constraints:1 &lt;= nums.length == n &lt;= 10^51 &lt;= nums[i] &lt;= 10^51 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9).*/ | Public Class Solution {    Public Int Maximumscore(list&lt;integer&gt; Nums, Int K) {        Int N = Nums.size();        Int[] Primes = New Int[n];        For (Int I = 0; I &lt; N; I++) {            Primes[i] = Primefactors(nums.get(i));            If (Primes[i] == 0) Primes[i] = 1;            //System.out.println(primes[i]);        }        Int[][] Dp = New Int[n][k + 1];        For (Int I = 0; I &lt; N; I++) {            Dp[i][0] = 1;        }        For (Int I = 1; I &lt;= K; I++) {            For (Int J = 0; J &lt; N; J++) {                Dp[j][i] = Math.max(dp[j][i - 1], Dp[j - 1][i - 1] * Primes[j]);            }        }        Return Dp[n - 1][k];            }        Public Int Primefactors(int N) {        Int Count = 0;        For (Int I = 2; I &lt;= N / I; I++) {            While (N % I == 0) {                N /= I;                Count++;            }        }        If (N &gt; 1) Count++;        Return Count;    }    } | Class Solution {    Static Final Int Mod = 1000000007;    Public Int Maximumscore(list&lt;integer&gt; Nums, Int K) {        Int N = Nums.size();        Int Upper = Collections.max(nums) + 1;        Boolean[] Prime = New Boolean[upper];        Int[] Primescore = New Int[upper];        Arrays.fill(prime, True);        Prime[0] = Prime[1] = False;        For (Int I = 2; I &lt; Upper; I++) {            If (Prime[i]) {                For (Int J = I; J &lt; Upper; J += I) {                    Primescore[j]++;                    Prime[j] = False;                }            }        }        Int[] Nextgreaterelement = New Int[n];        Arrays.fill(nextgreaterelement, N);        Stack&lt;integer&gt; S = New Stack&lt;&gt;();        For (Int I = N - 1; I &gt;= 0; I--) {            While (!S.empty() &amp;&amp; Primescore[nums.get(i)] &gt;= Primescore[nums.get(s.peek())]) {                S.pop();            }            Nextgreaterelement[i] = S.empty() ? N : S.peek();            S.push(i);        }        Int[] Prevgreaterorequalelement = New Int[n];        Arrays.fill(prevgreaterorequalelement, -1);        S = New Stack&lt;&gt;();        For (Int I = 0; I &lt; N; I++) {            While (!S.empty() &amp;&amp; Primescore[nums.get(i)] &gt; Primescore[nums.get(s.peek())]) {                S.pop();            }            Prevgreaterorequalelement[i] = S.empty() ? -1 : S.peek();            S.push(i);        }        Int Res = 1;        Int[][] Tuples = New Int[n][2];        For (Int I = 0; I &lt; N; I++) {            Tuples[i][0] = Nums.get(i);            Tuples[i][1] = I;        }        Arrays.sort(tuples, New Comparator&lt;int[]&gt;() {            Public Int Compare(int[] A, Int[] B) {                Return B[0] - A[0];            }        });        For (Int I = 0; I &lt; N; I++) {            Int Num = Tuples[i][0];            Int Idx = Tuples[i][1];            Int Operations = Math.min((idx - Prevgreaterorequalelement[idx]) * (Nextgreaterelement[idx] - Idx), K);            Res = (Int)((1l * Res * Pow(num, Operations)) % Mod);            K -= Operations;            If (K == 0) {                Return Res;            }        }        Return Res;    }    Public Int Pow(int X, Int N) {        Int Res = 1;        While (N &gt; 0) {            If (N % 2 == 1) {                Res = (Int)((1l * Res * X) % Mod);            }            X = (Int)((1l * X * X) % Mod);            N /= 2;        }        Return Res;    }} 
 68 | 5 | Python | hard | CodeWhisperer | IDE Extension | You are given an array nums of n positive integers and an integer k.Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.Multiply your score by x.Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.Return the maximum possible score after applying at most k operations.Since the answer may be large, return it modulo 10^9 + 7.Example 1:Input: nums = [8,3,9,3,8], k = 2Output: 81Explanation: To get a score of 81, we can apply the following operations:- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.It can be proven that 81 is the highest score one can obtain.Example 2:Input: nums = [19,12,14,6,10,18], k = 3Output: 4788Explanation: To get a score of 4788, we can apply the following operations: - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.It can be proven that 4788 is the highest score one can obtain. Constraints:1 &lt;= nums.length == n &lt;= 10^51 &lt;= nums[i] &lt;= 10^51 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9)  | class Solution:    def maximumScore(self, nums: List[int], k: int) -&gt; int:&quot;&quot;&quot;You are given an array nums of n positive integers and an integer k.Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.Multiply your score by x.Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.Return the maximum possible score after applying at most k operations.Since the answer may be large, return it modulo 10^9 + 7.Example 1:Input: nums = [8,3,9,3,8], k = 2Output: 81Explanation: To get a score of 81, we can apply the following operations:- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.It can be proven that 81 is the highest score one can obtain.Example 2:Input: nums = [19,12,14,6,10,18], k = 3Output: 4788Explanation: To get a score of 4788, we can apply the following operations: - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.It can be proven that 4788 is the highest score one can obtain. Constraints:1 &lt;= nums.length == n &lt;= 10^51 &lt;= nums[i] &lt;= 10^51 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9) &quot;&quot;&quot; | Class Solution:    Def Maximumscore(self, Nums: List[int], K: Int) -&gt; Int:        Def Prime(n):            If N == 1:                Return False            For I In Range(2, Int(n**0.5)+1):                If N % I == 0:                    Return False            Return True        Ans = 1        For I In Range(k, -1, -1):            If Prime(nums[i]):                Ans *= Nums[i]        For I In Range(k+1, Len(nums)):            If Prime(nums[i]):                Ans *= Nums[i]        Return Ans % (10**9 + 7) | Class Solution:     Mod = 1000000007    Def Maximumscore(self, Nums: List[int], K: Int) -&gt; Int:        N = Len(nums)        Upper = Max(nums) + 1        Prime = [True]*upper        Prime[0] = Prime[1] = False        Primescore = [0]*upper        For I In Range(2, Upper):            If Prime[i]:                For J In Range(i, Upper, I):                    Primescore[j] += 1                    Prime[j] = False        Nextgreaterelement = [N]*n        S = []        For I In Range(n - 1, -1, -1):            While S And Primescore[nums[i]] &gt;= Primescore[nums[s[-1]]]:                S.pop()            Nextgreaterelement[i] = S[-1] If S Else N            S.append(i)        Prevgreaterorequalelement = [-1]*n        S = []        For I In Range(n):            While S And Primescore[nums[i]] &gt; Primescore[nums[s[-1]]]:                S.pop()            Prevgreaterorequalelement[i] = S[-1] If S Else -1            S.append(i)        Res = 1        Tuples = [[Nums[i], I] For I In Range(n)]        Tuples.sort(reverse=true)        For Num, Idx In Tuples:            Operations = Min((idx - Prevgreaterorequalelement[idx]) * (Nextgreaterelement[idx] - Idx), K)            Res = (Res * Self.pow(num, Operations)) % Self.mod            K -= Operations            If K == 0:                Return Res        Return Res    Def Pow(self, X: Int, N: Int) -&gt; Int:        Res = 1        While N &gt; 0:            If N % 2 == 1:                Res = (Res * X) % Self.mod            X = (X * X) % Self.mod            N //= 2        Return Res 
 69 | 5 | C++ | hard | CodeWhisperer | IDE Extension | You are given an array nums of n positive integers and an integer k.Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.Multiply your score by x.Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.Return the maximum possible score after applying at most k operations.Since the answer may be large, return it modulo 10^9 + 7.Example 1:Input: nums = [8,3,9,3,8], k = 2Output: 81Explanation: To get a score of 81, we can apply the following operations:- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.It can be proven that 81 is the highest score one can obtain.Example 2:Input: nums = [19,12,14,6,10,18], k = 3Output: 4788Explanation: To get a score of 4788, we can apply the following operations: - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.It can be proven that 4788 is the highest score one can obtain. Constraints:1 &lt;= nums.length == n &lt;= 10^51 &lt;= nums[i] &lt;= 10^51 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9)  | class Solution {public:    int maximumScore(vector&lt;int&gt;&amp; nums, int k) {/*You are given an array nums of n positive integers and an integer k.Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.Multiply your score by x.Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.Return the maximum possible score after applying at most k operations.Since the answer may be large, return it modulo 10^9 + 7.Example 1:Input: nums = [8,3,9,3,8], k = 2Output: 81Example 2:Input: nums = [19,12,14,6,10,18], k = 3Output: 4788 Constraints:1 &lt;= nums.length == n &lt;= 10^51 &lt;= nums[i] &lt;= 10^51 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9) */ | Class Solution {Public:    Int Maximumscore(vector&lt;int&gt;&amp; Nums, Int K) {        Int N = Nums.size();        Int L = K, R = K;        Int Score = 1;        Int Ans = 0;        While(l &gt;= 0 || R &lt; N){            If(l &lt; 0){                Score *= Nums[r++];                Ans = Max(ans, Score);                Continue;            }            If(r == N){                Score *= Nums[l--];                Ans = Max(ans, Score);                Continue;            }            If(nums[l] &lt; Nums[r]){                Score *= Nums[l--];                Ans = Max(ans, Score);            }            Else{                Score *= Nums[r++];                Ans = Max(ans, Score);            }        }        Return Ans;    }}; | Class Solution {Public:    Const Int Mod = 1000000007;    Int Maximumscore(vector&lt;int&gt;&amp; Nums, Int K) {        Int N = Nums.size();        Int Upper = *Max_element(nums.begin(), Nums.end()) + 1;        Vector&lt;bool&gt; Prime(upper, True);        Prime[0] = Prime[1] = False;        Vector&lt;int&gt; Primescore(upper, 0);        For (Int I = 2; I &lt; Upper; I++) {            If (Prime[i]) {                For (Int J = I; J &lt; Upper; J += I) {                    Primescore[j]++;                    Prime[j] = False;                }            }        }        Vector&lt;int&gt; Nextgreaterelement(n, N);        Stack&lt;int&gt; S;        For (Int I = N - 1; I &gt;= 0; I--) {            While (!S.empty() &amp;&amp; Primescore[nums[i]] &gt;= Primescore[nums[s.top()]]) {                S.pop();            }            Nextgreaterelement[i] = S.empty() ? N : S.top();            S.push(i);        }        Vector&lt;int&gt; Prevgreaterorequalelement(n, -1);        S = Stack&lt;int&gt;();        For (Int I = 0; I &lt; N; I++) {            While (!S.empty() &amp;&amp; Primescore[nums[i]] &gt; Primescore[nums[s.top()]]) {                S.pop();            }            Prevgreaterorequalelement[i] = S.empty() ? -1 : S.top();            S.push(i);        }        Int Res = 1;        Vector&lt;pair&lt;int, Int&gt;&gt; Tuples(n);        For (Int I = 0; I &lt; N; I++) {            Tuples[i].first = Nums[i];            Tuples[i].second = I;        }        Sort(tuples.rbegin(), Tuples.rend());        For (Const Auto&amp; [Num, I] : Tuples) {            Int Operations = Min((i - Prevgreaterorequalelement[i]) * (Nextgreaterelement[i] - I), K);            Res = (Int)((1l * Res * Pow(num, Operations)) % Mod);            K -= Operations;            If (K == 0) {                Return Res;            }        }        Return Res;    }    Int Pow(int X, Int N) {        Int Res = 1;        While (N &gt; 0) {            If (N % 2 == 1) {                Res = (Int)((1l * Res * X) % Mod);            }            X = (Int)((1l * X * X) % Mod);            N /= 2;        }        Return Res;    }}; 
 70 | 6 | Java | hard | CodeWhisperer | IDE Extension | You are given a 0-indexed 2D integer array items of length n and an integer k.items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.Your task is to find the maximum elegance from all subsequences of size k in items.Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.Example 1:Input: items = [[3,2],[5,1],[10,1]], k = 2Output: 17Explanation: In this example, we have to select a subsequence of size 2.We can select items[0] = [3,2] and items[2] = [10,1].The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. Example 2:Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3Output: 19Explanation: In this example, we have to select a subsequence of size 3. We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.Example 3:Input: items = [[1,1],[2,1],[3,1]], k = 3Output: 7Explanation: In this example, we have to select a subsequence of size 3. We should select all the items. The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. Hence, the maximum elegance is 6 + 1^2 = 7.   Constraints:1 &lt;= items.length == n &lt;= 10^5items[i].length == 2items[i][0] == profit_iitems[i][1] == category_i1 &lt;= profit_i &lt;= 10^91 &lt;= category_i &lt;= n 1 &lt;= k &lt;= n  | public class Solution {    public int findMaximumElegance(int[][] items, int k) {/* * You are given a 0-indexed 2D integer array items of length n and an integer k.items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.Your task is to find the maximum elegance from all subsequences of size k in items.Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.Example 1:Input: items = [[3,2],[5,1],[10,1]], k = 2Output: 17Explanation: In this example, we have to select a subsequence of size 2.We can select items[0] = [3,2] and items[2] = [10,1].The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. Example 2:Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3Output: 19Explanation: In this example, we have to select a subsequence of size 3. We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.Example 3:Input: items = [[1,1],[2,1],[3,1]], k = 3Output: 7Explanation: In this example, we have to select a subsequence of size 3. We should select all the items. The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. Hence, the maximum elegance is 6 + 1^2 = 7.   Constraints:1 &lt;= items.length == n &lt;= 10^5items[i].length == 2items[i][0] == profit_iitems[i][1] == category_i1 &lt;= profit_i &lt;= 10^91 &lt;= category_i &lt;= n 1 &lt;= k &lt;= n*/ | Public Class Solution {    Public Int Findmaximumelegance(int[][] Items, Int K) {        Int N = Items.length;        Int[] Category = New Int[n];        For (Int I = 0; I &lt; N; I++) {            Category[i] = Items[i][1];        }        Int[] Count = New Int[n + 1];        For (Int I = 0; I &lt; N; I++) {            Count[category[i]]++;        }        For (Int I = 1; I &lt;= N; I++) {            Count[i] += Count[i - 1];        }        Int[] Dp = New Int[n + 1];        For (Int I = 0; I &lt; N; I++) {            Int Index = Count[category[i]];            Dp[index] = Math.max(dp[index], Dp[index - 1] + Items[i][0]);        }        Return Dp[n];            }} | Class Solution {    Public Long Findmaximumelegance(int[][] A, Int K) {        Arrays.sort(a, (A, B) -&gt; B[0] - A[0]);        Long Res = 0, Cur = 0;        List&lt;integer&gt; Dup = New Arraylist&lt;&gt;();        Set&lt;integer&gt; Seen = New Hashset&lt;&gt;();        For (Int I = 0; I &lt; A.length; ++I) {            If (I &lt; K) {                If (Seen.contains(a[i][1])) {                    Dup.add(a[i][0]);                }                Cur += A[i][0];            } Else If (!Seen.contains(a[i][1])) {                If (Dup.isempty()) Break;                Cur += A[i][0] - Dup.remove(dup.size() - 1);            }            Seen.add(a[i][1]);            Res = Math.max(res, Cur + 1l * Seen.size() * Seen.size());        }        Return Res;    }} 
 71 | 6 | Python | hard | CodeWhisperer | IDE Extension | You are given a 0-indexed 2D integer array items of length n and an integer k.items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.Your task is to find the maximum elegance from all subsequences of size k in items.Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.Example 1:Input: items = [[3,2],[5,1],[10,1]], k = 2Output: 17Explanation: In this example, we have to select a subsequence of size 2.We can select items[0] = [3,2] and items[2] = [10,1].The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. Example 2:Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3Output: 19Explanation: In this example, we have to select a subsequence of size 3. We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.Example 3:Input: items = [[1,1],[2,1],[3,1]], k = 3Output: 7Explanation: In this example, we have to select a subsequence of size 3. We should select all the items. The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. Hence, the maximum elegance is 6 + 1^2 = 7.   Constraints:1 &lt;= items.length == n &lt;= 10^5items[i].length == 2items[i][0] == profit_iitems[i][1] == category_i1 &lt;= profit_i &lt;= 10^91 &lt;= category_i &lt;= n 1 &lt;= k &lt;= n  | class Solution:    def findMaximumElegance(self, items: List[List[int]], k: int) -&gt; int:&quot;&quot;&quot;You are given a 0-indexed 2D integer array items of length n and an integer k.items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.Your task is to find the maximum elegance from all subsequences of size k in items.Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.Example 1:Input: items = [[3,2],[5,1],[10,1]], k = 2Output: 17Explanation: In this example, we have to select a subsequence of size 2.We can select items[0] = [3,2] and items[2] = [10,1].The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. Example 2:Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3Output: 19Explanation: In this example, we have to select a subsequence of size 3. We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.Example 3:Input: items = [[1,1],[2,1],[3,1]], k = 3Output: 7Explanation: In this example, we have to select a subsequence of size 3. We should select all the items. The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. Hence, the maximum elegance is 6 + 1^2 = 7.   Constraints:1 &lt;= items.length == n &lt;= 10^5items[i].length == 2items[i][0] == profit_iitems[i][1] == category_i1 &lt;= profit_i &lt;= 10^91 &lt;= category_i &lt;= n 1 &lt;= k &lt;= n &quot;&quot;&quot; | Class Solution:    Def Findmaximumelegance(self, Items: List[list[int]], K: Int) -&gt; Int:        Items.sort(key = Lambda X: X[1])        Ans = 0        For I In Range(k):            Ans += Items[i][0]        Return Ans + (K * (K - 1) // 2) * Items[k - 1][1] | Class Solution:    Def Findmaximumelegance(self, Items: List[list[int]], K: Int) -&gt; Int:        Items = Sorted(items, Key=lambda V: -V[0])        Res = Cur = 0        A = []        Seen = Set()        For I, (P, C) In Enumerate(items):            If I &lt; K:                If C In Seen:                    A.append(p)                Cur += P            Elif C Not In Seen:                If Not A: Break                Cur += P - A.pop()            Seen.add(c)            Res = Max(res, Cur + Len(seen) * Len(seen))        Return Res 
 72 | 6 | C++ | hard | CodeWhisperer | IDE Extension | You are given a 0-indexed 2D integer array items of length n and an integer k.items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.Your task is to find the maximum elegance from all subsequences of size k in items.Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.Example 1:Input: items = [[3,2],[5,1],[10,1]], k = 2Output: 17Explanation: In this example, we have to select a subsequence of size 2.We can select items[0] = [3,2] and items[2] = [10,1].The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. Example 2:Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3Output: 19Explanation: In this example, we have to select a subsequence of size 3. We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.Example 3:Input: items = [[1,1],[2,1],[3,1]], k = 3Output: 7Explanation: In this example, we have to select a subsequence of size 3. We should select all the items. The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. Hence, the maximum elegance is 6 + 1^2 = 7.   Constraints:1 &lt;= items.length == n &lt;= 10^5items[i].length == 2items[i][0] == profit_iitems[i][1] == category_i1 &lt;= profit_i &lt;= 10^91 &lt;= category_i &lt;= n 1 &lt;= k &lt;= n  | /*You are given a 0-indexed 2D integer array items of length n and an integer k.items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.Your task is to find the maximum elegance from all subsequences of size k in items.Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.Example 1:Input: items = [[3,2],[5,1],[10,1]], k = 2Output: 17Explanation: In this example, we have to select a subsequence of size 2.We can select items[0] = [3,2] and items[2] = [10,1].The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. Example 2:Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3Output: 19Explanation: In this example, we have to select a subsequence of size 3. We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.Example 3:Input: items = [[1,1],[2,1],[3,1]], k = 3Output: 7Explanation: In this example, we have to select a subsequence of size 3. We should select all the items. The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. Hence, the maximum elegance is 6 + 1^2 = 7.  Constraints:1 &lt;= items.length == n &lt;= 10^5items[i].length == 2items[i][0] == profit_iitems[i][1] == category_i1 &lt;= profit_i &lt;= 10^91 &lt;= category_i &lt;= n 1 &lt;= k &lt;= n*/class Solution {public:    long long findMaximumElegance(vector&lt;vector&lt;int&gt;&gt;&amp; items, int k) { | Class Solution {Public:    Long Long Findmaximumelegance(vector&lt;vector&lt;int&gt;&gt;&amp; Items, Int K) {        Int N=items.size();        Vector&lt;long Long&gt;profit(n);        Vector&lt;long Long&gt;category(n);        For(int I=0;i&lt;n;i++){            Profit[i]=items[i][0];            Category[i]=items[i][1];        }        Sort(profit.begin(),profit.end());        Sort(category.begin(),category.end());        Long Long Ans=0;        Long Long Max_profit=0;        Long Long Max_category=0;        For(int I=0;i&lt;n;i++){            If(i&lt;k){                Max_profit+=profit[i];                Max_category+=category[i];                Ans=max(ans,max_profit+max_category*max_category);                Continue;            }            Max_profit-=profit[i-k];            Max_profit+=profit[i];            Max_category-=category[i-k];            Max_category+=category[i];            Ans=max(ans,max_profit+max_category*max_category);        }        Return Ans;    }}; | Class Solution {Public:    Long Long Findmaximumelegance(vector&lt;vector&lt;int&gt;&gt;&amp; A, Int K) {        Sort(a.begin(), A.end(), [](Const Vector&lt;int&gt;&amp; A, Const Vector&lt;int&gt;&amp; B) {            Return A[0] &gt; B[0];        });        Long Long Res = 0, Cur = 0;        Vector&lt;int&gt; Dup;        Unordered_set&lt;int&gt; Seen;        For (Int I = 0; I &lt; A.size(); ++I) {            If (I &lt; K) {                If (Seen.count(a[i][1])) {                    Dup.push_back(a[i][0]);                }                Cur += A[i][0];            } Else If (Seen.find(a[i][1]) == Seen.end()) {                If (Dup.empty()) Break;                Cur += A[i][0] - Dup.back();                Dup.pop_back();            }            Seen.insert(a[i][1]);            Res = Fmax(res, Cur + 1l * Seen.size() * Seen.size());        }        Return Res;    }}; 
 73 | 1 | Java | easy | GitHub Copilot | IDE Extension | You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.Return the maximum sum or -1 if no such pair exists.Example 1:Input: nums = [51,71,17,24,42]Output: 88Explanation: For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.Example 2:Input: nums = [1,2,3,4]Output: -1Explanation: No pair exists in nums with equal maximum digits.Constraints:2 &lt;= nums.length &lt;= 1001 &lt;= nums[i] &lt;= 10^4  | public class Solution {    public int maxSum(int[] nums) {        /*         * You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.Return the maximum sum or -1 if no such pair exists.Example 1:Input: nums = [51,71,17,24,42]Output: 88Explanation: For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.Example 2:Input: nums = [1,2,3,4]Output: -1Explanation: No pair exists in nums with equal maximum digits.Constraints:2 &lt;= nums.length &lt;= 1001 &lt;= nums[i] &lt;= 10^4         */ | Public Class Solution {    Public Int Maxsum(int[] Nums) {        Int Max = -1;        For(int I = 0; I &lt; Nums.length; I++){            For(int J = I+1; J &lt; Nums.length;j++){                If(max &lt; Nums[i] + Nums[j] &amp;&amp; Maxdigit(nums[i]) == Maxdigit(nums[j])){                    Max = Nums[i] + Nums[j];                }            }        }        Return Max;    }    Public Int Maxdigit(int Num){        Int Max = 0;        While(num &gt; 0){            Max = Math.max(max, Num % 10);            Num /= 10;        }        Return Max;    }} | Class Solution {    Public Int Maxsum(int[] Nums) {    Int Ans = -1;    Map&lt;integer,list&lt;integer&gt;&gt; Ump = New Hashmap&lt;&gt;();    For(int I = 0; I &lt; Nums.length; ++I){        Int T = Nums[i], Maxdigit = 0;        While(t != 0){ //Evaluate Max Digit In The Number            Maxdigit = Math.max(t%10, Maxdigit);            T = T/10;        }        If(!ump.containskey(maxdigit)) Ump.put(maxdigit, New Arraylist&lt;&gt;());        Ump.get(maxdigit).add(nums[i]); // Add The Number To The Map     }    For(map.entry&lt;integer, List&lt;integer&gt;&gt; Entry: Ump.entryset()){        Entry.getvalue().sort(comparator.reverseorder()); //To Find Max Two Number In Each Max Digit         If(entry.getvalue().size() &gt;= 2) Ans = Math.max(ans, Entry.getvalue().get(0) + Entry.getvalue().get(1)); //Sum Max Two Number And Take Max    }    Return Ans;    }} 
 74 | 1 | Python | easy | GitHub Copilot | IDE Extension | You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.Return the maximum sum or -1 if no such pair exists.Example 1:Input: nums = [51,71,17,24,42]Output: 88Explanation: For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.Example 2:Input: nums = [1,2,3,4]Output: -1Explanation: No pair exists in nums with equal maximum digits.Constraints:2 &lt;= nums.length &lt;= 1001 &lt;= nums[i] &lt;= 10^4  | class Solution:    def maxSum(self, nums: List[int]) -&gt; int:&quot;&quot;&quot;You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.Return the maximum sum or -1 if no such pair exists.Example 1:Input: nums = [51,71,17,24,42]Output: 88Explanation: For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.Example 2:Input: nums = [1,2,3,4]Output: -1Explanation: No pair exists in nums with equal maximum digits.Constraints:2 &lt;= nums.length &lt;= 1001 &lt;= nums[i] &lt;= 10^4&quot;&quot;&quot; | Class Solution:    Def Maxsum(self, Nums: List[int]) -&gt; Int:        Maxsum = -1        Maxdigit = [0] * 10        For Num In Nums:            Maxdigit[int(str(num)[0])] = Max(maxdigit[int(str(num)[0])], Num)        For I In Range(10):                        For J In Range(i, 10):                If Maxdigit[i] And Maxdigit[j]:                    Maxsum = Max(maxsum, Maxdigit[i] + Maxdigit[j])        Return Maxsum | Class Solution:    Def Maxsum(self, Nums: List[int]) -&gt; Int:        Max_by_digit = Defaultdict(int)        Max_sum = -1        For Num In Nums:            Digit = Max(str(num))            If Digit In Max_by_digit:                Max_sum = Max(max_sum, Max_by_digit[digit] + Num)            Max_by_digit[digit] = Max(max_by_digit[digit], Num)        Return Max_sum 
 75 | 1 | C++ | easy | GitHub Copilot | IDE Extension | You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.Return the maximum sum or -1 if no such pair exists.Example 1:Input: nums = [51,71,17,24,42]Output: 88Explanation: For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.Example 2:Input: nums = [1,2,3,4]Output: -1Explanation: No pair exists in nums with equal maximum digits.Constraints:2 &lt;= nums.length &lt;= 1001 &lt;= nums[i] &lt;= 10^4  | class Solution {public:    int maxSum(vector&lt;int&gt;&amp; nums) {/*You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.Return the maximum sum or -1 if no such pair exists.Example 1:Input: nums = [51,71,17,24,42]Output: 88Example 2:Input: nums = [1,2,3,4]Output: -1Constraints:2 &lt;= nums.length &lt;= 1001 &lt;= nums[i] &lt;= 10^4*/ | Class Solution {Public:    Int Maxsum(vector&lt;int&gt;&amp; Nums) {        Int N = Nums.size();        Int Maxsum = -1;        Unordered_map&lt;int, Int&gt; Mp;        For(int I = 0; I &lt; N; I++) {            Int Maxdigit = 0;            Int Temp = Nums[i];            While(temp) {                Maxdigit = Max(maxdigit, Temp % 10);                Temp /= 10;            }            If(mp.find(maxdigit) != Mp.end()) {                Maxsum = Max(maxsum, Mp[maxdigit] + Nums[i]);                Mp[maxdigit] = Max(mp[maxdigit], Nums[i]);            } Else {                Mp[maxdigit] = Nums[i];            }        }        Return Maxsum;    }}; | Class Solution {    Public:        Int Maxsum(vector&lt;int&gt;&amp; Nums) {        Int Res = -1, Max_num[10] = {};        For (Auto Num : Nums) {            Int Max_d = 0;            For (Int V = Num; V; V /= 10)                Max_d = Max(max_d, V % 10);            If (Max_num[max_d])                Res = Max(res, Max_num[max_d] + Num);            Max_num[max_d] = Max(max_num[max_d], Num);        }        Return Res;    }}; 
 76 | 2 | Java | easy | GitHub Copilot | IDE Extension | Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.Return the final string that will be present on your laptop screen.Example 1:Input: s = &quot;string&quot;Output: &quot;rtsng&quot;Explanation: After typing first character, the text on the screen is &quot;s&quot;.After the second character, the text is &quot;st&quot;. After the third character, the text is &quot;str&quot;.Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.After the fifth character, the text is &quot;rtsn&quot;. After the sixth character, the text is &quot;rtsng&quot;. Therefore, we return &quot;rtsng&quot;.Example 2:Input: s = &quot;poiinter&quot;Output: &quot;ponter&quot;Explanation: After the first character, the text on the screen is &quot;p&quot;.After the second character, the text is &quot;po&quot;. Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.After the fifth character, the text is &quot;pon&quot;.After the sixth character, the text is &quot;pont&quot;. After the seventh character, the text is &quot;ponte&quot;. After the eighth character, the text is &quot;ponter&quot;. Therefore, we return &quot;ponter&quot;. Constraints:1 &lt;= s.length &lt;= 100s consists of lowercase English letters.s[0] != &#39;i&#39; | public class Solution {    public String finalString(String s) {        /*         * Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.Return the final string that will be present on your laptop screen.Constraints:1 &lt;= s.length &lt;= 100s consists of lowercase English letters.s[0] != &#39;i&#39;*/ | Public Class Solution {    Public String Finalstring(string S) {        Stringbuilder Sb = New Stringbuilder();        For (Int I = 0; I &lt; S.length(); I++) {            If (S.charat(i) == &#39;I&#39;) {                Sb.reverse();            } Else {                Sb.append(s.charat(i));            }        }        Return Sb.tostring();    }} | Class Solution {    Public String Finalstring(string S) {        Stringbuilder Nm=new Stringbuilder();        For(char C:s.tochararray())        {            If(c==&#39;i&#39;)            {                Nm.reverse();            }            Else            {                Nm.append(c);            }        }        Return Nm.tostring();    }} 
 77 | 2 | Python | easy | GitHub Copilot | IDE Extension | Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.Return the final string that will be present on your laptop screen.Example 1:Input: s = &quot;string&quot;Output: &quot;rtsng&quot;Explanation: After typing first character, the text on the screen is &quot;s&quot;.After the second character, the text is &quot;st&quot;. After the third character, the text is &quot;str&quot;.Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.After the fifth character, the text is &quot;rtsn&quot;. After the sixth character, the text is &quot;rtsng&quot;. Therefore, we return &quot;rtsng&quot;.Example 2:Input: s = &quot;poiinter&quot;Output: &quot;ponter&quot;Explanation: After the first character, the text on the screen is &quot;p&quot;.After the second character, the text is &quot;po&quot;. Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.After the fifth character, the text is &quot;pon&quot;.After the sixth character, the text is &quot;pont&quot;. After the seventh character, the text is &quot;ponte&quot;. After the eighth character, the text is &quot;ponter&quot;. Therefore, we return &quot;ponter&quot;. Constraints:1 &lt;= s.length &lt;= 100s consists of lowercase English letters.s[0] != &#39;i&#39; | class Solution:    def finalString(self, s: str) -&gt; str:&quot;&quot;&quot;You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.Return the final string that will be present on your laptop screen.Example 1:Input: s = &quot;string&quot;Output: &quot;rtsng&quot;Explanation: After typing first character, the text on the screen is &quot;s&quot;.After the second character, the text is &quot;st&quot;. After the third character, the text is &quot;str&quot;.Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.After the fifth character, the text is &quot;rtsn&quot;. After the sixth character, the text is &quot;rtsng&quot;. Therefore, we return &quot;rtsng&quot;.Example 2:Input: s = &quot;poiinter&quot;Output: &quot;ponter&quot;Explanation: After the first character, the text on the screen is &quot;p&quot;.After the second character, the text is &quot;po&quot;. Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.After the fifth character, the text is &quot;pon&quot;.After the sixth character, the text is &quot;pont&quot;. After the seventh character, the text is &quot;ponte&quot;. After the eighth character, the text is &quot;ponter&quot;. Therefore, we return &quot;ponter&quot;. Constraints:1 &lt;= s.length &lt;= 100s consists of lowercase English letters.s[0] != &#39;i&#39;&quot;&quot;&quot; | Class Solution:    Def Finalstring(self, S: Str) -&gt; Str:        Stack = []        For I In Range(len(s)):            If S[i] == &#39;I&#39;:                Stack.reverse()            Else:                Stack.append(s[i])        Return &quot;&quot;.Join(stack) | Class Solution:    Def Finalstring(self, S: Str) -&gt; Str:        While &quot;I&quot; In S:            Index=s.index(&quot;i&quot;)            #First Half And Second Half            First=s[:index][::-1]            Second=s[index+1:]            S=&quot;&quot;.join([first,second])        Return S 
 78 | 2 | C++ | easy | GitHub Copilot | IDE Extension | Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.Return the final string that will be present on your laptop screen.Example 1:Input: s = &quot;string&quot;Output: &quot;rtsng&quot;Explanation: After typing first character, the text on the screen is &quot;s&quot;.After the second character, the text is &quot;st&quot;. After the third character, the text is &quot;str&quot;.Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.After the fifth character, the text is &quot;rtsn&quot;. After the sixth character, the text is &quot;rtsng&quot;. Therefore, we return &quot;rtsng&quot;.Example 2:Input: s = &quot;poiinter&quot;Output: &quot;ponter&quot;Explanation: After the first character, the text on the screen is &quot;p&quot;.After the second character, the text is &quot;po&quot;. Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.After the fifth character, the text is &quot;pon&quot;.After the sixth character, the text is &quot;pont&quot;. After the seventh character, the text is &quot;ponte&quot;. After the eighth character, the text is &quot;ponter&quot;. Therefore, we return &quot;ponter&quot;. Constraints:1 &lt;= s.length &lt;= 100s consists of lowercase English letters.s[0] != &#39;i&#39; | class Solution {public:    string finalString(string s) {/*You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.Return the final string that will be present on your laptop screen.Example 1:Input: s = &quot;string&quot;Output: &quot;rtsng&quot;Explanation: After typing first character, the text on the screen is &quot;s&quot;.After the second character, the text is &quot;st&quot;. After the third character, the text is &quot;str&quot;.Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.After the fifth character, the text is &quot;rtsn&quot;. After the sixth character, the text is &quot;rtsng&quot;. Therefore, we return &quot;rtsng&quot;.Example 2:Input: s = &quot;poiinter&quot;Output: &quot;ponter&quot;Explanation: After the first character, the text on the screen is &quot;p&quot;.After the second character, the text is &quot;po&quot;. Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.After the fifth character, the text is &quot;pon&quot;.After the sixth character, the text is &quot;pont&quot;. After the seventh character, the text is &quot;ponte&quot;. After the eighth character, the text is &quot;ponter&quot;. Therefore, we return &quot;ponter&quot;. Constraints:1 &lt;= s.length &lt;= 100s consists of lowercase English letters.s[0] != &#39;i&#39;*/ | Class Solution {Public:    String Finalstring(string S) {        String Ans = &quot;&quot;;        Int N = S.length();        Int I = 0;        While(i &lt; N) {            If(s[i] == &#39;I&#39;) {                Reverse(ans.begin(), Ans.end());            } Else {                Ans += S[i];            }            I++;        }        Return Ans;    }}; | Class Solution {Public:    String Finalstring(const String &amp;S) {        String A, B;        For (Char Ch : S)            If (Ch == &#39;I&#39;)                Swap(a, B);            Else                A += Ch;        Return String(rbegin(b), Rend(b)) + A;    }}; 
 79 | 3 | Java | medium | GitHub Copilot | IDE Extension | You are given a 0-indexed integer array nums and an integer x.Find the minimum absolute difference between two elements in the array that are at least x indices apart.In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.Example 1:Input: nums = [4,3,2,4], x = 2Output: 0Explanation: We can select nums[0] = 4 and nums[3] = 4. They are at least 2 indices apart, and their absolute difference is the minimum, 0. It can be shown that 0 is the optimal answer.Example 2:Input: nums = [5,3,2,10,15], x = 1Output: 1Explanation: We can select nums[1] = 3 and nums[2] = 2.They are at least 1 index apart, and their absolute difference is the minimum, 1.It can be shown that 1 is the optimal answer.Example 3:Input: nums = [1,2,3,4], x = 3Output: 3Explanation: We can select nums[0] = 1 and nums[3] = 4.They are at least 3 indices apart, and their absolute difference is the minimum, 3.It can be shown that 3 is the optimal answer. Constraints:1 &lt;= nums.length &lt;= 10^51 &lt;= nums[i] &lt;= 10^90 &lt;= x &lt; nums.length  | class Solution {    public int minAbsoluteDifference(List&lt;Integer&gt; nums, int x) {/*You are given a 0-indexed integer array nums and an integer x.Find the minimum absolute difference between two elements in the array that are at least x indices apart.In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart. Constraints:1 &lt;= nums.length &lt;= 10^51 &lt;= nums[i] &lt;= 10^90 &lt;= x &lt; nums.length*/ | Class Solution {    Public Int Minabsolutedifference(list&lt;integer&gt; Nums, Int X) {        Int Min = Integer.max_value;        Int N = Nums.size();        For(int I = 0; I &lt; N; I++){            For(int J = I + X; J &lt; N; J++){                Min = Math.min(min, Math.abs(nums.get(i) - Nums.get(j)));            }        }        Return Min;    }} | Class Solution {    Int Minabsolutedifference(list&lt;integer&gt; Nums, Int X) {        Int Ans = Integer.max_value;        Treeset&lt;integer&gt; S = New Treeset&lt;&gt;();        For(int I = X; I &lt; Nums.size(); ++I){            S.add(nums.get(i-x));            Integer High = S.ceiling(nums.get(i)), Low = S.floor(nums.get(i));            If(high != Null) Ans = Math.min(ans, Math.abs(nums.get(i) - High));            If(low != Null) Ans = Math.min(ans, Math.abs(nums.get(i) - Low));        }        Return Ans;    }} 
 80 | 3 | Python | medium | GitHub Copilot | IDE Extension | You are given a 0-indexed integer array nums and an integer x.Find the minimum absolute difference between two elements in the array that are at least x indices apart.In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.Example 1:Input: nums = [4,3,2,4], x = 2Output: 0Explanation: We can select nums[0] = 4 and nums[3] = 4. They are at least 2 indices apart, and their absolute difference is the minimum, 0. It can be shown that 0 is the optimal answer.Example 2:Input: nums = [5,3,2,10,15], x = 1Output: 1Explanation: We can select nums[1] = 3 and nums[2] = 2.They are at least 1 index apart, and their absolute difference is the minimum, 1.It can be shown that 1 is the optimal answer.Example 3:Input: nums = [1,2,3,4], x = 3Output: 3Explanation: We can select nums[0] = 1 and nums[3] = 4.They are at least 3 indices apart, and their absolute difference is the minimum, 3.It can be shown that 3 is the optimal answer. Constraints:1 &lt;= nums.length &lt;= 10^51 &lt;= nums[i] &lt;= 10^90 &lt;= x &lt; nums.length  | class Solution:    def minAbsoluteDifference(self, nums: List[int], x: int) -&gt; int:&quot;&quot;&quot;You are given a 0-indexed integer array nums and an integer x.Find the minimum absolute difference between two elements in the array that are at least x indices apart.In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.Example 1:Input: nums = [4,3,2,4], x = 2Output: 0Explanation: We can select nums[0] = 4 and nums[3] = 4. They are at least 2 indices apart, and their absolute difference is the minimum, 0. It can be shown that 0 is the optimal answer.Example 2:Input: nums = [5,3,2,10,15], x = 1Output: 1Explanation: We can select nums[1] = 3 and nums[2] = 2.They are at least 1 index apart, and their absolute difference is the minimum, 1.It can be shown that 1 is the optimal answer.Example 3:Input: nums = [1,2,3,4], x = 3Output: 3Explanation: We can select nums[0] = 1 and nums[3] = 4.They are at least 3 indices apart, and their absolute difference is the minimum, 3.It can be shown that 3 is the optimal answer. Constraints:1 &lt;= nums.length &lt;= 10^51 &lt;= nums[i] &lt;= 10^90 &lt;= x &lt; nums.length&quot;&quot;&quot; | Class Solution:    Def Minabsolutedifference(self, Nums: List[int], X: Int) -&gt; Int:        Nums.sort()        N = Len(nums)        Res = Float(&#39;inf&#39;)        For I In Range(n):            J = Bisect_left(nums, Nums[i] - X, I + 1)            If J &lt; N:                Res = Min(res, Abs(nums[i] - Nums[j] + X))            If J &gt; I + 1:                Res = Min(res, Abs(nums[i] - Nums[j - 1] + X))        Return Res | Class Solution:  Def Minabsolutedifference(self, Nums: List[int], X: Int) -&gt; Int:    If X == 0:      Return 0    Arr, Best_dist = Sortedlist([]), Float(&#39;inf&#39;)    For I In Range(x, Len(nums)):      Arr.add(nums[i - X])      V = Nums[i]      Pos = Arr.bisect_left(v)      If Pos &lt; Len(arr):        Best_dist = Min(best_dist, Abs(arr[pos] - V))      If Pos &gt; 0:        Best_dist = Min(best_dist, Abs(arr[pos - 1] - V))        Return Best_dist 
 81 | 3 | C++ | medium | GitHub Copilot | IDE Extension | You are given a 0-indexed integer array nums and an integer x.Find the minimum absolute difference between two elements in the array that are at least x indices apart.In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.Example 1:Input: nums = [4,3,2,4], x = 2Output: 0Explanation: We can select nums[0] = 4 and nums[3] = 4. They are at least 2 indices apart, and their absolute difference is the minimum, 0. It can be shown that 0 is the optimal answer.Example 2:Input: nums = [5,3,2,10,15], x = 1Output: 1Explanation: We can select nums[1] = 3 and nums[2] = 2.They are at least 1 index apart, and their absolute difference is the minimum, 1.It can be shown that 1 is the optimal answer.Example 3:Input: nums = [1,2,3,4], x = 3Output: 3Explanation: We can select nums[0] = 1 and nums[3] = 4.They are at least 3 indices apart, and their absolute difference is the minimum, 3.It can be shown that 3 is the optimal answer. Constraints:1 &lt;= nums.length &lt;= 10^51 &lt;= nums[i] &lt;= 10^90 &lt;= x &lt; nums.length  | class Solution {public:    int minAbsoluteDifference(vector&lt;int&gt;&amp; nums, int x) {/*You are given a 0-indexed integer array nums and an integer x.Find the minimum absolute difference between two elements in the array that are at least x indices apart.In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.Example 1:Input: nums = [4,3,2,4], x = 2Output: 0Explanation: We can select nums[0] = 4 and nums[3] = 4. They are at least 2 indices apart, and their absolute difference is the minimum, 0. It can be shown that 0 is the optimal answer.Example 2:Input: nums = [5,3,2,10,15], x = 1Output: 1Explanation: We can select nums[1] = 3 and nums[2] = 2.They are at least 1 index apart, and their absolute difference is the minimum, 1.It can be shown that 1 is the optimal answer.Example 3:Input: nums = [1,2,3,4], x = 3Output: 3Explanation: We can select nums[0] = 1 and nums[3] = 4.They are at least 3 indices apart, and their absolute difference is the minimum, 3.It can be shown that 3 is the optimal answer. Constraints:1 &lt;= nums.length &lt;= 10^51 &lt;= nums[i] &lt;= 10^90 &lt;= x &lt; nums.length*/ | Class Solution {Public:    Int Minabsolutedifference(vector&lt;int&gt;&amp; Nums, Int X) {        Int N = Nums.size();        Int Ans = Int_max;        For(int I = 0; I &lt; N; I++){            For(int J = I + X; J &lt; N; J++){                Ans = Min(ans, Abs(nums[i] - Nums[j]));            }        }        Return Ans;    }}; | Class Solution {Public:    Int Minabsolutedifference(vector&lt;int&gt;&amp; Nums, Int X) {        Int Ans = Int_max;        Set&lt;int&gt; S;        For(int I = X; I &lt; Nums.size(); ++I){            S.insert(nums[i-x]);            Auto It = S.upper_bound(nums[i]);            If(it != S.end()) Ans = Min(ans, Abs(nums[i] - *It));            If(it != S.begin()) Ans = Min(ans, Abs(nums[i] - *Prev(it)));        }        Return Ans;    }}; 
 82 | 4 | Java | medium | GitHub Copilot | IDE Extension | You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.Return the head of the linked list after doubling it.Example 1:Input: head = [1,8,9]Output: [3,7,8]Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.Example 2:Input: head = [9,9,9]Output: [1,9,9,8]Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. Constraints:The number of nodes in the list is in the range [1, 10^4]0 &lt;= Node.val &lt;= 9The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.  | class Solution {    public ListNode doubleIt(ListNode head) {/* *You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.Return the head of the linked list after doubling it.Constraints:The number of nodes in the list is in the range [1, 10^4]0 &lt;= Node.val &lt;= 9The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.*/ | Class Solution {    Public Listnode Doubleit(listnode Head) {        Listnode Curr = Head;        Listnode Prev = Null;        While(curr != Null) {            Listnode Next = Curr.next;            Curr.next = Prev;            Prev = Curr;            Curr = Next;        }                Listnode Newhead = Prev;        Listnode Newcurr = Newhead;        Listnode Carry = Null;        While(newcurr != Null) {            Int Sum = Newcurr.val * 2;            If(carry != Null) {                Sum += Carry.val;                Carry = Null;            }            If(sum &gt; 9) {                Carry = New Listnode(sum / 10);                Sum = Sum % 10;            }            Newcurr.val = Sum;            Newcurr = Newcurr.next;        }        If(carry != Null) {            Newcurr = Newhead;            While(newcurr.next != Null) {                Newcurr = Newcurr.next;            }            Newcurr.next = Carry;        }        Return Reverse(newhead);    }        Public Listnode Reverse(listnode Head) {        Listnode Curr = Head;        Listnode Prev = Null;        While(curr != Null) {            Listnode Next = Curr.next;            Curr.next = Prev;            Prev = Curr;            Curr = Next;        }                Return Prev;    }} | Class Solution {    Public Listnode Doubleit(listnode Head) {        If (Head.val &gt; 4)            Head = New Listnode(0, Head);        For(listnode Node = Head; Node != Null; Node = Node.next) {            Node.val = (Node.val * 2) % 10;            If (Node.next != Null &amp;&amp; Node.next.val &gt; 4)                Node.val++;        }        Return Head;    }} 
 83 | 4 | Python | medium | GitHub Copilot | IDE Extension | You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.Return the head of the linked list after doubling it.Example 1:Input: head = [1,8,9]Output: [3,7,8]Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.Example 2:Input: head = [9,9,9]Output: [1,9,9,8]Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. Constraints:The number of nodes in the list is in the range [1, 10^4]0 &lt;= Node.val &lt;= 9The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.  | class Solution:    def doubleIt(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:&quot;&quot;&quot;You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.Return the head of the linked list after doubling it.Example 1:Input: head = [1,8,9]Output: [3,7,8]Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.Example 2:Input: head = [9,9,9]Output: [1,9,9,8]Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. Constraints:The number of nodes in the list is in the range [1, 10^4]0 &lt;= Node.val &lt;= 9The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.&quot;&quot;&quot; | Class Solution:    Def Doubleit(self, Head: Optional[listnode]) -&gt; Optional[listnode]:        If Head Is None:            Return None        If Head.next Is None:            Head.val = Head.val * 2            Return Head        Node = Head        While Node:            Node.val = Node.val * 2            Node = Node.next        Node = Head        While Node:            If Node.val &gt; 9:                Node.val = Node.val % 10                If Node.next Is None:                    Node.next = Listnode(1)                Else:                    Node.next.val += 1            Node = Node.next        Return Head | Class Solution:    Def Doubleit(self, Head: Optional[listnode]) -&gt; Optional[listnode]:        If Head.val &gt; 4:            Head = Listnode(0, Head)        Node = Head        While Node:            Node.val = (Node.val * 2) % 10            If Node.next And Node.next.val &gt; 4:                Node.val += 1            Node = Node.next        Return Head 
 84 | 4 | C++ | medium | GitHub Copilot | IDE Extension | You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.Return the head of the linked list after doubling it.Example 1:Input: head = [1,8,9]Output: [3,7,8]Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.Example 2:Input: head = [9,9,9]Output: [1,9,9,8]Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. Constraints:The number of nodes in the list is in the range [1, 10^4]0 &lt;= Node.val &lt;= 9The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.  | class Solution {public:    ListNode* doubleIt(ListNode* head) {/*You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.Return the head of the linked list after doubling it.Constraints:The number of nodes in the list is in the range [1, 10^4]0 &lt;= Node.val &lt;= 9The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.*/ | Class Solution {Public:    Listnode* Doubleit(listnode* Head) {        Listnode* Temp = Head;        Listnode* Prev = Null;        While(temp != Null) {            Temp-&gt;val *= 2;            If(temp-&gt;val &gt; 9) {                If(prev == Null) {                    Listnode* Newhead = New Listnode(1);                    Newhead-&gt;next = Head;                    Head = Newhead;                    Temp-&gt;val -= 10;                } Else {                    Prev-&gt;val += 1;                    Temp-&gt;val -= 10;                }            }            Prev = Temp;            Temp = Temp-&gt;next;        }        Return Head;    }}; | Class Solution {Public:    Listnode* Doubleit(listnode* Head) {        If (Head-&gt;val &gt; 4)            Head = New Listnode(0, Head);        For(listnode* Node = Head; Node; Node = Node-&gt;next) {            Node-&gt;val = (Node-&gt;val * 2) % 10;            If (Node-&gt;next &amp;&amp; Node-&gt;next-&gt;val &gt; 4)                Node-&gt;val++;        }        Return Head;    }}; 
 85 | 5 | Java | hard | GitHub Copilot | IDE Extension | You are given an array nums of n positive integers and an integer k.Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.Multiply your score by x.Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.Return the maximum possible score after applying at most k operations.Since the answer may be large, return it modulo 10^9 + 7.Example 1:Input: nums = [8,3,9,3,8], k = 2Output: 81Explanation: To get a score of 81, we can apply the following operations:- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.It can be proven that 81 is the highest score one can obtain.Example 2:Input: nums = [19,12,14,6,10,18], k = 3Output: 4788Explanation: To get a score of 4788, we can apply the following operations: - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.It can be proven that 4788 is the highest score one can obtain. Constraints:1 &lt;= nums.length == n &lt;= 10^51 &lt;= nums[i] &lt;= 10^51 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9)  | public class Solution {    public int maximumScore(List&lt;Integer&gt; nums, int k) {/* * You are given an array nums of n positive integers and an integer k.Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.Multiply your score by x.Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.Return the maximum possible score after applying at most k operations.Since the answer may be large, return it modulo 10^9 + 7.Example 1:Input: nums = [8,3,9,3,8], k = 2Output: 81Explanation: To get a score of 81, we can apply the following operations:- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.It can be proven that 81 is the highest score one can obtain.Example 2:Input: nums = [19,12,14,6,10,18], k = 3Output: 4788Explanation: To get a score of 4788, we can apply the following operations: - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.It can be proven that 4788 is the highest score one can obtain. Constraints:1 &lt;= nums.length == n &lt;= 10^51 &lt;= nums[i] &lt;= 10^51 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9).*/ | Public Class Solution {    Public Int Maximumscore(list&lt;integer&gt; Nums, Int K) {        Int N = Nums.size();        Int[] Left = New Int[n];        Int[] Right = New Int[n];        Stack&lt;integer&gt; Stack = New Stack&lt;&gt;();        For (Int I = 0; I &lt; N; I++) {            While (!Stack.isempty() &amp;&amp; Nums.get(stack.peek()) &gt;= Nums.get(i)) {                Stack.pop();            }            Left[i] = Stack.isempty() ? -1 : Stack.peek();            Stack.push(i);        }        Stack.clear();        For (Int I = N - 1; I &gt;= 0; I--) {            While (!Stack.isempty() &amp;&amp; Nums.get(stack.peek()) &gt;= Nums.get(i)) {                Stack.pop();            }            Right[i] = Stack.isempty() ? N : Stack.peek();            Stack.push(i);        }        Int Ans = 0;        For (Int I = 0; I &lt; N; I++) {            If (Left[i] &lt; K &amp;&amp; Right[i] &gt; K) {                Ans = Math.max(ans, Nums.get(i) * (Right[i] - Left[i] - 1));            }        }        Return Ans;    }} | Class Solution {    Static Final Int Mod = 1000000007;    Public Int Maximumscore(list&lt;integer&gt; Nums, Int K) {        Int N = Nums.size();        Int Upper = Collections.max(nums) + 1;        Boolean[] Prime = New Boolean[upper];        Int[] Primescore = New Int[upper];        Arrays.fill(prime, True);        Prime[0] = Prime[1] = False;        For (Int I = 2; I &lt; Upper; I++) {            If (Prime[i]) {                For (Int J = I; J &lt; Upper; J += I) {                    Primescore[j]++;                    Prime[j] = False;                }            }        }        Int[] Nextgreaterelement = New Int[n];        Arrays.fill(nextgreaterelement, N);        Stack&lt;integer&gt; S = New Stack&lt;&gt;();        For (Int I = N - 1; I &gt;= 0; I--) {            While (!S.empty() &amp;&amp; Primescore[nums.get(i)] &gt;= Primescore[nums.get(s.peek())]) {                S.pop();            }            Nextgreaterelement[i] = S.empty() ? N : S.peek();            S.push(i);        }        Int[] Prevgreaterorequalelement = New Int[n];        Arrays.fill(prevgreaterorequalelement, -1);        S = New Stack&lt;&gt;();        For (Int I = 0; I &lt; N; I++) {            While (!S.empty() &amp;&amp; Primescore[nums.get(i)] &gt; Primescore[nums.get(s.peek())]) {                S.pop();            }            Prevgreaterorequalelement[i] = S.empty() ? -1 : S.peek();            S.push(i);        }        Int Res = 1;        Int[][] Tuples = New Int[n][2];        For (Int I = 0; I &lt; N; I++) {            Tuples[i][0] = Nums.get(i);            Tuples[i][1] = I;        }        Arrays.sort(tuples, New Comparator&lt;int[]&gt;() {            Public Int Compare(int[] A, Int[] B) {                Return B[0] - A[0];            }        });        For (Int I = 0; I &lt; N; I++) {            Int Num = Tuples[i][0];            Int Idx = Tuples[i][1];            Int Operations = Math.min((idx - Prevgreaterorequalelement[idx]) * (Nextgreaterelement[idx] - Idx), K);            Res = (Int)((1l * Res * Pow(num, Operations)) % Mod);            K -= Operations;            If (K == 0) {                Return Res;            }        }        Return Res;    }    Public Int Pow(int X, Int N) {        Int Res = 1;        While (N &gt; 0) {            If (N % 2 == 1) {                Res = (Int)((1l * Res * X) % Mod);            }            X = (Int)((1l * X * X) % Mod);            N /= 2;        }        Return Res;    }} 
 86 | 5 | Python | hard | GitHub Copilot | IDE Extension | You are given an array nums of n positive integers and an integer k.Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.Multiply your score by x.Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.Return the maximum possible score after applying at most k operations.Since the answer may be large, return it modulo 10^9 + 7.Example 1:Input: nums = [8,3,9,3,8], k = 2Output: 81Explanation: To get a score of 81, we can apply the following operations:- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.It can be proven that 81 is the highest score one can obtain.Example 2:Input: nums = [19,12,14,6,10,18], k = 3Output: 4788Explanation: To get a score of 4788, we can apply the following operations: - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.It can be proven that 4788 is the highest score one can obtain. Constraints:1 &lt;= nums.length == n &lt;= 10^51 &lt;= nums[i] &lt;= 10^51 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9)  | class Solution:    def maximumScore(self, nums: List[int], k: int) -&gt; int:&quot;&quot;&quot;You are given an array nums of n positive integers and an integer k.Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.Multiply your score by x.Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.Return the maximum possible score after applying at most k operations.Since the answer may be large, return it modulo 10^9 + 7.Example 1:Input: nums = [8,3,9,3,8], k = 2Output: 81Explanation: To get a score of 81, we can apply the following operations:- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.It can be proven that 81 is the highest score one can obtain.Example 2:Input: nums = [19,12,14,6,10,18], k = 3Output: 4788Explanation: To get a score of 4788, we can apply the following operations: - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.It can be proven that 4788 is the highest score one can obtain. Constraints:1 &lt;= nums.length == n &lt;= 10^51 &lt;= nums[i] &lt;= 10^51 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9).&quot;&quot;&quot; | Class Solution:    Def Maximumscore(self, Nums: List[int], K: Int) -&gt; Int:        N = Len(nums)        Left, Right = K, K        Res = Nums[k]        Min_val = Nums[k]        While Left &gt; 0 Or Right &lt; N - 1:            If Left == 0:                Right += 1            Elif Right == N - 1:                Left -= 1            Elif Nums[left - 1] &lt; Nums[right + 1]:                Right += 1            Else:                Left -= 1            Min_val = Min(min_val, Nums[left], Nums[right])            Res = Max(res, Min_val * (Right - Left + 1))        Return Res | Class Solution:     Mod = 1000000007    Def Maximumscore(self, Nums: List[int], K: Int) -&gt; Int:        N = Len(nums)        Upper = Max(nums) + 1        Prime = [True]*upper        Prime[0] = Prime[1] = False        Primescore = [0]*upper        For I In Range(2, Upper):            If Prime[i]:                For J In Range(i, Upper, I):                    Primescore[j] += 1                    Prime[j] = False        Nextgreaterelement = [N]*n        S = []        For I In Range(n - 1, -1, -1):            While S And Primescore[nums[i]] &gt;= Primescore[nums[s[-1]]]:                S.pop()            Nextgreaterelement[i] = S[-1] If S Else N            S.append(i)        Prevgreaterorequalelement = [-1]*n        S = []        For I In Range(n):            While S And Primescore[nums[i]] &gt; Primescore[nums[s[-1]]]:                S.pop()            Prevgreaterorequalelement[i] = S[-1] If S Else -1            S.append(i)        Res = 1        Tuples = [[Nums[i], I] For I In Range(n)]        Tuples.sort(reverse=true)        For Num, Idx In Tuples:            Operations = Min((idx - Prevgreaterorequalelement[idx]) * (Nextgreaterelement[idx] - Idx), K)            Res = (Res * Self.pow(num, Operations)) % Self.mod            K -= Operations            If K == 0:                Return Res        Return Res    Def Pow(self, X: Int, N: Int) -&gt; Int:        Res = 1        While N &gt; 0:            If N % 2 == 1:                Res = (Res * X) % Self.mod            X = (X * X) % Self.mod            N //= 2        Return Res 
 87 | 5 | C++ | hard | GitHub Copilot | IDE Extension | You are given an array nums of n positive integers and an integer k.Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.Multiply your score by x.Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.Return the maximum possible score after applying at most k operations.Since the answer may be large, return it modulo 10^9 + 7.Example 1:Input: nums = [8,3,9,3,8], k = 2Output: 81Explanation: To get a score of 81, we can apply the following operations:- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.It can be proven that 81 is the highest score one can obtain.Example 2:Input: nums = [19,12,14,6,10,18], k = 3Output: 4788Explanation: To get a score of 4788, we can apply the following operations: - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.It can be proven that 4788 is the highest score one can obtain. Constraints:1 &lt;= nums.length == n &lt;= 10^51 &lt;= nums[i] &lt;= 10^51 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9)  | class Solution {public:    int maximumScore(vector&lt;int&gt;&amp; nums, int k) {/*You are given an array nums of n positive integers and an integer k.Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.Multiply your score by x.Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.Return the maximum possible score after applying at most k operations.Since the answer may be large, return it modulo 10^9 + 7.Example 1:Input: nums = [8,3,9,3,8], k = 2Output: 81Explanation: To get a score of 81, we can apply the following operations:- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.It can be proven that 81 is the highest score one can obtain.Example 2:Input: nums = [19,12,14,6,10,18], k = 3Output: 4788Explanation: To get a score of 4788, we can apply the following operations: - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.It can be proven that 4788 is the highest score one can obtain. Constraints:1 &lt;= nums.length == n &lt;= 10^51 &lt;= nums[i] &lt;= 10^51 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9).*/ | Class Solution {Public:    Int Maximumscore(vector&lt;int&gt;&amp; Nums, Int K) {        Int N = Nums.size();        Vector&lt;int&gt; Left(n, -1), Right(n, N);        Stack&lt;int&gt; St;        For(int I = 0; I &lt; N; I++) {            While(!st.empty() &amp;&amp; Nums[st.top()] &gt;= Nums[i]) {                St.pop();            }            If(!st.empty()) {                Left[i] = St.top();            }            St.push(i);        }        While(!st.empty()) {            St.pop();        }        For(int I = N - 1; I &gt;= 0; I--) {            While(!st.empty() &amp;&amp; Nums[st.top()] &gt;= Nums[i]) {                St.pop();            }            If(!st.empty()) {                Right[i] = St.top();            }            St.push(i);        }        Vector&lt;int&gt; Primes(100001, 0);        For(int I = 2; I &lt;= 100000; I++) {            If(primes[i] == 0) {                For(int J = I; J &lt;= 100000; J += I) {                    Primes[j]++;                }            }        }        Vector&lt;int&gt; Dp(n, 0);        For(int I = 0; I &lt; N; I++) {            Dp[i] = Nums[i] * (Primes[nums[i]] + 1);        }        For(int I = 1; I &lt; N; I++) {            Dp[i] = Max(dp[i], Dp[i - 1]);        }        Int Ans = 0;        For(int I = 0; I &lt; N; I++) {            Int L = Left[i] + 1, R = Right[i] - 1;            If(l &lt;= K &amp;&amp; K &lt;= R) {                Ans = Max(ans, Nums[i] * Dp[r]);            }            If(l &lt;= K - 1 &amp;&amp; K - 1 &lt;= R) {                Ans = Max(ans, Nums[i] * Dp[r]);            }            If(l &lt;= K &amp;&amp; K &lt;= R + 1) {                Ans = Max(ans, Nums[i] * Dp[r]);            }            If(l &lt;= K - 1 &amp;&amp; K - 1 &lt;= R + 1) {                Ans = Max(ans, Nums[i] * Dp[r]);            }        }        Return Ans;    }}; | Class Solution {Public:    Const Int Mod = 1000000007;    Int Maximumscore(vector&lt;int&gt;&amp; Nums, Int K) {        Int N = Nums.size();        Int Upper = *Max_element(nums.begin(), Nums.end()) + 1;        Vector&lt;bool&gt; Prime(upper, True);        Prime[0] = Prime[1] = False;        Vector&lt;int&gt; Primescore(upper, 0);        For (Int I = 2; I &lt; Upper; I++) {            If (Prime[i]) {                For (Int J = I; J &lt; Upper; J += I) {                    Primescore[j]++;                    Prime[j] = False;                }            }        }        Vector&lt;int&gt; Nextgreaterelement(n, N);        Stack&lt;int&gt; S;        For (Int I = N - 1; I &gt;= 0; I--) {            While (!S.empty() &amp;&amp; Primescore[nums[i]] &gt;= Primescore[nums[s.top()]]) {                S.pop();            }            Nextgreaterelement[i] = S.empty() ? N : S.top();            S.push(i);        }        Vector&lt;int&gt; Prevgreaterorequalelement(n, -1);        S = Stack&lt;int&gt;();        For (Int I = 0; I &lt; N; I++) {            While (!S.empty() &amp;&amp; Primescore[nums[i]] &gt; Primescore[nums[s.top()]]) {                S.pop();            }            Prevgreaterorequalelement[i] = S.empty() ? -1 : S.top();            S.push(i);        }        Int Res = 1;        Vector&lt;pair&lt;int, Int&gt;&gt; Tuples(n);        For (Int I = 0; I &lt; N; I++) {            Tuples[i].first = Nums[i];            Tuples[i].second = I;        }        Sort(tuples.rbegin(), Tuples.rend());        For (Const Auto&amp; [Num, I] : Tuples) {            Int Operations = Min((i - Prevgreaterorequalelement[i]) * (Nextgreaterelement[i] - I), K);            Res = (Int)((1l * Res * Pow(num, Operations)) % Mod);            K -= Operations;            If (K == 0) {                Return Res;            }        }        Return Res;    }    Int Pow(int X, Int N) {        Int Res = 1;        While (N &gt; 0) {            If (N % 2 == 1) {                Res = (Int)((1l * Res * X) % Mod);            }            X = (Int)((1l * X * X) % Mod);            N /= 2;        }        Return Res;    }}; 
 88 | 6 | Java | hard | GitHub Copilot | IDE Extension | You are given a 0-indexed 2D integer array items of length n and an integer k.items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.Your task is to find the maximum elegance from all subsequences of size k in items.Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.Example 1:Input: items = [[3,2],[5,1],[10,1]], k = 2Output: 17Explanation: In this example, we have to select a subsequence of size 2.We can select items[0] = [3,2] and items[2] = [10,1].The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. Example 2:Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3Output: 19Explanation: In this example, we have to select a subsequence of size 3. We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.Example 3:Input: items = [[1,1],[2,1],[3,1]], k = 3Output: 7Explanation: In this example, we have to select a subsequence of size 3. We should select all the items. The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. Hence, the maximum elegance is 6 + 1^2 = 7.   Constraints:1 &lt;= items.length == n &lt;= 10^5items[i].length == 2items[i][0] == profit_iitems[i][1] == category_i1 &lt;= profit_i &lt;= 10^91 &lt;= category_i &lt;= n 1 &lt;= k &lt;= n  | public class Solution {    public int findMaximumElegance(int[][] items, int k) {/* * You are given a 0-indexed 2D integer array items of length n and an integer k.items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.Your task is to find the maximum elegance from all subsequences of size k in items.Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.Example 1:Input: items = [[3,2],[5,1],[10,1]], k = 2Output: 17Explanation: In this example, we have to select a subsequence of size 2.We can select items[0] = [3,2] and items[2] = [10,1].The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. Example 2:Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3Output: 19Explanation: In this example, we have to select a subsequence of size 3. We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.Example 3:Input: items = [[1,1],[2,1],[3,1]], k = 3Output: 7Explanation: In this example, we have to select a subsequence of size 3. We should select all the items. The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. Hence, the maximum elegance is 6 + 1^2 = 7.   Constraints:1 &lt;= items.length == n &lt;= 10^5items[i].length == 2items[i][0] == profit_iitems[i][1] == category_i1 &lt;= profit_i &lt;= 10^91 &lt;= category_i &lt;= n 1 &lt;= k &lt;= n*/ | Public Class Solution {    Public Int Findmaximumelegance(int[][] Items, Int K) {        Int N = Items.length;        Int[] Dp = New Int[n];        Arrays.sort(items, (A, B) -&gt; A[0] - B[0]);        Int Max = 0;        For (Int I = 0; I &lt; N; I++) {            Int Profit = Items[i][0];            Int Category = Items[i][1];            Dp[i] = Profit + Category * Category;            For (Int J = 0; J &lt; I; J++) {                If (Items[j][1] != Category) {                    Dp[i] = Math.max(dp[i], Dp[j] + Profit + Category * Category);                }            }            If (I &gt;= K - 1) {                Max = Math.max(max, Dp[i]);            }        }        Return Max;    }} | Class Solution {    Public Long Findmaximumelegance(int[][] A, Int K) {        Arrays.sort(a, (A, B) -&gt; B[0] - A[0]);        Long Res = 0, Cur = 0;        List&lt;integer&gt; Dup = New Arraylist&lt;&gt;();        Set&lt;integer&gt; Seen = New Hashset&lt;&gt;();        For (Int I = 0; I &lt; A.length; ++I) {            If (I &lt; K) {                If (Seen.contains(a[i][1])) {                    Dup.add(a[i][0]);                }                Cur += A[i][0];            } Else If (!Seen.contains(a[i][1])) {                If (Dup.isempty()) Break;                Cur += A[i][0] - Dup.remove(dup.size() - 1);            }            Seen.add(a[i][1]);            Res = Math.max(res, Cur + 1l * Seen.size() * Seen.size());        }        Return Res;    }} 
 89 | 6 | Python | hard | GitHub Copilot | IDE Extension | You are given a 0-indexed 2D integer array items of length n and an integer k.items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.Your task is to find the maximum elegance from all subsequences of size k in items.Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.Example 1:Input: items = [[3,2],[5,1],[10,1]], k = 2Output: 17Explanation: In this example, we have to select a subsequence of size 2.We can select items[0] = [3,2] and items[2] = [10,1].The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. Example 2:Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3Output: 19Explanation: In this example, we have to select a subsequence of size 3. We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.Example 3:Input: items = [[1,1],[2,1],[3,1]], k = 3Output: 7Explanation: In this example, we have to select a subsequence of size 3. We should select all the items. The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. Hence, the maximum elegance is 6 + 1^2 = 7.   Constraints:1 &lt;= items.length == n &lt;= 10^5items[i].length == 2items[i][0] == profit_iitems[i][1] == category_i1 &lt;= profit_i &lt;= 10^91 &lt;= category_i &lt;= n 1 &lt;= k &lt;= n  | class Solution:    def findMaximumElegance(self, items: List[List[int]], k: int) -&gt; int:&quot;&quot;&quot;You are given a 0-indexed 2D integer array items of length n and an integer k.items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.Your task is to find the maximum elegance from all subsequences of size k in items.Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.Example 1:Input: items = [[3,2],[5,1],[10,1]], k = 2Output: 17Explanation: In this example, we have to select a subsequence of size 2.We can select items[0] = [3,2] and items[2] = [10,1].The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. Example 2:Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3Output: 19Explanation: In this example, we have to select a subsequence of size 3. We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.Example 3:Input: items = [[1,1],[2,1],[3,1]], k = 3Output: 7Explanation: In this example, we have to select a subsequence of size 3. We should select all the items. The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. Hence, the maximum elegance is 6 + 1^2 = 7.   Constraints:1 &lt;= items.length == n &lt;= 10^5items[i].length == 2items[i][0] == profit_iitems[i][1] == category_i1 &lt;= profit_i &lt;= 10^91 &lt;= category_i &lt;= n 1 &lt;= k &lt;= n&quot;&quot;&quot; | Class Solution:    Def Findmaximumelegance(self, Items: List[list[int]], K: Int) -&gt; Int:        Items.sort(key = Lambda X: X[0], Reverse = True)        Category = {}        For I In Range(len(items)):            If Items[i][1] Not In Category:                Category[items[i][1]] = 1            Else:                Category[items[i][1]] += 1        Category = Sorted(category.items(), Key = Lambda X: X[1], Reverse = True)        Ans = 0        For I In Range(k):            Ans += Items[i][0]        Ans += Len(category) ** 2        Return Ans | Class Solution:    Def Findmaximumelegance(self, Items: List[list[int]], K: Int) -&gt; Int:        Items = Sorted(items, Key=lambda V: -V[0])        Res = Cur = 0        A = []        Seen = Set()        For I, (P, C) In Enumerate(items):            If I &lt; K:                If C In Seen:                    A.append(p)                Cur += P            Elif C Not In Seen:                If Not A: Break                Cur += P - A.pop()            Seen.add(c)            Res = Max(res, Cur + Len(seen) * Len(seen))        Return Res 
 90 | 6 | C++ | hard | GitHub Copilot | IDE Extension | You are given a 0-indexed 2D integer array items of length n and an integer k.items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.Your task is to find the maximum elegance from all subsequences of size k in items.Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.Example 1:Input: items = [[3,2],[5,1],[10,1]], k = 2Output: 17Explanation: In this example, we have to select a subsequence of size 2.We can select items[0] = [3,2] and items[2] = [10,1].The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. Example 2:Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3Output: 19Explanation: In this example, we have to select a subsequence of size 3. We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.Example 3:Input: items = [[1,1],[2,1],[3,1]], k = 3Output: 7Explanation: In this example, we have to select a subsequence of size 3. We should select all the items. The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. Hence, the maximum elegance is 6 + 1^2 = 7.   Constraints:1 &lt;= items.length == n &lt;= 10^5items[i].length == 2items[i][0] == profit_iitems[i][1] == category_i1 &lt;= profit_i &lt;= 10^91 &lt;= category_i &lt;= n 1 &lt;= k &lt;= n  | class Solution {public:    long long findMaximumElegance(vector&lt;vector&lt;int&gt;&gt;&amp; items, int k) {/*You are given a 0-indexed 2D integer array items of length n and an integer k.items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.Your task is to find the maximum elegance from all subsequences of size k in items.Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.Example 1:Input: items = [[3,2],[5,1],[10,1]], k = 2Output: 17Explanation: In this example, we have to select a subsequence of size 2.We can select items[0] = [3,2] and items[2] = [10,1].The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. Example 2:Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3Output: 19Explanation: In this example, we have to select a subsequence of size 3. We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.Example 3:Input: items = [[1,1],[2,1],[3,1]], k = 3Output: 7Explanation: In this example, we have to select a subsequence of size 3. We should select all the items. The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. Hence, the maximum elegance is 6 + 1^2 = 7.   Constraints:1 &lt;= items.length == n &lt;= 10^5items[i].length == 2items[i][0] == profit_iitems[i][1] == category_i1 &lt;= profit_i &lt;= 10^91 &lt;= category_i &lt;= n 1 &lt;= k &lt;= n*/ | Class Solution {Public:    Long Long Findmaximumelegance(vector&lt;vector&lt;int&gt;&gt;&amp; Items, Int K) {        Int N = Items.size();        Vector&lt;pair&lt;int,int&gt;&gt; V;        For(int I=0;i&lt;n;i++){            V.push_back({items[i][0],items[i][1]});        }        Sort(v.begin(),v.end(),greater&lt;pair&lt;int,int&gt;&gt;());        Int I=0;        Long Long Ans = 0;        Unordered_map&lt;int,int&gt; Mp;        While(i&lt;n &amp;&amp; K&gt;0){            If(mp[v[i].second]==0){                Ans += V[i].first;                Mp[v[i].second]++;                K--;            }            I++;        }        Return Ans + (K*k);    }}; | Class Solution {Public:    Long Long Findmaximumelegance(vector&lt;vector&lt;int&gt;&gt;&amp; A, Int K) {        Sort(a.begin(), A.end(), [](Const Vector&lt;int&gt;&amp; A, Const Vector&lt;int&gt;&amp; B) {            Return A[0] &gt; B[0];        });        Long Long Res = 0, Cur = 0;        Vector&lt;int&gt; Dup;        Unordered_set&lt;int&gt; Seen;        For (Int I = 0; I &lt; A.size(); ++I) {            If (I &lt; K) {                If (Seen.count(a[i][1])) {                    Dup.push_back(a[i][0]);                }                Cur += A[i][0];            } Else If (Seen.find(a[i][1]) == Seen.end()) {                If (Dup.empty()) Break;                Cur += A[i][0] - Dup.back();                Dup.pop_back();            }            Seen.insert(a[i][1]);            Res = Fmax(res, Cur + 1l * Seen.size() * Seen.size());        }        Return Res;    }}; 
 91 | 1 | Java | easy | InstructCodeT5+ | HuggingFace Model | You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.Return the maximum sum or -1 if no such pair exists.Example 1:Input: nums = [51,71,17,24,42]Output: 88Explanation: For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.Example 2:Input: nums = [1,2,3,4]Output: -1Explanation: No pair exists in nums with equal maximum digits.Constraints:2 &lt;= nums.length &lt;= 1001 &lt;= nums[i] &lt;= 10^4  | prompt = &quot;&quot;&quot;You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.Return the maximum sum or -1 if no such pair exists.Example 1:Input: nums = [51,71,17,24,42]Output: 88Explanation: For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.Example 2:Input: nums = [1,2,3,4]Output: -1Explanation: No pair exists in nums with equal maximum digits.Constraints:2 &lt;= nums.length &lt;= 1001 &lt;= nums[i] &lt;= 10^4class Solution {    public int maxSum(int[] nums) {&quot;&quot;&quot; | Class Solution {        Public Int Maxsum(int[] Nums) {        Int Max = Integer.min_value;        Int Sum = 0;        For (Int I = 0; I &lt; Nums.length; I++) {            Sum += Nums[i];            If (Nums[i] &gt; Max) {                Max = Nums[i];            }            If (Max &gt; 0 &amp;&amp; Nums[i] % Max == 0) {                Sum -= Nums[i];            }        }        Return Sum;    }} | Class Solution {    Public Int Maxsum(int[] Nums) {    Int Ans = -1;    Map&lt;integer,list&lt;integer&gt;&gt; Ump = New Hashmap&lt;&gt;();    For(int I = 0; I &lt; Nums.length; ++I){        Int T = Nums[i], Maxdigit = 0;        While(t != 0){ //Evaluate Max Digit In The Number            Maxdigit = Math.max(t%10, Maxdigit);            T = T/10;        }        If(!ump.containskey(maxdigit)) Ump.put(maxdigit, New Arraylist&lt;&gt;());        Ump.get(maxdigit).add(nums[i]); // Add The Number To The Map     }    For(map.entry&lt;integer, List&lt;integer&gt;&gt; Entry: Ump.entryset()){        Entry.getvalue().sort(comparator.reverseorder()); //To Find Max Two Number In Each Max Digit         If(entry.getvalue().size() &gt;= 2) Ans = Math.max(ans, Entry.getvalue().get(0) + Entry.getvalue().get(1)); //Sum Max Two Number And Take Max    }    Return Ans;    }} 
 92 | 1 | Python | easy | InstructCodeT5+ | HuggingFace Model | You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.Return the maximum sum or -1 if no such pair exists.Example 1:Input: nums = [51,71,17,24,42]Output: 88Explanation: For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.Example 2:Input: nums = [1,2,3,4]Output: -1Explanation: No pair exists in nums with equal maximum digits.Constraints:2 &lt;= nums.length &lt;= 1001 &lt;= nums[i] &lt;= 10^4  | prompt = &quot;&quot;&quot;You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.Return the maximum sum or -1 if no such pair exists.Example 1:Input: nums = [51,71,17,24,42]Output: 88Explanation: For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.Example 2:Input: nums = [1,2,3,4]Output: -1Explanation: No pair exists in nums with equal maximum digits.Constraints:2 &lt;= nums.length &lt;= 1001 &lt;= nums[i] &lt;= 10^4class Solution:    def maxSum (self, nums: List[int]) -&gt; int:&quot;&quot;&quot; | Class Solution:        Def Maxsum (Self, Nums: List[int]) -&gt; Int:                Nums.sort()                Max_sum = 0                For I In Range(len(nums)-1):            If Nums[i] == Nums[i+1]:                Max_sum = Max(max_sum, Nums[i]*(len(nums)-i-1))                        Return Max_sum | Class Solution:    Def Maxsum(self, Nums: List[int]) -&gt; Int:        Max_by_digit = Defaultdict(int)        Max_sum = -1        For Num In Nums:            Digit = Max(str(num))            If Digit In Max_by_digit:                Max_sum = Max(max_sum, Max_by_digit[digit] + Num)            Max_by_digit[digit] = Max(max_by_digit[digit], Num)        Return Max_sum 
 93 | 1 | C++ | easy | InstructCodeT5+ | HuggingFace Model | You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.Return the maximum sum or -1 if no such pair exists.Example 1:Input: nums = [51,71,17,24,42]Output: 88Explanation: For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.Example 2:Input: nums = [1,2,3,4]Output: -1Explanation: No pair exists in nums with equal maximum digits.Constraints:2 &lt;= nums.length &lt;= 1001 &lt;= nums[i] &lt;= 10^4  | prompt = &quot;&quot;&quot;You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.Return the maximum sum or -1 if no such pair exists.Example 1:Input: nums = [51,71,17,24,42]Output: 88Explanation: For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.Example 2:Input: nums = [1,2,3,4]Output: -1Explanation: No pair exists in nums with equal maximum digits.Constraints:2 &lt;= nums.length &lt;= 1001 &lt;= nums[i] &lt;= 10^4class Solution {public:    int maxSum(vector&lt;int&gt;&amp; nums) {&quot;&quot;&quot; | Class Solution {Public:    Int Maxsum(vector&lt;int&gt;&amp; Nums) {        Int N = Nums.size();        Int Max_sum = -1;        Unordered_map&lt;int, Int&gt; Mp;        For (Int I = 0; I &lt; N; I++) {            For (Int J = I + 1; J &lt; N; J++) {                Int Sum = Nums[i] + Nums[j];                Int Max_digit = 0;                For (Int K = 0; K &lt; 10; K++) {                    If (Sum % 10 == K) {                        Max_digit = Max(max_digit, K);                    }                    Sum /= 10;                }                If (Mp.find(max_digit)!= Mp.end()) {                    Max_sum = Max(max_sum, Sum + Mp[max_digit]);                }                Mp[max_digit] = Sum;            }        }        Return Max_sum;    }}; | Class Solution {    Public:        Int Maxsum(vector&lt;int&gt;&amp; Nums) {        Int Res = -1, Max_num[10] = {};        For (Auto Num : Nums) {            Int Max_d = 0;            For (Int V = Num; V; V /= 10)                Max_d = Max(max_d, V % 10);            If (Max_num[max_d])                Res = Max(res, Max_num[max_d] + Num);            Max_num[max_d] = Max(max_num[max_d], Num);        }        Return Res;    }}; 
 94 | 2 | Java | easy | InstructCodeT5+ | HuggingFace Model | Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.Return the final string that will be present on your laptop screen.Example 1:Input: s = &quot;string&quot;Output: &quot;rtsng&quot;Explanation: After typing first character, the text on the screen is &quot;s&quot;.After the second character, the text is &quot;st&quot;. After the third character, the text is &quot;str&quot;.Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.After the fifth character, the text is &quot;rtsn&quot;. After the sixth character, the text is &quot;rtsng&quot;. Therefore, we return &quot;rtsng&quot;.Example 2:Input: s = &quot;poiinter&quot;Output: &quot;ponter&quot;Explanation: After the first character, the text on the screen is &quot;p&quot;.After the second character, the text is &quot;po&quot;. Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.After the fifth character, the text is &quot;pon&quot;.After the sixth character, the text is &quot;pont&quot;. After the seventh character, the text is &quot;ponte&quot;. After the eighth character, the text is &quot;ponter&quot;. Therefore, we return &quot;ponter&quot;. Constraints:1 &lt;= s.length &lt;= 100s consists of lowercase English letters.s[0] != &#39;i&#39; | prompt = &quot;&quot;&quot;Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.Return the final string that will be present on your laptop screen.Example 1:Input: s = &quot;string&quot;Output: &quot;rtsng&quot;Explanation: After typing first character, the text on the screen is &quot;s&quot;.After the second character, the text is &quot;st&quot;. After the third character, the text is &quot;str&quot;.Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.After the fifth character, the text is &quot;rtsn&quot;. After the sixth character, the text is &quot;rtsng&quot;. Therefore, we return &quot;rtsng&quot;.Example 2:Input: s = &quot;poiinter&quot;Output: &quot;ponter&quot;Explanation: After the first character, the text on the screen is &quot;p&quot;.After the second character, the text is &quot;po&quot;. Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.After the fifth character, the text is &quot;pon&quot;.After the sixth character, the text is &quot;pont&quot;. After the seventh character, the text is &quot;ponte&quot;. After the eighth character, the text is &quot;ponter&quot;. Therefore, we return &quot;ponter&quot;. Constraints:1 &lt;= s.length &lt;= 100s consists of lowercase English letters.s[0] != &#39;i&#39;public class Solution {    public String finalString(String s) {&quot;&quot;&quot; | Public Class Solution {        Public String Finalstring(string S) {        Stringbuilder Sb = New Stringbuilder();        For (Int I = 0; I &lt; S.length(); I++) {            Char C = S.charat(i);            If (C == &#39;I&#39;) {                Sb.append(c);            } Else {                Sb.append(c);                Sb.append(c);            }        }        Return Sb.tostring();    }} | Class Solution {    Public String Finalstring(string S) {        Stringbuilder Nm=new Stringbuilder();        For(char C:s.tochararray())        {            If(c==&#39;i&#39;)            {                Nm.reverse();            }            Else            {                Nm.append(c);            }        }        Return Nm.tostring();    }} 
 95 | 2 | Python | easy | InstructCodeT5+ | HuggingFace Model | Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.Return the final string that will be present on your laptop screen.Example 1:Input: s = &quot;string&quot;Output: &quot;rtsng&quot;Explanation: After typing first character, the text on the screen is &quot;s&quot;.After the second character, the text is &quot;st&quot;. After the third character, the text is &quot;str&quot;.Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.After the fifth character, the text is &quot;rtsn&quot;. After the sixth character, the text is &quot;rtsng&quot;. Therefore, we return &quot;rtsng&quot;.Example 2:Input: s = &quot;poiinter&quot;Output: &quot;ponter&quot;Explanation: After the first character, the text on the screen is &quot;p&quot;.After the second character, the text is &quot;po&quot;. Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.After the fifth character, the text is &quot;pon&quot;.After the sixth character, the text is &quot;pont&quot;. After the seventh character, the text is &quot;ponte&quot;. After the eighth character, the text is &quot;ponter&quot;. Therefore, we return &quot;ponter&quot;. Constraints:1 &lt;= s.length &lt;= 100s consists of lowercase English letters.s[0] != &#39;i&#39; | prompt = &quot;&quot;&quot;class Solution:    def finalString(self, s: str) -&gt; str:Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.Return the final string that will be present on your laptop screen.Example 1:Input: s = &quot;string&quot;Output: &quot;rtsng&quot;Example 2:Input: s = &quot;poiinter&quot;Output: &quot;ponter&quot; Constraints:1 &lt;= s.length &lt;= 100s consists of lowercase English letters.s[0] != &#39;i&#39;&quot;&quot;&quot; | Class Solution:    Def Finalstring(self, S: Str) -&gt; Str:        Res = &quot;&quot;        For I In S:            If I!= &#39;I&#39;:                Res += I            Else:                Res = Res[::-1]        Return Res | Class Solution:    Def Finalstring(self, S: Str) -&gt; Str:        While &quot;I&quot; In S:            Index=s.index(&quot;i&quot;)            #First Half And Second Half            First=s[:index][::-1]            Second=s[index+1:]            S=&quot;&quot;.join([first,second])        Return S 
 96 | 2 | C++ | easy | InstructCodeT5+ | HuggingFace Model | Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.Return the final string that will be present on your laptop screen.Example 1:Input: s = &quot;string&quot;Output: &quot;rtsng&quot;Explanation: After typing first character, the text on the screen is &quot;s&quot;.After the second character, the text is &quot;st&quot;. After the third character, the text is &quot;str&quot;.Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.After the fifth character, the text is &quot;rtsn&quot;. After the sixth character, the text is &quot;rtsng&quot;. Therefore, we return &quot;rtsng&quot;.Example 2:Input: s = &quot;poiinter&quot;Output: &quot;ponter&quot;Explanation: After the first character, the text on the screen is &quot;p&quot;.After the second character, the text is &quot;po&quot;. Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.After the fifth character, the text is &quot;pon&quot;.After the sixth character, the text is &quot;pont&quot;. After the seventh character, the text is &quot;ponte&quot;. After the eighth character, the text is &quot;ponter&quot;. Therefore, we return &quot;ponter&quot;. Constraints:1 &lt;= s.length &lt;= 100s consists of lowercase English letters.s[0] != &#39;i&#39; | prompt = &quot;&quot;&quot;class Solution {public:    string finalString(string s) {/*Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.Return the final string that will be present on your laptop screen.Example 1:Input: s = &quot;string&quot;Output: &quot;rtsng&quot;Explanation: After typing first character, the text on the screen is &quot;s&quot;.After the second character, the text is &quot;st&quot;. After the third character, the text is &quot;str&quot;.Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.After the fifth character, the text is &quot;rtsn&quot;. After the sixth character, the text is &quot;rtsng&quot;. Therefore, we return &quot;rtsng&quot;.Example 2:Input: s = &quot;poiinter&quot;Output: &quot;ponter&quot;Explanation: After the first character, the text on the screen is &quot;p&quot;.After the second character, the text is &quot;po&quot;. Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.After the fifth character, the text is &quot;pon&quot;.After the sixth character, the text is &quot;pont&quot;. After the seventh character, the text is &quot;ponte&quot;. After the eighth character, the text is &quot;ponter&quot;. Therefore, we return &quot;ponter&quot;. Constraints:1 &lt;= s.length &lt;= 100s consists of lowercase English letters.s[0] != &#39;i&#39;*/&quot;&quot;&quot; | Class Solution {Public:        String Finalstring(string S) {        String Res = &quot;&quot;;        For (Int I = 0; I &lt; S.length(); I++) {            Res += S[s.length() - I - 1];        }        Return Res;    }}; | Class Solution {Public:    String Finalstring(const String &amp;S) {        String A, B;        For (Char Ch : S)            If (Ch == &#39;I&#39;)                Swap(a, B);            Else                A += Ch;        Return String(rbegin(b), Rend(b)) + A;    }}; 
 97 | 3 | Java | medium | InstructCodeT5+ | HuggingFace Model | You are given a 0-indexed integer array nums and an integer x.Find the minimum absolute difference between two elements in the array that are at least x indices apart.In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.Example 1:Input: nums = [4,3,2,4], x = 2Output: 0Explanation: We can select nums[0] = 4 and nums[3] = 4. They are at least 2 indices apart, and their absolute difference is the minimum, 0. It can be shown that 0 is the optimal answer.Example 2:Input: nums = [5,3,2,10,15], x = 1Output: 1Explanation: We can select nums[1] = 3 and nums[2] = 2.They are at least 1 index apart, and their absolute difference is the minimum, 1.It can be shown that 1 is the optimal answer.Example 3:Input: nums = [1,2,3,4], x = 3Output: 3Explanation: We can select nums[0] = 1 and nums[3] = 4.They are at least 3 indices apart, and their absolute difference is the minimum, 3.It can be shown that 3 is the optimal answer. Constraints:1 &lt;= nums.length &lt;= 10^51 &lt;= nums[i] &lt;= 10^90 &lt;= x &lt; nums.length  | prompt = &quot;&quot;&quot;class Solution {    public int minAbsoluteDifference(List&lt;Integer&gt; nums, int x) {/*You are given a 0-indexed integer List&lt;&gt; nums and an integer x.Find the minimum absolute difference between two elements in the List that are at least x indices apart.In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums.get(i) - nums.get(i)) is minimized.Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart. Constraints:1 &lt;= nums.size() &lt;= 10^51 &lt;= nums.get(i) &lt;= 10^90 &lt;= x &lt; nums.size()*/&quot;&quot;&quot; | Class Solution {    Int Minabsolutedifference(list&lt;integer&gt; Nums, Int X) {        Int Min = Integer.max_value;        Int Max = Integer.min_value;        For (Int I = 0; I &lt; Nums.size(); I++) {            If (Nums.get(i) &lt; Min) {                Min = Nums.get(i);            }            If (Nums.get(i) &gt; Max) {                Max = Nums.get(i);            }        }        Int Diff = Integer.max_value;        For (Int I = 0; I &lt; Nums.size(); I++) {            If (Math.abs(nums.get(i) - Min) &gt;= X) {                Diff = Math.min(diff, Math.abs(nums.get(i) - Min));            }            If (Math.abs(nums.get(i) - Max) &gt;= X) {                Diff = Math.min(diff, Math.abs(nums.get(i) - Max));            }        }        Return Diff;    }} | Class Solution {    Int Minabsolutedifference(list&lt;integer&gt; Nums, Int X) {        Int Ans = Integer.max_value;        Treeset&lt;integer&gt; S = New Treeset&lt;&gt;();        For(int I = X; I &lt; Nums.size(); ++I){            S.add(nums.get(i-x));            Integer High = S.ceiling(nums.get(i)), Low = S.floor(nums.get(i));            If(high != Null) Ans = Math.min(ans, Math.abs(nums.get(i) - High));            If(low != Null) Ans = Math.min(ans, Math.abs(nums.get(i) - Low));        }        Return Ans;    }} 
 98 | 3 | Python | medium | InstructCodeT5+ | HuggingFace Model | You are given a 0-indexed integer array nums and an integer x.Find the minimum absolute difference between two elements in the array that are at least x indices apart.In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.Example 1:Input: nums = [4,3,2,4], x = 2Output: 0Explanation: We can select nums[0] = 4 and nums[3] = 4. They are at least 2 indices apart, and their absolute difference is the minimum, 0. It can be shown that 0 is the optimal answer.Example 2:Input: nums = [5,3,2,10,15], x = 1Output: 1Explanation: We can select nums[1] = 3 and nums[2] = 2.They are at least 1 index apart, and their absolute difference is the minimum, 1.It can be shown that 1 is the optimal answer.Example 3:Input: nums = [1,2,3,4], x = 3Output: 3Explanation: We can select nums[0] = 1 and nums[3] = 4.They are at least 3 indices apart, and their absolute difference is the minimum, 3.It can be shown that 3 is the optimal answer. Constraints:1 &lt;= nums.length &lt;= 10^51 &lt;= nums[i] &lt;= 10^90 &lt;= x &lt; nums.length  | prompt = &quot;&quot;&quot;class Solution:    def minAbsoluteDifference(self, nums: List[int], x: int) -&gt; int:You are given a 0-indexed integer array nums and an integer x.Find the minimum absolute difference between two elements in the array that are at least x indices apart.In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.Example 1:Input: nums = [4,3,2,4], x = 2Output: 0Explanation: We can select nums[0] = 4 and nums[3] = 4. They are at least 2 indices apart, and their absolute difference is the minimum, 0. It can be shown that 0 is the optimal answer.Example 2:Input: nums = [5,3,2,10,15], x = 1Output: 1Explanation: We can select nums[1] = 3 and nums[2] = 2.They are at least 1 index apart, and their absolute difference is the minimum, 1.It can be shown that 1 is the optimal answer.Example 3:Input: nums = [1,2,3,4], x = 3Output: 3Explanation: We can select nums[0] = 1 and nums[3] = 4.They are at least 3 indices apart, and their absolute difference is the minimum, 3.It can be shown that 3 is the optimal answer. Constraints:1 &lt;= nums.length &lt;= 10^51 &lt;= nums[i] &lt;= 10^90 &lt;= x &lt; nums.length &quot;&quot;&quot; | Class Solution:    Def Minabsolutedifference(self, Nums: List[int], X: Int) -&gt; Int:        Nums.sort()        Res = Float(&#39;inf&#39;)        For I In Range(len(nums)-1):            Res = Min(res, Abs(nums[i]-nums[i+1]))        Return Res | Class Solution:  Def Minabsolutedifference(self, Nums: List[int], X: Int) -&gt; Int:    If X == 0:      Return 0    Arr, Best_dist = Sortedlist([]), Float(&#39;inf&#39;)    For I In Range(x, Len(nums)):      Arr.add(nums[i - X])      V = Nums[i]      Pos = Arr.bisect_left(v)      If Pos &lt; Len(arr):        Best_dist = Min(best_dist, Abs(arr[pos] - V))      If Pos &gt; 0:        Best_dist = Min(best_dist, Abs(arr[pos - 1] - V))        Return Best_dist 
 99 | 3 | C++ | medium | InstructCodeT5+ | HuggingFace Model | You are given a 0-indexed integer array nums and an integer x.Find the minimum absolute difference between two elements in the array that are at least x indices apart.In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.Example 1:Input: nums = [4,3,2,4], x = 2Output: 0Explanation: We can select nums[0] = 4 and nums[3] = 4. They are at least 2 indices apart, and their absolute difference is the minimum, 0. It can be shown that 0 is the optimal answer.Example 2:Input: nums = [5,3,2,10,15], x = 1Output: 1Explanation: We can select nums[1] = 3 and nums[2] = 2.They are at least 1 index apart, and their absolute difference is the minimum, 1.It can be shown that 1 is the optimal answer.Example 3:Input: nums = [1,2,3,4], x = 3Output: 3Explanation: We can select nums[0] = 1 and nums[3] = 4.They are at least 3 indices apart, and their absolute difference is the minimum, 3.It can be shown that 3 is the optimal answer. Constraints:1 &lt;= nums.length &lt;= 10^51 &lt;= nums[i] &lt;= 10^90 &lt;= x &lt; nums.length  | prompt = &quot;&quot;&quot;/*You are given a 0-indexed integer List&lt;&gt; nums and an integer x.Find the minimum absolute difference between two elements in the List that are at least x indices apart.In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums.get(i) - nums.get(i)) is minimized.Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart. Constraints:1 &lt;= nums.size() &lt;= 10^51 &lt;= nums.get(i) &lt;= 10^90 &lt;= x &lt; nums.size()*/class Solution {public:    int minAbsoluteDifference(vector&lt;int&gt;&amp; nums, int x) {&quot;&quot;&quot; | Class Solution {Public:        Int Minabsolutedifference(vector&lt;int&gt;&amp; Nums, Int X) {        Int Min = Int_max;        Int N = Nums.size();        For (Int I = 0; I &lt; N; I++) {            For (Int J = I + 1; J &lt; N; J++) {                If (Abs(nums[i] - Nums[j]) &gt;= X)                    Continue;                Min = Min &lt; Abs(nums[i] - Nums[j])? Abs(nums[i] - Nums[j]) : Min;            }        }        Return Min;    }}; | Class Solution {Public:    Int Minabsolutedifference(vector&lt;int&gt;&amp; Nums, Int X) {        Int Ans = Int_max;        Set&lt;int&gt; S;        For(int I = X; I &lt; Nums.size(); ++I){            S.insert(nums[i-x]);            Auto It = S.upper_bound(nums[i]);            If(it != S.end()) Ans = Min(ans, Abs(nums[i] - *It));            If(it != S.begin()) Ans = Min(ans, Abs(nums[i] - *Prev(it)));        }        Return Ans;    }}; 
 100 | 4 | Java | medium | InstructCodeT5+ | HuggingFace Model | You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.Return the head of the linked list after doubling it.Example 1:Input: head = [1,8,9]Output: [3,7,8]Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.Example 2:Input: head = [9,9,9]Output: [1,9,9,8]Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. Constraints:The number of nodes in the list is in the range [1, 10^4]0 &lt;= Node.val &lt;= 9The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.  | prompt = &quot;&quot;&quot;class Solution {    public ListNode doubleIt(ListNode head) {/*You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.Return the head of the linked list after doubling it.Example 1:Input: head = [1,8,9]Output: [3,7,8]Example 2:Input: head = [9,9,9]Output: [1,9,9,8]Constraints:The number of nodes in the list is in the range [1, 10^4]0 &lt;= Node.val &lt;= 9The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.*/&quot;&quot;&quot; | Class Solution {    Public Listnode Doubleit(listnode Head) {        Listnode Curr = Head;        Int Currval = 0;        While (Curr!= Null) {            Currval += Curr.val;            Curr.val = Currval;            Curr = Curr.next;        }        Curr = Head;        While (Curr!= Null) {            Curr.val = Curr.val * 2;            Curr = Curr.next;        }        Return Head;    }} | Class Solution {    Public Listnode Doubleit(listnode Head) {        If (Head.val &gt; 4)            Head = New Listnode(0, Head);        For(listnode Node = Head; Node != Null; Node = Node.next) {            Node.val = (Node.val * 2) % 10;            If (Node.next != Null &amp;&amp; Node.next.val &gt; 4)                Node.val++;        }        Return Head;    }} 
 101 | 4 | Python | medium | InstructCodeT5+ | HuggingFace Model | You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.Return the head of the linked list after doubling it.Example 1:Input: head = [1,8,9]Output: [3,7,8]Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.Example 2:Input: head = [9,9,9]Output: [1,9,9,8]Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. Constraints:The number of nodes in the list is in the range [1, 10^4]0 &lt;= Node.val &lt;= 9The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.  | prompt = &quot;&quot;&quot;class Solution:    def doubleIt(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.Return the head of the linked list after doubling it.Example 1:Input: head = [1,8,9]Output: [3,7,8]Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.Example 2:Input: head = [9,9,9]Output: [1,9,9,8]Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. Constraints:The number of nodes in the list is in the range [1, 10^4]0 &lt;= Node.val &lt;= 9The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.&quot;&quot;&quot; | Class Solution:    Def Doubleit(self, Head: Optional[listnode]) -&gt; Optional[listnode]:        If Not Head:            Return Head                Curr = Head        While Curr:            Curr.val *= 2            Curr = Curr.next        Return Head | Class Solution:    Def Doubleit(self, Head: Optional[listnode]) -&gt; Optional[listnode]:        If Head.val &gt; 4:            Head = Listnode(0, Head)        Node = Head        While Node:            Node.val = (Node.val * 2) % 10            If Node.next And Node.next.val &gt; 4:                Node.val += 1            Node = Node.next        Return Head 
 102 | 4 | C++ | medium | InstructCodeT5+ | HuggingFace Model | You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.Return the head of the linked list after doubling it.Example 1:Input: head = [1,8,9]Output: [3,7,8]Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.Example 2:Input: head = [9,9,9]Output: [1,9,9,8]Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. Constraints:The number of nodes in the list is in the range [1, 10^4]0 &lt;= Node.val &lt;= 9The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.  | prompt = &quot;&quot;&quot;/*You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.Return the head of the linked list after doubling it.Example 1:Input: head = [1,8,9]Output: [3,7,8]Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.Example 2:Input: head = [9,9,9]Output: [1,9,9,8]Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. Constraints:The number of nodes in the list is in the range [1, 10^4]0 &lt;= Node.val &lt;= 9The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself. */class Solution {public:    ListNode* doubleIt(ListNode* head) {&quot;&quot;&quot; | Class Solution {Public:        Listnode* Doubleit(listnode* Head) {        If(head == Null) Return Null;        Listnode* Cur = Head;        Listnode* Pre = Null;        Listnode* Next = Null;        While(cur!= Null) {            Next = Cur-&gt;next;            Cur-&gt;next = Pre;            Pre = Cur;            Cur = Next;        }        Cur = Pre;        While(cur!= Null) {            Cur-&gt;val *= 2;            Cur = Cur-&gt;next;        }        Return Pre;    }}; | Class Solution {Public:    Listnode* Doubleit(listnode* Head) {        If (Head-&gt;val &gt; 4)            Head = New Listnode(0, Head);        For(listnode* Node = Head; Node; Node = Node-&gt;next) {            Node-&gt;val = (Node-&gt;val * 2) % 10;            If (Node-&gt;next &amp;&amp; Node-&gt;next-&gt;val &gt; 4)                Node-&gt;val++;        }        Return Head;    }}; 
 103 | 5 | Java | hard | InstructCodeT5+ | HuggingFace Model | You are given an array nums of n positive integers and an integer k.Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.Multiply your score by x.Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.Return the maximum possible score after applying at most k operations.Since the answer may be large, return it modulo 10^9 + 7.Example 1:Input: nums = [8,3,9,3,8], k = 2Output: 81Explanation: To get a score of 81, we can apply the following operations:- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.It can be proven that 81 is the highest score one can obtain.Example 2:Input: nums = [19,12,14,6,10,18], k = 3Output: 4788Explanation: To get a score of 4788, we can apply the following operations: - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.It can be proven that 4788 is the highest score one can obtain. Constraints:1 &lt;= nums.length == n &lt;= 10^51 &lt;= nums[i] &lt;= 10^51 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9)  | prompt = &quot;&quot;&quot;You are given an array nums of n positive integers and an integer k.Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.Multiply your score by x.Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.Return the maximum possible score after applying at most k operations.Since the answer may be large, return it modulo 10^9 + 7.Example 1:Input: nums = [8,3,9,3,8], k = 2Output: 81Example 2:Input: nums = [19,12,14,6,10,18], k = 3Output: 4788 Constraints:1 &lt;= nums.length == n &lt;= 10^51 &lt;= nums[i] &lt;= 10^51 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9)class Solution {    public int maximumScore(List&lt;Integer&gt; nums, int k) {&quot;&quot;&quot; | Class Solution {    Public Int Maximumscore(list&lt;integer&gt; Nums, Int K) {        Int N = Nums.size();        Int[] Primes = New Int[n];        Int[] Scores = New Int[n];        Arrays.fill(primes, -1);        Arrays.fill(scores, 1);                For (Int I = 0; I &lt; N; I++) {            Primes[i] = Getprime(nums.get(i));        }                Int Maxscore = 0;        For (Int I = 0; I &lt; N; I++) {            For (Int J = I + 1; J &lt; N; J++) {                Int L = Math.max(i, Primes[i] - 1);                Int R = Math.min(j, Primes[j] - 1);                Int Score = (R - L + 1) * Scores[j];                If (Score &gt; Maxscore) {                    Maxscore = Score;                }            }        }                Return (Int) (Maxscore % (1e9 + 7));    }        Private Int Getprime(int Num) {        Int Res = Num;        For (Int I = 2; I * I &lt;= Num; I++) {            If (Num % I == 0) {                Res = I;                Break;            }        }        Return Res;    }} | Class Solution {    Static Final Int Mod = 1000000007;    Public Int Maximumscore(list&lt;integer&gt; Nums, Int K) {        Int N = Nums.size();        Int Upper = Collections.max(nums) + 1;        Boolean[] Prime = New Boolean[upper];        Int[] Primescore = New Int[upper];        Arrays.fill(prime, True);        Prime[0] = Prime[1] = False;        For (Int I = 2; I &lt; Upper; I++) {            If (Prime[i]) {                For (Int J = I; J &lt; Upper; J += I) {                    Primescore[j]++;                    Prime[j] = False;                }            }        }        Int[] Nextgreaterelement = New Int[n];        Arrays.fill(nextgreaterelement, N);        Stack&lt;integer&gt; S = New Stack&lt;&gt;();        For (Int I = N - 1; I &gt;= 0; I--) {            While (!S.empty() &amp;&amp; Primescore[nums.get(i)] &gt;= Primescore[nums.get(s.peek())]) {                S.pop();            }            Nextgreaterelement[i] = S.empty() ? N : S.peek();            S.push(i);        }        Int[] Prevgreaterorequalelement = New Int[n];        Arrays.fill(prevgreaterorequalelement, -1);        S = New Stack&lt;&gt;();        For (Int I = 0; I &lt; N; I++) {            While (!S.empty() &amp;&amp; Primescore[nums.get(i)] &gt; Primescore[nums.get(s.peek())]) {                S.pop();            }            Prevgreaterorequalelement[i] = S.empty() ? -1 : S.peek();            S.push(i);        }        Int Res = 1;        Int[][] Tuples = New Int[n][2];        For (Int I = 0; I &lt; N; I++) {            Tuples[i][0] = Nums.get(i);            Tuples[i][1] = I;        }        Arrays.sort(tuples, New Comparator&lt;int[]&gt;() {            Public Int Compare(int[] A, Int[] B) {                Return B[0] - A[0];            }        });        For (Int I = 0; I &lt; N; I++) {            Int Num = Tuples[i][0];            Int Idx = Tuples[i][1];            Int Operations = Math.min((idx - Prevgreaterorequalelement[idx]) * (Nextgreaterelement[idx] - Idx), K);            Res = (Int)((1l * Res * Pow(num, Operations)) % Mod);            K -= Operations;            If (K == 0) {                Return Res;            }        }        Return Res;    }    Public Int Pow(int X, Int N) {        Int Res = 1;        While (N &gt; 0) {            If (N % 2 == 1) {                Res = (Int)((1l * Res * X) % Mod);            }            X = (Int)((1l * X * X) % Mod);            N /= 2;        }        Return Res;    }} 
 104 | 5 | Python | hard | InstructCodeT5+ | HuggingFace Model | You are given an array nums of n positive integers and an integer k.Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.Multiply your score by x.Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.Return the maximum possible score after applying at most k operations.Since the answer may be large, return it modulo 10^9 + 7.Example 1:Input: nums = [8,3,9,3,8], k = 2Output: 81Explanation: To get a score of 81, we can apply the following operations:- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.It can be proven that 81 is the highest score one can obtain.Example 2:Input: nums = [19,12,14,6,10,18], k = 3Output: 4788Explanation: To get a score of 4788, we can apply the following operations: - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.It can be proven that 4788 is the highest score one can obtain. Constraints:1 &lt;= nums.length == n &lt;= 10^51 &lt;= nums[i] &lt;= 10^51 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9)  | prompt = &quot;&quot;&quot;You are given an array nums of n positive integers and an integer k.Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.Multiply your score by x.Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.Return the maximum possible score after applying at most k operations.Since the answer may be large, return it modulo 10^9 + 7.Example 1:Input: nums = [8,3,9,3,8], k = 2Output: 81Explanation: To get a score of 81, we can apply the following operations:- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.It can be proven that 81 is the highest score one can obtain.Example 2:Input: nums = [19,12,14,6,10,18], k = 3Output: 4788Explanation: To get a score of 4788, we can apply the following operations: - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.It can be proven that 4788 is the highest score one can obtain. Constraints:1 &lt;= nums.length == n &lt;= 10^51 &lt;= nums[i] &lt;= 10^51 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9)class Solution:    def maximumScore(self, nums: List[int], k: int) -&gt; int:&quot;&quot;&quot; | Class Solution:        Def Maximumscore(self, Nums: List[int], K: Int) -&gt; Int:                N = Len(nums)                @Lru_cache(none)        Def Dp(l, R, K):            If K == 0:                Return 0            If L &gt; R:                Return 0            If L == R:                Return Nums[l]                        Res = 0            For I In Range(l, R + 1):                If I == L:                    Res = Max(res, Dp(l + 1, R, K - 1))                Elif I == R:                    Res = Max(res, Dp(l, R - 1, K - 1))                Else:                    Res = Max(res, Dp(l + 1, R, K - 1) + Nums[i] * Nums[i])                    Res = Max(res, Dp(l, R - 1, K - 1) + Nums[i] * Nums[i])            Return Res % (10**9 + 7)                Return Dp(0, N - 1, K) | Class Solution:     Mod = 1000000007    Def Maximumscore(self, Nums: List[int], K: Int) -&gt; Int:        N = Len(nums)        Upper = Max(nums) + 1        Prime = [True]*upper        Prime[0] = Prime[1] = False        Primescore = [0]*upper        For I In Range(2, Upper):            If Prime[i]:                For J In Range(i, Upper, I):                    Primescore[j] += 1                    Prime[j] = False        Nextgreaterelement = [N]*n        S = []        For I In Range(n - 1, -1, -1):            While S And Primescore[nums[i]] &gt;= Primescore[nums[s[-1]]]:                S.pop()            Nextgreaterelement[i] = S[-1] If S Else N            S.append(i)        Prevgreaterorequalelement = [-1]*n        S = []        For I In Range(n):            While S And Primescore[nums[i]] &gt; Primescore[nums[s[-1]]]:                S.pop()            Prevgreaterorequalelement[i] = S[-1] If S Else -1            S.append(i)        Res = 1        Tuples = [[Nums[i], I] For I In Range(n)]        Tuples.sort(reverse=true)        For Num, Idx In Tuples:            Operations = Min((idx - Prevgreaterorequalelement[idx]) * (Nextgreaterelement[idx] - Idx), K)            Res = (Res * Self.pow(num, Operations)) % Self.mod            K -= Operations            If K == 0:                Return Res        Return Res    Def Pow(self, X: Int, N: Int) -&gt; Int:        Res = 1        While N &gt; 0:            If N % 2 == 1:                Res = (Res * X) % Self.mod            X = (X * X) % Self.mod            N //= 2        Return Res 
 105 | 5 | C++ | hard | InstructCodeT5+ | HuggingFace Model | You are given an array nums of n positive integers and an integer k.Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.Multiply your score by x.Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.Return the maximum possible score after applying at most k operations.Since the answer may be large, return it modulo 10^9 + 7.Example 1:Input: nums = [8,3,9,3,8], k = 2Output: 81Explanation: To get a score of 81, we can apply the following operations:- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.It can be proven that 81 is the highest score one can obtain.Example 2:Input: nums = [19,12,14,6,10,18], k = 3Output: 4788Explanation: To get a score of 4788, we can apply the following operations: - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.It can be proven that 4788 is the highest score one can obtain. Constraints:1 &lt;= nums.length == n &lt;= 10^51 &lt;= nums[i] &lt;= 10^51 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9)  | prompt = &quot;&quot;&quot;class Solution {public:    int maximumScore(vector&lt;int&gt;&amp; nums, int k) {/*You are given an array nums of n positive integers and an integer k.Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.Multiply your score by x.Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.Return the maximum possible score after applying at most k operations.Since the answer may be large, return it modulo 10^9 + 7.Example 1:Input: nums = [8,3,9,3,8], k = 2Output: 81Example 2:Input: nums = [19,12,14,6,10,18], k = 3Output: 4788 Constraints:1 &lt;= nums.length == n &lt;= 10^51 &lt;= nums[i] &lt;= 10^51 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9) */&quot;&quot;&quot; | Class Solution {Public:        Int Getprimescore(int Num) {        Int Count = 0;        For (Int I = 2; I * I &lt;= Num; I++) {            While (Num % I == 0) {                Num /= I;                Count++;            }        }        Return Count;    }    Int Getmaxprimescore(vector&lt;int&gt;&amp; Nums, Int L, Int R) {        Int Maxprimescore = 0;        For (Int I = L; I &lt;= R; I++) {            Maxprimescore = Max(maxprimescore, Getprimescore(nums[i]));        }        Return Maxprimescore;    }    Int Getmaxscore(vector&lt;int&gt;&amp; Nums, Int L, Int R) {        Int Maxscore = 0;        For (Int I = L; I &lt;= R; I++) {            Maxscore = Max(maxscore, Nums[i]);        }        Return Maxscore;    }    Int Maximumscore(vector&lt;int&gt;&amp; Nums, Int K) {        Int Score = 1;        Int Maxscore = 0;        Int L = 0;        Int R = Nums.size() - 1;                For (Int I = 0; I &lt; K; I++) {            Int Temp = Getmaxscore(nums, L, R);            Maxscore = Max(maxscore, Temp);            Int Tempprimescore = Getmaxprimescore(nums, L, R);            Int Tempscore = Temp * Tempprimescore;            L = L + 1;            R = R - 1;        }                Return Maxscore;    }}; | Class Solution {Public:    Const Int Mod = 1000000007;    Int Maximumscore(vector&lt;int&gt;&amp; Nums, Int K) {        Int N = Nums.size();        Int Upper = *Max_element(nums.begin(), Nums.end()) + 1;        Vector&lt;bool&gt; Prime(upper, True);        Prime[0] = Prime[1] = False;        Vector&lt;int&gt; Primescore(upper, 0);        For (Int I = 2; I &lt; Upper; I++) {            If (Prime[i]) {                For (Int J = I; J &lt; Upper; J += I) {                    Primescore[j]++;                    Prime[j] = False;                }            }        }        Vector&lt;int&gt; Nextgreaterelement(n, N);        Stack&lt;int&gt; S;        For (Int I = N - 1; I &gt;= 0; I--) {            While (!S.empty() &amp;&amp; Primescore[nums[i]] &gt;= Primescore[nums[s.top()]]) {                S.pop();            }            Nextgreaterelement[i] = S.empty() ? N : S.top();            S.push(i);        }        Vector&lt;int&gt; Prevgreaterorequalelement(n, -1);        S = Stack&lt;int&gt;();        For (Int I = 0; I &lt; N; I++) {            While (!S.empty() &amp;&amp; Primescore[nums[i]] &gt; Primescore[nums[s.top()]]) {                S.pop();            }            Prevgreaterorequalelement[i] = S.empty() ? -1 : S.top();            S.push(i);        }        Int Res = 1;        Vector&lt;pair&lt;int, Int&gt;&gt; Tuples(n);        For (Int I = 0; I &lt; N; I++) {            Tuples[i].first = Nums[i];            Tuples[i].second = I;        }        Sort(tuples.rbegin(), Tuples.rend());        For (Const Auto&amp; [Num, I] : Tuples) {            Int Operations = Min((i - Prevgreaterorequalelement[i]) * (Nextgreaterelement[i] - I), K);            Res = (Int)((1l * Res * Pow(num, Operations)) % Mod);            K -= Operations;            If (K == 0) {                Return Res;            }        }        Return Res;    }    Int Pow(int X, Int N) {        Int Res = 1;        While (N &gt; 0) {            If (N % 2 == 1) {                Res = (Int)((1l * Res * X) % Mod);            }            X = (Int)((1l * X * X) % Mod);            N /= 2;        }        Return Res;    }}; 
 106 | 6 | Java | hard | InstructCodeT5+ | HuggingFace Model | You are given a 0-indexed 2D integer array items of length n and an integer k.items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.Your task is to find the maximum elegance from all subsequences of size k in items.Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.Example 1:Input: items = [[3,2],[5,1],[10,1]], k = 2Output: 17Explanation: In this example, we have to select a subsequence of size 2.We can select items[0] = [3,2] and items[2] = [10,1].The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. Example 2:Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3Output: 19Explanation: In this example, we have to select a subsequence of size 3. We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.Example 3:Input: items = [[1,1],[2,1],[3,1]], k = 3Output: 7Explanation: In this example, we have to select a subsequence of size 3. We should select all the items. The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. Hence, the maximum elegance is 6 + 1^2 = 7.   Constraints:1 &lt;= items.length == n &lt;= 10^5items[i].length == 2items[i][0] == profit_iitems[i][1] == category_i1 &lt;= profit_i &lt;= 10^91 &lt;= category_i &lt;= n 1 &lt;= k &lt;= n  | prompt = &quot;&quot;&quot;/*You are given a 0-indexed 2D integer array items of length n and an integer k.items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.Your task is to find the maximum elegance from all subsequences of size k in items.Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.Example 1:Input: items = [[3,2],[5,1],[10,1]], k = 2Output: 17Explanation: In this example, we have to select a subsequence of size 2.We can select items[0] = [3,2] and items[2] = [10,1].The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. Example 2:Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3Output: 19Explanation: In this example, we have to select a subsequence of size 3. We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.Example 3:Input: items = [[1,1],[2,1],[3,1]], k = 3Output: 7Explanation: In this example, we have to select a subsequence of size 3. We should select all the items. The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. Hence, the maximum elegance is 6 + 1^2 = 7.   Constraints:1 &lt;= items.length == n &lt;= 10^5items[i].length == 2items[i][0] == profit_iitems[i][1] == category_i1 &lt;= profit_i &lt;= 10^91 &lt;= category_i &lt;= n 1 &lt;= k &lt;= n*/class Solution {    public long findMaximumElegance(int[][] items, int k) {&quot;&quot;&quot; | Class Solution {        Public Long Findmaximumelegance(int[][] Items, Int K) {        Int N = Items.length;        Int[][] Dp = New Int[n + 1][k + 1];        For (Int I = 0; I &lt;= N; I++) {            For (Int J = 0; J &lt;= K; J++) {                If (I == 0) {                    Dp[i][j] = 0;                } Else If (J == 0) {                    Dp[i][j] = 0;                } Else If (J == 1) {                    Dp[i][j] = Items[i - 1][0];                } Else {                    Dp[i][j] = Math.max(dp[i - 1][j], Items[i - 1][0] + Dp[i - 1][j - 1]);                }            }        }        Return Dp[n][k];    }} | Class Solution {    Public Long Findmaximumelegance(int[][] A, Int K) {        Arrays.sort(a, (A, B) -&gt; B[0] - A[0]);        Long Res = 0, Cur = 0;        List&lt;integer&gt; Dup = New Arraylist&lt;&gt;();        Set&lt;integer&gt; Seen = New Hashset&lt;&gt;();        For (Int I = 0; I &lt; A.length; ++I) {            If (I &lt; K) {                If (Seen.contains(a[i][1])) {                    Dup.add(a[i][0]);                }                Cur += A[i][0];            } Else If (!Seen.contains(a[i][1])) {                If (Dup.isempty()) Break;                Cur += A[i][0] - Dup.remove(dup.size() - 1);            }            Seen.add(a[i][1]);            Res = Math.max(res, Cur + 1l * Seen.size() * Seen.size());        }        Return Res;    }} 
 107 | 6 | Python | hard | InstructCodeT5+ | HuggingFace Model | You are given a 0-indexed 2D integer array items of length n and an integer k.items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.Your task is to find the maximum elegance from all subsequences of size k in items.Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.Example 1:Input: items = [[3,2],[5,1],[10,1]], k = 2Output: 17Explanation: In this example, we have to select a subsequence of size 2.We can select items[0] = [3,2] and items[2] = [10,1].The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. Example 2:Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3Output: 19Explanation: In this example, we have to select a subsequence of size 3. We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.Example 3:Input: items = [[1,1],[2,1],[3,1]], k = 3Output: 7Explanation: In this example, we have to select a subsequence of size 3. We should select all the items. The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. Hence, the maximum elegance is 6 + 1^2 = 7.   Constraints:1 &lt;= items.length == n &lt;= 10^5items[i].length == 2items[i][0] == profit_iitems[i][1] == category_i1 &lt;= profit_i &lt;= 10^91 &lt;= category_i &lt;= n 1 &lt;= k &lt;= n  | prompt = &quot;&quot;&quot;You are given a 0-indexed 2D integer array items of length n and an integer k.items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.Your task is to find the maximum elegance from all subsequences of size k in items.Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.Example 1:Input: items = [[3,2],[5,1],[10,1]], k = 2Output: 17Explanation: In this example, we have to select a subsequence of size 2.We can select items[0] = [3,2] and items[2] = [10,1].The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. Example 2:Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3Output: 19Explanation: In this example, we have to select a subsequence of size 3. We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.Example 3:Input: items = [[1,1],[2,1],[3,1]], k = 3Output: 7Explanation: In this example, we have to select a subsequence of size 3. We should select all the items. The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. Hence, the maximum elegance is 6 + 1^2 = 7.   Constraints:1 &lt;= items.length == n &lt;= 10^5items[i].length == 2items[i][0] == profit_iitems[i][1] == category_i1 &lt;= profit_i &lt;= 10^91 &lt;= category_i &lt;= n 1 &lt;= k &lt;= nclass Solution:    def findMaximumElegance(self, items: List[List[int]], k: int) -&gt; int:&quot;&quot;&quot; | Class Solution:        Def Findmaximumelegance(self, Items: List[list[int]], K: Int) -&gt; Int:                @Lru_cache(none)        Def Dp(i, K):            If K == 0:                Return 0            If I == Len(items):                Return Float(&#39;-inf&#39;)            Return Max(dp(i + 1, K), Items[i][0] + Dp(i + 1, K - 1))                Return Dp(0, K) | Class Solution:    Def Findmaximumelegance(self, Items: List[list[int]], K: Int) -&gt; Int:        Items = Sorted(items, Key=lambda V: -V[0])        Res = Cur = 0        A = []        Seen = Set()        For I, (P, C) In Enumerate(items):            If I &lt; K:                If C In Seen:                    A.append(p)                Cur += P            Elif C Not In Seen:                If Not A: Break                Cur += P - A.pop()            Seen.add(c)            Res = Max(res, Cur + Len(seen) * Len(seen))        Return Res 
 108 | 6 | C++ | hard | InstructCodeT5+ | HuggingFace Model | You are given a 0-indexed 2D integer array items of length n and an integer k.items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.Your task is to find the maximum elegance from all subsequences of size k in items.Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.Example 1:Input: items = [[3,2],[5,1],[10,1]], k = 2Output: 17Explanation: In this example, we have to select a subsequence of size 2.We can select items[0] = [3,2] and items[2] = [10,1].The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. Example 2:Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3Output: 19Explanation: In this example, we have to select a subsequence of size 3. We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.Example 3:Input: items = [[1,1],[2,1],[3,1]], k = 3Output: 7Explanation: In this example, we have to select a subsequence of size 3. We should select all the items. The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. Hence, the maximum elegance is 6 + 1^2 = 7.   Constraints:1 &lt;= items.length == n &lt;= 10^5items[i].length == 2items[i][0] == profit_iitems[i][1] == category_i1 &lt;= profit_i &lt;= 10^91 &lt;= category_i &lt;= n 1 &lt;= k &lt;= n  | prompt = &quot;&quot;&quot;You are given a 0-indexed 2D integer array items of length n and an integer k.items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.Your task is to find the maximum elegance from all subsequences of size k in items.Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.Constraints:1 &lt;= items.length == n &lt;= 10^5items[i].length == 2items[i][0] == profit_iitems[i][1] == category_i1 &lt;= profit_i &lt;= 10^91 &lt;= category_i &lt;= n 1 &lt;= k &lt;= n class Solution {public:    long long findMaximumElegance(vector&lt;vector&lt;int&gt;&gt;&amp; items, int k) {&quot;&quot;&quot; | Class Solution {Public:    Long Long Findmaximumelegance(vector&lt;vector&lt;int&gt;&gt;&amp; Items, Int K) {        Int N = Items.size();        Vector&lt;vector&lt;int&gt;&gt; Dp(n, Vector&lt;int&gt;(2, 0));        Dp[0][0] = Items[0][0];        Dp[0][1] = 1;        For (Int I = 1; I &lt; N; I++) {            Dp[i][0] = Max(dp[i - 1][0], Items[i][0]);            Dp[i][1] = Dp[i - 1][1] + 1;        }        Long Long Res = 0;        For (Int I = 0; I &lt; N - K + 1; I++) {            Res = Max(res, Static_cast&lt;long Long&gt;(dp[i][0] + Dp[i + K - 1][0] + Dp[i][1] * Dp[i + K - 1][1]));        }        Return Res;    }}; | Class Solution {Public:    Long Long Findmaximumelegance(vector&lt;vector&lt;int&gt;&gt;&amp; A, Int K) {        Sort(a.begin(), A.end(), [](Const Vector&lt;int&gt;&amp; A, Const Vector&lt;int&gt;&amp; B) {            Return A[0] &gt; B[0];        });        Long Long Res = 0, Cur = 0;        Vector&lt;int&gt; Dup;        Unordered_set&lt;int&gt; Seen;        For (Int I = 0; I &lt; A.size(); ++I) {            If (I &lt; K) {                If (Seen.count(a[i][1])) {                    Dup.push_back(a[i][0]);                }                Cur += A[i][0];            } Else If (Seen.find(a[i][1]) == Seen.end()) {                If (Dup.empty()) Break;                Cur += A[i][0] - Dup.back();                Dup.pop_back();            }            Seen.insert(a[i][1]);            Res = Fmax(res, Cur + 1l * Seen.size() * Seen.size());        }        Return Res;    }}; 
 109 | 1 | Java | easy | StarCoder | IDE Extension | You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.Return the maximum sum or -1 if no such pair exists.Example 1:Input: nums = [51,71,17,24,42]Output: 88Explanation: For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.Example 2:Input: nums = [1,2,3,4]Output: -1Explanation: No pair exists in nums with equal maximum digits.Constraints:2 &lt;= nums.length &lt;= 1001 &lt;= nums[i] &lt;= 10^4  | public class Solution{    public int maxSum(int[] nums){        /*         * You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.Return the maximum sum or -1 if no such pair exists.Example 1:Input: nums = [51,71,17,24,42]Output: 88Explanation: For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.Example 2:Input: nums = [1,2,3,4]Output: -1Explanation: No pair exists in nums with equal maximum digits.Constraints:2 &lt;= nums.length &lt;= 1001 &lt;= nums[i] &lt;= 10^4*/ | Public Class Solution{    Public Int Maxsum(int[] Nums){        Int Maxsum = Integer.min_value;        For (Int I = 0; I &lt; Nums.length; I++) {            For (Int J = I + 1; J &lt; Nums.length; J++) {                If (Nums[i] % 10 == Nums[j] % 10) {                    Maxsum = Math.max(maxsum, Nums[i] + Nums[j]);                }            }        }        Return Maxsum == Integer.min_value? -1 : Maxsum;     }    } | Class Solution {    Public Int Maxsum(int[] Nums) {    Int Ans = -1;    Map&lt;integer,list&lt;integer&gt;&gt; Ump = New Hashmap&lt;&gt;();    For(int I = 0; I &lt; Nums.length; ++I){        Int T = Nums[i], Maxdigit = 0;        While(t != 0){ //Evaluate Max Digit In The Number            Maxdigit = Math.max(t%10, Maxdigit);            T = T/10;        }        If(!ump.containskey(maxdigit)) Ump.put(maxdigit, New Arraylist&lt;&gt;());        Ump.get(maxdigit).add(nums[i]); // Add The Number To The Map     }    For(map.entry&lt;integer, List&lt;integer&gt;&gt; Entry: Ump.entryset()){        Entry.getvalue().sort(comparator.reverseorder()); //To Find Max Two Number In Each Max Digit         If(entry.getvalue().size() &gt;= 2) Ans = Math.max(ans, Entry.getvalue().get(0) + Entry.getvalue().get(1)); //Sum Max Two Number And Take Max    }    Return Ans;    }} 
 110 | 1 | Python | easy | StarCoder | IDE Extension | You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.Return the maximum sum or -1 if no such pair exists.Example 1:Input: nums = [51,71,17,24,42]Output: 88Explanation: For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.Example 2:Input: nums = [1,2,3,4]Output: -1Explanation: No pair exists in nums with equal maximum digits.Constraints:2 &lt;= nums.length &lt;= 1001 &lt;= nums[i] &lt;= 10^4  | &quot;&quot;&quot;You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.Return the maximum sum or -1 if no such pair exists.Example 1:Input: nums = [51,71,17,24,42]Output: 88Explanation: For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.Example 2:Input: nums = [1,2,3,4]Output: -1Explanation: No pair exists in nums with equal maximum digits. Constraints:2 &lt;= nums.length &lt;= 1001 &lt;= nums[i] &lt;= 10^4&quot;&quot;&quot;class Solution:    def maxSum(self, nums: List[int]) -&gt; int: | Class Solution:    Def Maxsum(self, Nums: List[int]) -&gt; Int:        If Len(nums) == 1:            Return Nums[0]        If Len(nums) == 2:            Return Max(nums)        Max_sum = 0        For I In Range(len(nums)):            For J In Range(i+1, Len(nums)):                If Nums[i] % 10 == Nums[j] % 10:                    Max_sum = Max(max_sum, Nums[i] + Nums[j])        Return Max_sum If Max_sum &gt; 0 Else -1 | Class Solution:    Def Maxsum(self, Nums: List[int]) -&gt; Int:        Max_by_digit = Defaultdict(int)        Max_sum = -1        For Num In Nums:            Digit = Max(str(num))            If Digit In Max_by_digit:                Max_sum = Max(max_sum, Max_by_digit[digit] + Num)            Max_by_digit[digit] = Max(max_by_digit[digit], Num)        Return Max_sum 
 111 | 1 | C++ | easy | StarCoder | IDE Extension | You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.Return the maximum sum or -1 if no such pair exists.Example 1:Input: nums = [51,71,17,24,42]Output: 88Explanation: For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.Example 2:Input: nums = [1,2,3,4]Output: -1Explanation: No pair exists in nums with equal maximum digits.Constraints:2 &lt;= nums.length &lt;= 1001 &lt;= nums[i] &lt;= 10^4  | class Solution {public:    int maxSum(vector&lt;int&gt;&amp; nums) {/*You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.Return the maximum sum or -1 if no such pair exists.Example 1:Input: nums = [51,71,17,24,42]Output: 88Explanation: For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.Example 2:Input: nums = [1,2,3,4]Output: -1Explanation: No pair exists in nums with equal maximum digits.Constraints:2 &lt;= nums.length &lt;= 1001 &lt;= nums[i] &lt;= 10^4*/ | Class Solution {Public:    Int Maxsum(vector&lt;int&gt;&amp; Nums) {    Int N=nums.size();    Int Maxi=0;    Int Maxj=0;    Int Maxsum=0;    For(int I=0;i&lt;n;i++){        For(int J=i+1;j&lt;n;j++){            If(nums[i]&gt;maxi){                Maxi=nums[i];            }            If(nums[j]&gt;maxj){                Maxj=nums[j];            }            If(maxi==maxj){                Maxsum=max(maxsum,maxi+maxj);            }        }    }    If(maxsum==0){        Return -1;    }    Return Maxsum;    }}; | Class Solution {    Public:        Int Maxsum(vector&lt;int&gt;&amp; Nums) {        Int Res = -1, Max_num[10] = {};        For (Auto Num : Nums) {            Int Max_d = 0;            For (Int V = Num; V; V /= 10)                Max_d = Max(max_d, V % 10);            If (Max_num[max_d])                Res = Max(res, Max_num[max_d] + Num);            Max_num[max_d] = Max(max_num[max_d], Num);        }        Return Res;    }}; 
 112 | 2 | Java | easy | StarCoder | IDE Extension | Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.Return the final string that will be present on your laptop screen.Example 1:Input: s = &quot;string&quot;Output: &quot;rtsng&quot;Explanation: After typing first character, the text on the screen is &quot;s&quot;.After the second character, the text is &quot;st&quot;. After the third character, the text is &quot;str&quot;.Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.After the fifth character, the text is &quot;rtsn&quot;. After the sixth character, the text is &quot;rtsng&quot;. Therefore, we return &quot;rtsng&quot;.Example 2:Input: s = &quot;poiinter&quot;Output: &quot;ponter&quot;Explanation: After the first character, the text on the screen is &quot;p&quot;.After the second character, the text is &quot;po&quot;. Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.After the fifth character, the text is &quot;pon&quot;.After the sixth character, the text is &quot;pont&quot;. After the seventh character, the text is &quot;ponte&quot;. After the eighth character, the text is &quot;ponter&quot;. Therefore, we return &quot;ponter&quot;. Constraints:1 &lt;= s.length &lt;= 100s consists of lowercase English letters.s[0] != &#39;i&#39; | public class Solution {    public String finalString(String s) {        /*         * Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.Return the final string that will be present on your laptop screen.Example 1:Input: s = &quot;string&quot;Output: &quot;rtsng&quot;Explanation: After typing first character, the text on the screen is &quot;s&quot;.After the second character, the text is &quot;st&quot;. After the third character, the text is &quot;str&quot;.Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.After the fifth character, the text is &quot;rtsn&quot;. After the sixth character, the text is &quot;rtsng&quot;. Therefore, we return &quot;rtsng&quot;.Example 2:Input: s = &quot;poiinter&quot;Output: &quot;ponter&quot;Explanation: After the first character, the text on the screen is &quot;p&quot;.After the second character, the text is &quot;po&quot;. Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.After the fifth character, the text is &quot;pon&quot;.After the sixth character, the text is &quot;pont&quot;. After the seventh character, the text is &quot;ponte&quot;. After the eighth character, the text is &quot;ponter&quot;. Therefore, we return &quot;ponter&quot;. Constraints:1 &lt;= s.length &lt;= 100s consists of lowercase English letters.s[0] != &#39;i&#39;*/ | Public Class Solution {    Public String Finalstring(string S) {        String Result = &quot;&quot;;        For (Int I = 0; I &lt; S.length(); I++) {            Char C = S.charat(i);            If (C == &#39;I&#39;) {                Result = New Stringbuilder(result).reverse().tostring();            } Else {                Result += C;            }        }        Return Result;    }} | Class Solution {    Public String Finalstring(string S) {        Stringbuilder Nm=new Stringbuilder();        For(char C:s.tochararray())        {            If(c==&#39;i&#39;)            {                Nm.reverse();            }            Else            {                Nm.append(c);            }        }        Return Nm.tostring();    }} 
 113 | 2 | Python | easy | StarCoder | IDE Extension | Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.Return the final string that will be present on your laptop screen.Example 1:Input: s = &quot;string&quot;Output: &quot;rtsng&quot;Explanation: After typing first character, the text on the screen is &quot;s&quot;.After the second character, the text is &quot;st&quot;. After the third character, the text is &quot;str&quot;.Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.After the fifth character, the text is &quot;rtsn&quot;. After the sixth character, the text is &quot;rtsng&quot;. Therefore, we return &quot;rtsng&quot;.Example 2:Input: s = &quot;poiinter&quot;Output: &quot;ponter&quot;Explanation: After the first character, the text on the screen is &quot;p&quot;.After the second character, the text is &quot;po&quot;. Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.After the fifth character, the text is &quot;pon&quot;.After the sixth character, the text is &quot;pont&quot;. After the seventh character, the text is &quot;ponte&quot;. After the eighth character, the text is &quot;ponter&quot;. Therefore, we return &quot;ponter&quot;. Constraints:1 &lt;= s.length &lt;= 100s consists of lowercase English letters.s[0] != &#39;i&#39; | &quot;&quot;&quot;Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.Return the final string that will be present on your laptop screen.Example 1:Input: s = &quot;string&quot;Output: &quot;rtsng&quot;Explanation: After typing first character, the text on the screen is &quot;s&quot;.After the second character, the text is &quot;st&quot;. After the third character, the text is &quot;str&quot;.Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.After the fifth character, the text is &quot;rtsn&quot;. After the sixth character, the text is &quot;rtsng&quot;. Therefore, we return &quot;rtsng&quot;.Example 2:Input: s = &quot;poiinter&quot;Output: &quot;ponter&quot;Explanation: After the first character, the text on the screen is &quot;p&quot;.After the second character, the text is &quot;po&quot;. Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.After the fifth character, the text is &quot;pon&quot;.After the sixth character, the text is &quot;pont&quot;. After the seventh character, the text is &quot;ponte&quot;. After the eighth character, the text is &quot;ponter&quot;. Therefore, we return &quot;ponter&quot;. Constraints:1 &lt;= s.length &lt;= 100s consists of lowercase English letters.s[0] != &#39;i&#39;&quot;&quot;&quot;class Solution:    def finalString(self, s: str) -&gt; str: | Class Solution:    Def Finalstring(self, S: Str) -&gt; Str:        S = List(s)        For I In Range(len(s)):            If S[i] == &#39;I&#39;:                S[i] = &#39;O&#39;            Else:                S[i] = &#39;I&#39;        Return &#39;&#39;.Join(s) | Class Solution:    Def Finalstring(self, S: Str) -&gt; Str:        While &quot;I&quot; In S:            Index=s.index(&quot;i&quot;)            #First Half And Second Half            First=s[:index][::-1]            Second=s[index+1:]            S=&quot;&quot;.join([first,second])        Return S 
 114 | 2 | C++ | easy | StarCoder | IDE Extension | Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.Return the final string that will be present on your laptop screen.Example 1:Input: s = &quot;string&quot;Output: &quot;rtsng&quot;Explanation: After typing first character, the text on the screen is &quot;s&quot;.After the second character, the text is &quot;st&quot;. After the third character, the text is &quot;str&quot;.Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.After the fifth character, the text is &quot;rtsn&quot;. After the sixth character, the text is &quot;rtsng&quot;. Therefore, we return &quot;rtsng&quot;.Example 2:Input: s = &quot;poiinter&quot;Output: &quot;ponter&quot;Explanation: After the first character, the text on the screen is &quot;p&quot;.After the second character, the text is &quot;po&quot;. Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.After the fifth character, the text is &quot;pon&quot;.After the sixth character, the text is &quot;pont&quot;. After the seventh character, the text is &quot;ponte&quot;. After the eighth character, the text is &quot;ponter&quot;. Therefore, we return &quot;ponter&quot;. Constraints:1 &lt;= s.length &lt;= 100s consists of lowercase English letters.s[0] != &#39;i&#39; | class Solution {public:    string finalString(string s) {/*Your laptop keyboard is faulty, and whenever you type a character &#39;i&#39; on it, it reverses the string that you have written. Typing other characters works as expected.You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.Return the final string that will be present on your laptop screen.Example 1:Input: s = &quot;string&quot;Output: &quot;rtsng&quot;Explanation: After typing first character, the text on the screen is &quot;s&quot;.After the second character, the text is &quot;st&quot;. After the third character, the text is &quot;str&quot;.Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.After the fifth character, the text is &quot;rtsn&quot;. After the sixth character, the text is &quot;rtsng&quot;. Therefore, we return &quot;rtsng&quot;.Example 2:Input: s = &quot;poiinter&quot;Output: &quot;ponter&quot;Explanation: After the first character, the text on the screen is &quot;p&quot;.After the second character, the text is &quot;po&quot;. Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.After the fifth character, the text is &quot;pon&quot;.After the sixth character, the text is &quot;pont&quot;. After the seventh character, the text is &quot;ponte&quot;. After the eighth character, the text is &quot;ponter&quot;. Therefore, we return &quot;ponter&quot;. Constraints:1 &lt;= s.length &lt;= 100s consists of lowercase English letters.s[0] != &#39;i&#39;*/ | Class Solution {Public:    String Finalstring(string S) {    Int N=s.length();    String Ans=&quot;&quot;;    For(int I=0;i&lt;n;i++){        If(s[i]==&#39;i&#39;){            Ans=ans.substr(0,ans.length()-1);        }        Else{            Ans+=s[i];        }    }    Return Ans;    }}; | Class Solution {Public:    String Finalstring(const String &amp;S) {        String A, B;        For (Char Ch : S)            If (Ch == &#39;I&#39;)                Swap(a, B);            Else                A += Ch;        Return String(rbegin(b), Rend(b)) + A;    }}; 
 115 | 3 | Java | medium | StarCoder | IDE Extension | You are given a 0-indexed integer array nums and an integer x.Find the minimum absolute difference between two elements in the array that are at least x indices apart.In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.Example 1:Input: nums = [4,3,2,4], x = 2Output: 0Explanation: We can select nums[0] = 4 and nums[3] = 4. They are at least 2 indices apart, and their absolute difference is the minimum, 0. It can be shown that 0 is the optimal answer.Example 2:Input: nums = [5,3,2,10,15], x = 1Output: 1Explanation: We can select nums[1] = 3 and nums[2] = 2.They are at least 1 index apart, and their absolute difference is the minimum, 1.It can be shown that 1 is the optimal answer.Example 3:Input: nums = [1,2,3,4], x = 3Output: 3Explanation: We can select nums[0] = 1 and nums[3] = 4.They are at least 3 indices apart, and their absolute difference is the minimum, 3.It can be shown that 3 is the optimal answer. Constraints:1 &lt;= nums.length &lt;= 10^51 &lt;= nums[i] &lt;= 10^90 &lt;= x &lt; nums.length  | class Solution {        /*         * You are given a 0-indexed integer array nums and an integer x.Find the minimum absolute difference between two elements in the array that are at least x indices apart.In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.Example 1:Input: nums = [4,3,2,4], x = 2Output: 0Explanation: We can select nums[0] = 4 and nums[3] = 4. They are at least 2 indices apart, and their absolute difference is the minimum, 0. It can be shown that 0 is the optimal answer.Example 2:Input: nums = [5,3,2,10,15], x = 1Output: 1Explanation: We can select nums[1] = 3 and nums[2] = 2.They are at least 1 index apart, and their absolute difference is the minimum, 1.It can be shown that 1 is the optimal answer.Example 3:Input: nums = [1,2,3,4], x = 3Output: 3Explanation: We can select nums[0] = 1 and nums[3] = 4.They are at least 3 indices apart, and their absolute difference is the minimum, 3.It can be shown that 3 is the optimal answer. Constraints:1 &lt;= nums.length &lt;= 10^51 &lt;= nums[i] &lt;= 10^90 &lt;= x &lt; nums.length*/    public int minAbsoluteDifference(List&lt;Integer&gt; nums, int x) { | Class Solution {    Public Int Minabsolutedifference(list&lt;integer&gt; Nums, Int X) {        Int N = Nums.size();        Int[] Arr  = New Int[n];        For(int I = 0; I &lt; N; I++) {            Arr[i] = Nums.get(i);        }        Arrays.sort(arr);        Int Res = Integer.max_value;        For(int I =  0; I &lt; N; I++) {            Int Left = I + 1;            Int Right = N - 1;            While(left &lt;= Right) {                Int Mid = Left + (Right - Left) / 2;                If(arr[mid] - Arr[  I] &gt;= X) {                    Right = Mid - 1;                } Else {                    Left = Mid + 1;                }            }            If(left &lt; N) {                Res = Math.min(res, Arr[left] - Arr[i]);            }            Left  = 0;            Right = I - 1;            While(left &lt;= Right) {                Int Mid = Left + (Right - Left) / 2;                If(arr[i] - Arr[mid] &gt;= X) {                    Left = Mid + 1;                 } Else {                    Right = Mid - 1;                }            }            If(right &gt;= 0) {                Res = Math.min(res, Arr[i] - Arr[right]);            }        }        Return Res;    }}  | Class Solution {    Int Minabsolutedifference(list&lt;integer&gt; Nums, Int X) {        Int Ans = Integer.max_value;        Treeset&lt;integer&gt; S = New Treeset&lt;&gt;();        For(int I = X; I &lt; Nums.size(); ++I){            S.add(nums.get(i-x));            Integer High = S.ceiling(nums.get(i)), Low = S.floor(nums.get(i));            If(high != Null) Ans = Math.min(ans, Math.abs(nums.get(i) - High));            If(low != Null) Ans = Math.min(ans, Math.abs(nums.get(i) - Low));        }        Return Ans;    }} 
 116 | 3 | Python | medium | StarCoder | IDE Extension | You are given a 0-indexed integer array nums and an integer x.Find the minimum absolute difference between two elements in the array that are at least x indices apart.In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.Example 1:Input: nums = [4,3,2,4], x = 2Output: 0Explanation: We can select nums[0] = 4 and nums[3] = 4. They are at least 2 indices apart, and their absolute difference is the minimum, 0. It can be shown that 0 is the optimal answer.Example 2:Input: nums = [5,3,2,10,15], x = 1Output: 1Explanation: We can select nums[1] = 3 and nums[2] = 2.They are at least 1 index apart, and their absolute difference is the minimum, 1.It can be shown that 1 is the optimal answer.Example 3:Input: nums = [1,2,3,4], x = 3Output: 3Explanation: We can select nums[0] = 1 and nums[3] = 4.They are at least 3 indices apart, and their absolute difference is the minimum, 3.It can be shown that 3 is the optimal answer. Constraints:1 &lt;= nums.length &lt;= 10^51 &lt;= nums[i] &lt;= 10^90 &lt;= x &lt; nums.length  | class Solution:    def minAbsoluteDifference(self, nums: List[int], x: int) -&gt; int:&quot;&quot;&quot;You are given a 0-indexed integer array nums and an integer x.Find the minimum absolute difference between two elements in the array that are at least x indices apart.In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.Example 1:Input: nums = [4,3,2,4], x = 2Output: 0Explanation: We can select nums[0] = 4 and nums[3] = 4. They are at least 2 indices apart, and their absolute difference is the minimum, 0. It can be shown that 0 is the optimal answer.Example 2:Input: nums = [5,3,2,10,15], x = 1Output: 1Explanation: We can select nums[1] = 3 and nums[2] = 2.They are at least 1 index apart, and their absolute difference is the minimum, 1.It can be shown that 1 is the optimal answer.Example 3:Input: nums = [1,2,3,4], x = 3Output: 3Explanation: We can select nums[0] = 1 and nums[3] = 4.They are at least 3 indices apart, and their absolute difference is the minimum, 3.It can be shown that 3 is the optimal answer. Constraints:1 &lt;= nums.length &lt;= 10^51 &lt;= nums[i] &lt;= 10^90 &lt;= x &lt; nums.length &quot;&quot;&quot; | Class Solution:    Def Minabsolutedifference(self, Nums: List[int], X: Int) -&gt; Int:        Nums.sort()        N = Len(nums)        Ans = Float(&#39;inf&#39;)        For I In Range(n):            For J In Range(i+1, N):                If Abs(nums[i] - Nums[j]) &lt; Ans:                    Ans = Abs(nums[i] - Nums[j])                If Abs(nums[i] - Nums[j]) == Ans And Abs(nums[i] - X) &lt; Abs(nums[j] - X):                    Ans = Abs(nums[i] - X)        Return Ans | Class Solution:  Def Minabsolutedifference(self, Nums: List[int], X: Int) -&gt; Int:    If X == 0:      Return 0    Arr, Best_dist = Sortedlist([]), Float(&#39;inf&#39;)    For I In Range(x, Len(nums)):      Arr.add(nums[i - X])      V = Nums[i]      Pos = Arr.bisect_left(v)      If Pos &lt; Len(arr):        Best_dist = Min(best_dist, Abs(arr[pos] - V))      If Pos &gt; 0:        Best_dist = Min(best_dist, Abs(arr[pos - 1] - V))        Return Best_dist 
 117 | 3 | C++ | medium | StarCoder | IDE Extension | You are given a 0-indexed integer array nums and an integer x.Find the minimum absolute difference between two elements in the array that are at least x indices apart.In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.Example 1:Input: nums = [4,3,2,4], x = 2Output: 0Explanation: We can select nums[0] = 4 and nums[3] = 4. They are at least 2 indices apart, and their absolute difference is the minimum, 0. It can be shown that 0 is the optimal answer.Example 2:Input: nums = [5,3,2,10,15], x = 1Output: 1Explanation: We can select nums[1] = 3 and nums[2] = 2.They are at least 1 index apart, and their absolute difference is the minimum, 1.It can be shown that 1 is the optimal answer.Example 3:Input: nums = [1,2,3,4], x = 3Output: 3Explanation: We can select nums[0] = 1 and nums[3] = 4.They are at least 3 indices apart, and their absolute difference is the minimum, 3.It can be shown that 3 is the optimal answer. Constraints:1 &lt;= nums.length &lt;= 10^51 &lt;= nums[i] &lt;= 10^90 &lt;= x &lt; nums.length  | class Solution {public:    int minAbsoluteDifference(vector&lt;int&gt;&amp; nums, int x) {/*You are given a 0-indexed integer array nums and an integer x.Find the minimum absolute difference between two elements in the array that are at least x indices apart.In other words, find two indices i and j such that abs(i - j) &gt;= x and abs(nums[i] - nums[j]) is minimized.Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.Example 1:Input: nums = [4,3,2,4], x = 2Output: 0Explanation: We can select nums[0] = 4 and nums[3] = 4. They are at least 2 indices apart, and their absolute difference is the minimum, 0. It can be shown that 0 is the optimal answer.Example 2:Input: nums = [5,3,2,10,15], x = 1Output: 1Explanation: We can select nums[1] = 3 and nums[2] = 2.They are at least 1 index apart, and their absolute difference is the minimum, 1.It can be shown that 1 is the optimal answer.Example 3:Input: nums = [1,2,3,4], x = 3Output: 3Explanation: We can select nums[0] = 1 and nums[3] = 4.They are at least 3 indices apart, and their absolute difference is the minimum, 3.It can be shown that 3 is the optimal answer. Constraints:1 &lt;= nums.length &lt;= 10^51 &lt;= nums[i] &lt;= 10^90 &lt;= x &lt; nums.length*/ | Class Solution {Public:    Int Minabsolutedifference(vector&lt;int&gt;&amp; Nums, Int X) {    Int N=nums.size();    Vector&lt;int&gt;v;    For(int I=0;i&lt;n;i++)    {        V.push_back(abs(nums[i]-x));    }    Sort(v.begin(),v.end());    Int Ans=v[0];    For(int I=1;i&lt;n;i++)    {        Ans=min(ans,v[i]-v[i-1]);    }    Return Ans;    }}; | Class Solution {Public:    Int Minabsolutedifference(vector&lt;int&gt;&amp; Nums, Int X) {        Int Ans = Int_max;        Set&lt;int&gt; S;        For(int I = X; I &lt; Nums.size(); ++I){            S.insert(nums[i-x]);            Auto It = S.upper_bound(nums[i]);            If(it != S.end()) Ans = Min(ans, Abs(nums[i] - *It));            If(it != S.begin()) Ans = Min(ans, Abs(nums[i] - *Prev(it)));        }        Return Ans;    }}; 
 118 | 4 | Java | medium | StarCoder | IDE Extension | You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.Return the head of the linked list after doubling it.Example 1:Input: head = [1,8,9]Output: [3,7,8]Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.Example 2:Input: head = [9,9,9]Output: [1,9,9,8]Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. Constraints:The number of nodes in the list is in the range [1, 10^4]0 &lt;= Node.val &lt;= 9The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.  | class Solution {    public ListNode doubleIt(ListNode head) {/*You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.Return the head of the linked list after doubling it.Example 1:Input: head = [1,8,9]Output: [3,7,8]Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.Example 2:Input: head = [9,9,9]Output: [1,9,9,8]Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. Constraints:The number of nodes in the list is in the range [1, 10^4]0 &lt;= Node.val &lt;= 9The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.*/ | Class Solution {    Public Listnode Doubleit(listnode Head) {    Listnode Dummy = New Listnode(0);    Dummy.next = Head;    Listnode Cur = Dummy;    While (Cur.next != Null &amp;&amp; Cur.next.next != Null) {        Listnode Next = Cur.next.next;        Cur.next.next =  Next.next;        Next.next = Cur.next;        Cur.next = Next;        Cur = Cur.next.next;    }    Return Dummy.next;    }} | Class Solution {    Public Listnode Doubleit(listnode Head) {        If (Head.val &gt; 4)            Head = New Listnode(0, Head);        For(listnode Node = Head; Node != Null; Node = Node.next) {            Node.val = (Node.val * 2) % 10;            If (Node.next != Null &amp;&amp; Node.next.val &gt; 4)                Node.val++;        }        Return Head;    }} 
 119 | 4 | Python | medium | StarCoder | IDE Extension | You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.Return the head of the linked list after doubling it.Example 1:Input: head = [1,8,9]Output: [3,7,8]Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.Example 2:Input: head = [9,9,9]Output: [1,9,9,8]Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. Constraints:The number of nodes in the list is in the range [1, 10^4]0 &lt;= Node.val &lt;= 9The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.  | class Solution:    def doubleIt(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:&quot;&quot;&quot;You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.Return the head of the linked list after doubling it.Example 1:Input: head = [1,8,9]Output: [3,7,8]Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.Example 2:Input: head = [9,9,9]Output: [1,9,9,8]Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. Constraints:The number of nodes in the list is in the range [1, 10^4]0 &lt;= Node.val &lt;= 9The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself. &quot;&quot;&quot; | Class Solution:    Def Doubleit(self, Head: Optional[listnode]) -&gt; Optional[listnode]:        If Head Is None:            Return None        Temp = Head        While Temp Is Not None:            Temp.val *= 2            Temp = Temp.next        Return Head | Class Solution:    Def Doubleit(self, Head: Optional[listnode]) -&gt; Optional[listnode]:        If Head.val &gt; 4:            Head = Listnode(0, Head)        Node = Head        While Node:            Node.val = (Node.val * 2) % 10            If Node.next And Node.next.val &gt; 4:                Node.val += 1            Node = Node.next        Return Head 
 120 | 4 | C++ | medium | StarCoder | IDE Extension | You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.Return the head of the linked list after doubling it.Example 1:Input: head = [1,8,9]Output: [3,7,8]Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.Example 2:Input: head = [9,9,9]Output: [1,9,9,8]Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. Constraints:The number of nodes in the list is in the range [1, 10^4]0 &lt;= Node.val &lt;= 9The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.  | class Solution {public:    ListNode* doubleIt(ListNode* head) {/*You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.Return the head of the linked list after doubling it.Example 1:Input: head = [1,8,9]Output: [3,7,8]Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.Example 2:Input: head = [9,9,9]Output: [1,9,9,8]Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. Constraints:The number of nodes in the list is in the range [1, 10^4]0 &lt;= Node.val &lt;= 9The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself. */ | Class Solution {Public:    Listnode* Doubleit(listnode* Head) {        Listnode* Temp=head;        While(temp!=null){            Listnode* Temp2=temp-&gt;next;            Temp-&gt;next=new Listnode(temp-&gt;val);            Temp-&gt;next-&gt;next=temp2;            Temp=temp2;        }        Return Head;    }}; | Class Solution {Public:    Listnode* Doubleit(listnode* Head) {        If (Head-&gt;val &gt; 4)            Head = New Listnode(0, Head);        For(listnode* Node = Head; Node; Node = Node-&gt;next) {            Node-&gt;val = (Node-&gt;val * 2) % 10;            If (Node-&gt;next &amp;&amp; Node-&gt;next-&gt;val &gt; 4)                Node-&gt;val++;        }        Return Head;    }}; 
 121 | 5 | Java | hard | StarCoder | IDE Extension | You are given an array nums of n positive integers and an integer k.Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.Multiply your score by x.Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.Return the maximum possible score after applying at most k operations.Since the answer may be large, return it modulo 10^9 + 7.Example 1:Input: nums = [8,3,9,3,8], k = 2Output: 81Explanation: To get a score of 81, we can apply the following operations:- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.It can be proven that 81 is the highest score one can obtain.Example 2:Input: nums = [19,12,14,6,10,18], k = 3Output: 4788Explanation: To get a score of 4788, we can apply the following operations: - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.It can be proven that 4788 is the highest score one can obtain. Constraints:1 &lt;= nums.length == n &lt;= 10^51 &lt;= nums[i] &lt;= 10^51 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9)  | public class Solution {/* * You are given an array nums of n positive integers and an integer k.Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.Multiply your score by x.Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.Return the maximum possible score after applying at most k operations.Since the answer may be large, return it modulo 10^9 + 7.Constraints:1 &lt;= nums.length == n &lt;= 10^51 &lt;= nums[i] &lt;= 10^51 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9).*/    public int maximumScore(List&lt;Integer&gt; nums, int k) { | Public Class Solution {    Public Int Maximumscore(list&lt;integer&gt; Nums, Int K) {                Int N = Nums.size();        Int[] Dp = New Int[n];        Int[] Prime = New Int[n];        Int[] Primecount = New Int[n];        Int[] Prefix = New Int[n];        Int[] Suffix = New Int[n];                        For(int I = 0; I &lt; N; I++){            Dp[i] = Nums.get(i);            Prime[i] = Getprime(nums.get(i));            Primecount[i] = Getprimecount(nums.get(i));                    }                For(int I = 1; I &lt; N; I++){            Prefix[i] = Prefix[i-1] + Primecount[i-1];        }                For(int I = N-2; I &gt;= 0; I--){            Suffix[  I] = Suffix[i+1] + Primecount[i+1];        }                Int[] Dp2 = New Int[n];        Int[] Dp3 = New Int[n];        Int[] Dp4 = New Int[n];                For(int I = 0  ; I &lt; N; I++){            Dp2[i] = Dp[i];            Dp3[i] = Dp[i];            Dp4[i] = Dp[i];        }                For(int I = 0; I &lt; K; I++){            Int Max  = -1;            Int Maxindex = -1;            For(int J = 0; J &lt; N; J++){                If(j == 0){                    Dp2[j] = Dp[j] * Prime[j];                }Else{                    Dp2[j  ] = Math.max(dp2[j-1], Dp[j] * Prime[j]);                }                                If(j == N-1){                    Dp3[j] = Dp[j] * Prime[j];                }Else{                    Dp3[j]  = Math.max(dp3[j+1], Dp[j] * Prime[j]);                }                                If(prefix[j] + Suffix[j] - Primecount[j] &gt; Max){                    Max = Prefix[j] + Suffix[j] - Primecount  [J];                    Maxindex = J;                }            }                        Dp4[maxindex] = 0;                        For(int J = 0; J &lt; N; J++){                If(j == 0){                    Dp4[j] = Math.max(dp4  [J], Dp2[j]);                }Else If(j == N-1){                    Dp4[j] = Math.max(dp4[j], Dp3[j]);                }Else{                    Dp4[j] = Math.max(dp4[j],  Math.max(dp2[j], Dp3[j]));                }            }                        For(int J = 0; J &lt; N; J++){                Dp[j] = Dp4[j];            }        }                Int Sum = 0;        For(int I  = 0; I &lt; N; I++){            Sum = (Sum + Dp[i]) % 1000000007;        }                Return Sum;    }        Public Int Getprime(int Num){        Int Count = 0;        For(  Int I = 2; I &lt;= Num; I++){            If(num % I == 0){                Count++;            }        }        Return Count;    }        Public Int Getprimecount(int Num){        Int Count = 0;        For(  Int I =  2; I &lt;= Num; I++){            If(num % I == 0){                Count++;            }        }        Return Count - 1;    }} | Class Solution {    Static Final Int Mod = 1000000007;    Public Int Maximumscore(list&lt;integer&gt; Nums, Int K) {        Int N = Nums.size();        Int Upper = Collections.max(nums) + 1;        Boolean[] Prime = New Boolean[upper];        Int[] Primescore = New Int[upper];        Arrays.fill(prime, True);        Prime[0] = Prime[1] = False;        For (Int I = 2; I &lt; Upper; I++) {            If (Prime[i]) {                For (Int J = I; J &lt; Upper; J += I) {                    Primescore[j]++;                    Prime[j] = False;                }            }        }        Int[] Nextgreaterelement = New Int[n];        Arrays.fill(nextgreaterelement, N);        Stack&lt;integer&gt; S = New Stack&lt;&gt;();        For (Int I = N - 1; I &gt;= 0; I--) {            While (!S.empty() &amp;&amp; Primescore[nums.get(i)] &gt;= Primescore[nums.get(s.peek())]) {                S.pop();            }            Nextgreaterelement[i] = S.empty() ? N : S.peek();            S.push(i);        }        Int[] Prevgreaterorequalelement = New Int[n];        Arrays.fill(prevgreaterorequalelement, -1);        S = New Stack&lt;&gt;();        For (Int I = 0; I &lt; N; I++) {            While (!S.empty() &amp;&amp; Primescore[nums.get(i)] &gt; Primescore[nums.get(s.peek())]) {                S.pop();            }            Prevgreaterorequalelement[i] = S.empty() ? -1 : S.peek();            S.push(i);        }        Int Res = 1;        Int[][] Tuples = New Int[n][2];        For (Int I = 0; I &lt; N; I++) {            Tuples[i][0] = Nums.get(i);            Tuples[i][1] = I;        }        Arrays.sort(tuples, New Comparator&lt;int[]&gt;() {            Public Int Compare(int[] A, Int[] B) {                Return B[0] - A[0];            }        });        For (Int I = 0; I &lt; N; I++) {            Int Num = Tuples[i][0];            Int Idx = Tuples[i][1];            Int Operations = Math.min((idx - Prevgreaterorequalelement[idx]) * (Nextgreaterelement[idx] - Idx), K);            Res = (Int)((1l * Res * Pow(num, Operations)) % Mod);            K -= Operations;            If (K == 0) {                Return Res;            }        }        Return Res;    }    Public Int Pow(int X, Int N) {        Int Res = 1;        While (N &gt; 0) {            If (N % 2 == 1) {                Res = (Int)((1l * Res * X) % Mod);            }            X = (Int)((1l * X * X) % Mod);            N /= 2;        }        Return Res;    }} 
 122 | 5 | Python | hard | StarCoder | IDE Extension | You are given an array nums of n positive integers and an integer k.Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.Multiply your score by x.Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.Return the maximum possible score after applying at most k operations.Since the answer may be large, return it modulo 10^9 + 7.Example 1:Input: nums = [8,3,9,3,8], k = 2Output: 81Explanation: To get a score of 81, we can apply the following operations:- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.It can be proven that 81 is the highest score one can obtain.Example 2:Input: nums = [19,12,14,6,10,18], k = 3Output: 4788Explanation: To get a score of 4788, we can apply the following operations: - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.It can be proven that 4788 is the highest score one can obtain. Constraints:1 &lt;= nums.length == n &lt;= 10^51 &lt;= nums[i] &lt;= 10^51 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9)  | class Solution:    def maximumScore(self, nums: List[int], k: int) -&gt; int:&quot;&quot;&quot;You are given an array nums of n positive integers and an integer k.Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.Multiply your score by x.Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.Return the maximum possible score after applying at most k operations.Since the answer may be large, return it modulo 10^9 + 7.Example 1:Input: nums = [8,3,9,3,8], k = 2Output: 81Explanation: To get a score of 81, we can apply the following operations:- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.It can be proven that 81 is the highest score one can obtain.Example 2:Input: nums = [19,12,14,6,10,18], k = 3Output: 4788Explanation: To get a score of 4788, we can apply the following operations: - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.It can be proven that 4788 is the highest score one can obtain. Constraints:1 &lt;= nums.length == n &lt;= 10^51 &lt;= nums[i] &lt;= 10^51 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9) &quot;&quot;&quot; | Class Solution:    Def Maximumscore(self, Nums: List[int], K: Int) -&gt; Int:        N = Len(nums)        Dp = [0]*n        Dp[0] = Nums[0]        For I In Range(1, N):            Dp[i] = Max(dp[i-1], Nums[i])        Ans = Dp[k-1]        For I In Range(k-1, N):            Ans = Max(ans, Dp[i] * Dp[k-1-i])        Return Ans % (10**9 + 7) | Class Solution:     Mod = 1000000007    Def Maximumscore(self, Nums: List[int], K: Int) -&gt; Int:        N = Len(nums)        Upper = Max(nums) + 1        Prime = [True]*upper        Prime[0] = Prime[1] = False        Primescore = [0]*upper        For I In Range(2, Upper):            If Prime[i]:                For J In Range(i, Upper, I):                    Primescore[j] += 1                    Prime[j] = False        Nextgreaterelement = [N]*n        S = []        For I In Range(n - 1, -1, -1):            While S And Primescore[nums[i]] &gt;= Primescore[nums[s[-1]]]:                S.pop()            Nextgreaterelement[i] = S[-1] If S Else N            S.append(i)        Prevgreaterorequalelement = [-1]*n        S = []        For I In Range(n):            While S And Primescore[nums[i]] &gt; Primescore[nums[s[-1]]]:                S.pop()            Prevgreaterorequalelement[i] = S[-1] If S Else -1            S.append(i)        Res = 1        Tuples = [[Nums[i], I] For I In Range(n)]        Tuples.sort(reverse=true)        For Num, Idx In Tuples:            Operations = Min((idx - Prevgreaterorequalelement[idx]) * (Nextgreaterelement[idx] - Idx), K)            Res = (Res * Self.pow(num, Operations)) % Self.mod            K -= Operations            If K == 0:                Return Res        Return Res    Def Pow(self, X: Int, N: Int) -&gt; Int:        Res = 1        While N &gt; 0:            If N % 2 == 1:                Res = (Res * X) % Self.mod            X = (X * X) % Self.mod            N //= 2        Return Res 
 123 | 5 | C++ | hard | StarCoder | IDE Extension | You are given an array nums of n positive integers and an integer k.Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.Multiply your score by x.Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.Return the maximum possible score after applying at most k operations.Since the answer may be large, return it modulo 10^9 + 7.Example 1:Input: nums = [8,3,9,3,8], k = 2Output: 81Explanation: To get a score of 81, we can apply the following operations:- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.It can be proven that 81 is the highest score one can obtain.Example 2:Input: nums = [19,12,14,6,10,18], k = 3Output: 4788Explanation: To get a score of 4788, we can apply the following operations: - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.It can be proven that 4788 is the highest score one can obtain. Constraints:1 &lt;= nums.length == n &lt;= 10^51 &lt;= nums[i] &lt;= 10^51 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9)  | class Solution {public:    int maximumScore(vector&lt;int&gt;&amp; nums, int k) {/*You are given an array nums of n positive integers and an integer k.Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:Choose any non-empty subarray nums[l, ..., r] that you haven&#39;t chosen previously.Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.Multiply your score by x.Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.Return the maximum possible score after applying at most k operations.Since the answer may be large, return it modulo 10^9 + 7.Example 1:Input: nums = [8,3,9,3,8], k = 2Output: 81Explanation: To get a score of 81, we can apply the following operations:- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.It can be proven that 81 is the highest score one can obtain.Example 2:Input: nums = [19,12,14,6,10,18], k = 3Output: 4788Explanation: To get a score of 4788, we can apply the following operations: - Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.It can be proven that 4788 is the highest score one can obtain. Constraints:1 &lt;= nums.length == n &lt;= 10^51 &lt;= nums[i] &lt;= 10^51 &lt;= k &lt;= min(n * (n + 1) / 2, 10^9)*/ | Class Solution {Public:    Int Maximumscore(vector&lt;int&gt;&amp; Nums, Int K) {        Int Mod=1e9+7;        Int N=nums.size();        Vector&lt;int&gt; Dp(n+1,0);        Vector&lt;int&gt; Primes;        For(int I=2;i&lt;=n;i++) {            If(dp[i]==0) {                Primes.push_back(i);                For(int J=i;j&lt;=n;j+=i) {                    Dp[j]+=1;                }            }        }        Int Ans=0;        For(int I=0;i&lt;k;i++) {            Int Mx=0;            Int Mx_idx=-1;            For(int J=i;j&lt;n;j++) {                If(mx&lt;dp[j]) {                    Mx=dp[j];                    Mx_idx=j;                }            }            Ans=(ans+nums[mx_idx]*primes[mx-1])%mod;            Dp[mx_idx]=0;        }        Return Ans;    }}; | Class Solution {Public:    Const Int Mod = 1000000007;    Int Maximumscore(vector&lt;int&gt;&amp; Nums, Int K) {        Int N = Nums.size();        Int Upper = *Max_element(nums.begin(), Nums.end()) + 1;        Vector&lt;bool&gt; Prime(upper, True);        Prime[0] = Prime[1] = False;        Vector&lt;int&gt; Primescore(upper, 0);        For (Int I = 2; I &lt; Upper; I++) {            If (Prime[i]) {                For (Int J = I; J &lt; Upper; J += I) {                    Primescore[j]++;                    Prime[j] = False;                }            }        }        Vector&lt;int&gt; Nextgreaterelement(n, N);        Stack&lt;int&gt; S;        For (Int I = N - 1; I &gt;= 0; I--) {            While (!S.empty() &amp;&amp; Primescore[nums[i]] &gt;= Primescore[nums[s.top()]]) {                S.pop();            }            Nextgreaterelement[i] = S.empty() ? N : S.top();            S.push(i);        }        Vector&lt;int&gt; Prevgreaterorequalelement(n, -1);        S = Stack&lt;int&gt;();        For (Int I = 0; I &lt; N; I++) {            While (!S.empty() &amp;&amp; Primescore[nums[i]] &gt; Primescore[nums[s.top()]]) {                S.pop();            }            Prevgreaterorequalelement[i] = S.empty() ? -1 : S.top();            S.push(i);        }        Int Res = 1;        Vector&lt;pair&lt;int, Int&gt;&gt; Tuples(n);        For (Int I = 0; I &lt; N; I++) {            Tuples[i].first = Nums[i];            Tuples[i].second = I;        }        Sort(tuples.rbegin(), Tuples.rend());        For (Const Auto&amp; [Num, I] : Tuples) {            Int Operations = Min((i - Prevgreaterorequalelement[i]) * (Nextgreaterelement[i] - I), K);            Res = (Int)((1l * Res * Pow(num, Operations)) % Mod);            K -= Operations;            If (K == 0) {                Return Res;            }        }        Return Res;    }    Int Pow(int X, Int N) {        Int Res = 1;        While (N &gt; 0) {            If (N % 2 == 1) {                Res = (Int)((1l * Res * X) % Mod);            }            X = (Int)((1l * X * X) % Mod);            N /= 2;        }        Return Res;    }}; 
 124 | 6 | Java | hard | StarCoder | IDE Extension | You are given a 0-indexed 2D integer array items of length n and an integer k.items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.Your task is to find the maximum elegance from all subsequences of size k in items.Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.Example 1:Input: items = [[3,2],[5,1],[10,1]], k = 2Output: 17Explanation: In this example, we have to select a subsequence of size 2.We can select items[0] = [3,2] and items[2] = [10,1].The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. Example 2:Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3Output: 19Explanation: In this example, we have to select a subsequence of size 3. We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.Example 3:Input: items = [[1,1],[2,1],[3,1]], k = 3Output: 7Explanation: In this example, we have to select a subsequence of size 3. We should select all the items. The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. Hence, the maximum elegance is 6 + 1^2 = 7.   Constraints:1 &lt;= items.length == n &lt;= 10^5items[i].length == 2items[i][0] == profit_iitems[i][1] == category_i1 &lt;= profit_i &lt;= 10^91 &lt;= category_i &lt;= n 1 &lt;= k &lt;= n  | public class Solution {    public int findMaximumElegance(int[][] items, int k) {/* * You are given a 0-indexed 2D integer array items of length n and an integer k.items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.Your task is to find the maximum elegance from all subsequences of size k in items.Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.Example 1:Input: items = [[3,2],[5,1],[10,1]], k = 2Output: 17Explanation: In this example, we have to select a subsequence of size 2.We can select items[0] = [3,2] and items[2] = [10,1].The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. Example 2:Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3Output: 19Explanation: In this example, we have to select a subsequence of size 3. We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.Example 3:Input: items = [[1,1],[2,1],[3,1]], k = 3Output: 7Explanation: In this example, we have to select a subsequence of size 3. We should select all the items. The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. Hence, the maximum elegance is 6 + 1^2 = 7.   Constraints:1 &lt;= items.length == n &lt;= 10^5items[i].length == 2items[i][0] == profit_iitems[i][1] == category_i1 &lt;= profit_i &lt;= 10^91 &lt;= category_i &lt;= n 1 &lt;= k &lt;= n*/ | Public Class Solution {    Public Int Findmaximumelegance(int[][] Items, Int K) {        Int N = Items.length;        Int[][] Dp = New Int[n][k];        For(int I=0; I&lt;n; I++) {            Dp[i][0] = Items[i][0];        }        For(int I=1; I  &lt;N; I++) {            For(int J=1; J&lt;k; J++) {                Int Max = Integer.min_value;                For(int M=0; M&lt;i; M++) {                    If(items[m][1] != Items[i][ 1]) {                        Max = Math.max(max, Dp[m][j-1]);                    }                }                Dp[i][j] = Max + Items[i][0];            }        }        Int Max = Integer.min_value;        For(int I= 0; I&lt;n; I++) {            Max = Math.max(max, Dp[i][k-1]);        }        Return Max;    }} | Class Solution {    Public Long Findmaximumelegance(int[][] A, Int K) {        Arrays.sort(a, (A, B) -&gt; B[0] - A[0]);        Long Res = 0, Cur = 0;        List&lt;integer&gt; Dup = New Arraylist&lt;&gt;();        Set&lt;integer&gt; Seen = New Hashset&lt;&gt;();        For (Int I = 0; I &lt; A.length; ++I) {            If (I &lt; K) {                If (Seen.contains(a[i][1])) {                    Dup.add(a[i][0]);                }                Cur += A[i][0];            } Else If (!Seen.contains(a[i][1])) {                If (Dup.isempty()) Break;                Cur += A[i][0] - Dup.remove(dup.size() - 1);            }            Seen.add(a[i][1]);            Res = Math.max(res, Cur + 1l * Seen.size() * Seen.size());        }        Return Res;    }} 
 125 | 6 | Python | hard | StarCoder | IDE Extension | You are given a 0-indexed 2D integer array items of length n and an integer k.items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.Your task is to find the maximum elegance from all subsequences of size k in items.Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.Example 1:Input: items = [[3,2],[5,1],[10,1]], k = 2Output: 17Explanation: In this example, we have to select a subsequence of size 2.We can select items[0] = [3,2] and items[2] = [10,1].The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. Example 2:Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3Output: 19Explanation: In this example, we have to select a subsequence of size 3. We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.Example 3:Input: items = [[1,1],[2,1],[3,1]], k = 3Output: 7Explanation: In this example, we have to select a subsequence of size 3. We should select all the items. The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. Hence, the maximum elegance is 6 + 1^2 = 7.   Constraints:1 &lt;= items.length == n &lt;= 10^5items[i].length == 2items[i][0] == profit_iitems[i][1] == category_i1 &lt;= profit_i &lt;= 10^91 &lt;= category_i &lt;= n 1 &lt;= k &lt;= n  | class Solution:    def findMaximumElegance(self, items: List[List[int]], k: int) -&gt; int:&quot;&quot;&quot;You are given a 0-indexed 2D integer array items of length n and an integer k.items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.Your task is to find the maximum elegance from all subsequences of size k in items.Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.Example 1:Input: items = [[3,2],[5,1],[10,1]], k = 2Output: 17Explanation: In this example, we have to select a subsequence of size 2.We can select items[0] = [3,2] and items[2] = [10,1].The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. Example 2:Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3Output: 19Explanation: In this example, we have to select a subsequence of size 3. We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.Example 3:Input: items = [[1,1],[2,1],[3,1]], k = 3Output: 7Explanation: In this example, we have to select a subsequence of size 3. We should select all the items. The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. Hence, the maximum elegance is 6 + 1^2 = 7.   Constraints:1 &lt;= items.length == n &lt;= 10^5items[i].length == 2items[i][0] == profit_iitems[i][1] == category_i1 &lt;= profit_i &lt;= 10^91 &lt;= category_i &lt;= n 1 &lt;= k &lt;= n &quot;&quot;&quot; | Class Solution:    Def Findmaximumelegance(self, Items: List[list[int]], K: Int) -&gt; Int:        N = Len(items)        Dp = [[0]*n For _ In Range(n)]        For I In Range(n):            Dp[i][i] = Items[i][0]        For L In Range(2, N+1):            For I In Range(n-l+1):                J = I+l-1                Dp[i][j] = Max(dp[i][j-1], Dp[i+1][j]) + Items[j][0]        Return Max(dp[0][k-1], Dp[n-k][n-1]) | Class Solution:    Def Findmaximumelegance(self, Items: List[list[int]], K: Int) -&gt; Int:        Items = Sorted(items, Key=lambda V: -V[0])        Res = Cur = 0        A = []        Seen = Set()        For I, (P, C) In Enumerate(items):            If I &lt; K:                If C In Seen:                    A.append(p)                Cur += P            Elif C Not In Seen:                If Not A: Break                Cur += P - A.pop()            Seen.add(c)            Res = Max(res, Cur + Len(seen) * Len(seen))        Return Res 
 126 | 6 | C++ | hard | StarCoder | IDE Extension | You are given a 0-indexed 2D integer array items of length n and an integer k.items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.Your task is to find the maximum elegance from all subsequences of size k in items.Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.Example 1:Input: items = [[3,2],[5,1],[10,1]], k = 2Output: 17Explanation: In this example, we have to select a subsequence of size 2.We can select items[0] = [3,2] and items[2] = [10,1].The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. Example 2:Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3Output: 19Explanation: In this example, we have to select a subsequence of size 3. We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.Example 3:Input: items = [[1,1],[2,1],[3,1]], k = 3Output: 7Explanation: In this example, we have to select a subsequence of size 3. We should select all the items. The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. Hence, the maximum elegance is 6 + 1^2 = 7.   Constraints:1 &lt;= items.length == n &lt;= 10^5items[i].length == 2items[i][0] == profit_iitems[i][1] == category_i1 &lt;= profit_i &lt;= 10^91 &lt;= category_i &lt;= n 1 &lt;= k &lt;= n  | class Solution {public:    long long findMaximumElegance(vector&lt;vector&lt;int&gt;&gt;&amp; items, int k) {/*You are given a 0-indexed 2D integer array items of length n and an integer k.items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.Let&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.Your task is to find the maximum elegance from all subsequences of size k in items.Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.Example 1:Input: items = [[3,2],[5,1],[10,1]], k = 2Output: 17Example 2:Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3Output: 19Example 3:Input: items = [[1,1],[2,1],[3,1]], k = 3Output: 7 Constraints:1 &lt;= items.length == n &lt;= 10^5items[i].length == 2items[i][0] == profit_iitems[i][1] == category_i1 &lt;= profit_i &lt;= 10^91 &lt;= category_i &lt;= n 1 &lt;= k &lt;= n */ | Class Solution {Public:    Long Long Findmaximumelegance(vector&lt;vector&lt;int&gt;&gt;&amp; Items, Int K) {  Int N=items.size();  Vector&lt;vector&lt;int&gt;&gt;dp(n,vector&lt;int&gt;(k,0));  For(int I=0;i&lt;n;i++)  {    Dp[i][0]=items[i][0];  }  For(int I=1;i&lt;n;i++)  {    For(int J=1;j&lt;k;j++)    {      Dp[i][j]=max(dp[i-1][j],dp[i-1][j-1]);      If(items[i][1]!=items[i-1][1])      {        Dp[i][j]=max(dp[i][j],dp[i-1][j]+items[i][0]);      }    }  }  Return Dp[n-1][k-1];    }}; | Class Solution {Public:    Long Long Findmaximumelegance(vector&lt;vector&lt;int&gt;&gt;&amp; A, Int K) {        Sort(a.begin(), A.end(), [](Const Vector&lt;int&gt;&amp; A, Const Vector&lt;int&gt;&amp; B) {            Return A[0] &gt; B[0];        });        Long Long Res = 0, Cur = 0;        Vector&lt;int&gt; Dup;        Unordered_set&lt;int&gt; Seen;        For (Int I = 0; I &lt; A.size(); ++I) {            If (I &lt; K) {                If (Seen.count(a[i][1])) {                    Dup.push_back(a[i][0]);                }                Cur += A[i][0];            } Else If (Seen.find(a[i][1]) == Seen.end()) {                If (Dup.empty()) Break;                Cur += A[i][0] - Dup.back();                Dup.pop_back();            }            Seen.insert(a[i][1]);            Res = Fmax(res, Cur + 1l * Seen.size() * Seen.size());        }        Return Res;    }}; 

